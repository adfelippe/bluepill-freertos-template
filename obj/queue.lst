ARM GAS  /tmp/ccdqkONZ.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"queue.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.align	1
  16              		.global	xQueueGenericReset
  17              		.syntax unified
  18              		.thumb
  19              		.thumb_func
  20              		.fpu softvfp
  21              		.type	xQueueGenericReset, %function
  22              	xQueueGenericReset:
  23              	.LFB5:
  24              		.file 1 "FreeRTOS/Source/queue.c"
   1:FreeRTOS/Source/queue.c **** /*
   2:FreeRTOS/Source/queue.c ****  * FreeRTOS Kernel V10.3.1
   3:FreeRTOS/Source/queue.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Source/queue.c ****  *
   5:FreeRTOS/Source/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Source/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Source/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Source/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Source/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Source/queue.c ****  * subject to the following conditions:
  11:FreeRTOS/Source/queue.c ****  *
  12:FreeRTOS/Source/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/Source/queue.c ****  * copies or substantial portions of the Software.
  14:FreeRTOS/Source/queue.c ****  *
  15:FreeRTOS/Source/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:FreeRTOS/Source/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:FreeRTOS/Source/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:FreeRTOS/Source/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:FreeRTOS/Source/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:FreeRTOS/Source/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:FreeRTOS/Source/queue.c ****  *
  22:FreeRTOS/Source/queue.c ****  * http://www.FreeRTOS.org
  23:FreeRTOS/Source/queue.c ****  * http://aws.amazon.com/freertos
  24:FreeRTOS/Source/queue.c ****  *
  25:FreeRTOS/Source/queue.c ****  * 1 tab == 4 spaces!
  26:FreeRTOS/Source/queue.c ****  */
  27:FreeRTOS/Source/queue.c **** 
  28:FreeRTOS/Source/queue.c **** #include <stdlib.h>
  29:FreeRTOS/Source/queue.c **** #include <string.h>
  30:FreeRTOS/Source/queue.c **** 
  31:FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  32:FreeRTOS/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  33:FreeRTOS/Source/queue.c **** task.h is included from an application file. */
ARM GAS  /tmp/ccdqkONZ.s 			page 2


  34:FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  35:FreeRTOS/Source/queue.c **** 
  36:FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  37:FreeRTOS/Source/queue.c **** #include "task.h"
  38:FreeRTOS/Source/queue.c **** #include "queue.h"
  39:FreeRTOS/Source/queue.c **** 
  40:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  41:FreeRTOS/Source/queue.c **** 	#include "croutine.h"
  42:FreeRTOS/Source/queue.c **** #endif
  43:FreeRTOS/Source/queue.c **** 
  44:FreeRTOS/Source/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  45:FreeRTOS/Source/queue.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  46:FreeRTOS/Source/queue.c **** for the header files above, but not in this file, in order to generate the
  47:FreeRTOS/Source/queue.c **** correct privileged Vs unprivileged linkage and placement. */
  48:FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  49:FreeRTOS/Source/queue.c **** 
  50:FreeRTOS/Source/queue.c **** 
  51:FreeRTOS/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  52:FreeRTOS/Source/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  53:FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  54:FreeRTOS/Source/queue.c **** 
  55:FreeRTOS/Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:FreeRTOS/Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  57:FreeRTOS/Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:FreeRTOS/Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:FreeRTOS/Source/queue.c **** structure instead holds a pointer to the mutex holder (if any).  Map alternative
  60:FreeRTOS/Source/queue.c **** names to the pcHead and structure member to ensure the readability of the code
  61:FreeRTOS/Source/queue.c **** is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  62:FreeRTOS/Source/queue.c **** a union as their usage is mutually exclusive dependent on what the queue is
  63:FreeRTOS/Source/queue.c **** being used for. */
  64:FreeRTOS/Source/queue.c **** #define uxQueueType						pcHead
  65:FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  66:FreeRTOS/Source/queue.c **** 
  67:FreeRTOS/Source/queue.c **** typedef struct QueuePointers
  68:FreeRTOS/Source/queue.c **** {
  69:FreeRTOS/Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
  70:FreeRTOS/Source/queue.c **** 	int8_t *pcReadFrom;				/*< Points to the last place that a queued item was read from when the stru
  71:FreeRTOS/Source/queue.c **** } QueuePointers_t;
  72:FreeRTOS/Source/queue.c **** 
  73:FreeRTOS/Source/queue.c **** typedef struct SemaphoreData
  74:FreeRTOS/Source/queue.c **** {
  75:FreeRTOS/Source/queue.c **** 	TaskHandle_t xMutexHolder;		 /*< The handle of the task that holds the mutex. */
  76:FreeRTOS/Source/queue.c **** 	UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex ha
  77:FreeRTOS/Source/queue.c **** } SemaphoreData_t;
  78:FreeRTOS/Source/queue.c **** 
  79:FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  80:FreeRTOS/Source/queue.c **** zero. */
  81:FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
  82:FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
  83:FreeRTOS/Source/queue.c **** 
  84:FreeRTOS/Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
  85:FreeRTOS/Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  86:FreeRTOS/Source/queue.c **** 	performed just because a higher priority task has been woken. */
  87:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
  88:FreeRTOS/Source/queue.c **** #else
  89:FreeRTOS/Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  90:FreeRTOS/Source/queue.c **** #endif
ARM GAS  /tmp/ccdqkONZ.s 			page 3


  91:FreeRTOS/Source/queue.c **** 
  92:FreeRTOS/Source/queue.c **** /*
  93:FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
  94:FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  95:FreeRTOS/Source/queue.c ****  * rationale: https://www.freertos.org/Embedded-RTOS-Queues.html
  96:FreeRTOS/Source/queue.c ****  */
  97:FreeRTOS/Source/queue.c **** typedef struct QueueDefinition 		/* The old naming convention is used to prevent breaking kernel aw
  98:FreeRTOS/Source/queue.c **** {
  99:FreeRTOS/Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 100:FreeRTOS/Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 101:FreeRTOS/Source/queue.c **** 
 102:FreeRTOS/Source/queue.c **** 	union
 103:FreeRTOS/Source/queue.c **** 	{
 104:FreeRTOS/Source/queue.c **** 		QueuePointers_t xQueue;		/*< Data required exclusively when this structure is used as a queue. */
 105:FreeRTOS/Source/queue.c **** 		SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaph
 106:FreeRTOS/Source/queue.c **** 	} u;
 107:FreeRTOS/Source/queue.c **** 
 108:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 109:FreeRTOS/Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 110:FreeRTOS/Source/queue.c **** 
 111:FreeRTOS/Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 112:FreeRTOS/Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 113:FreeRTOS/Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 114:FreeRTOS/Source/queue.c **** 
 115:FreeRTOS/Source/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 116:FreeRTOS/Source/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 117:FreeRTOS/Source/queue.c **** 
 118:FreeRTOS/Source/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 119:FreeRTOS/Source/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 120:FreeRTOS/Source/queue.c **** 	#endif
 121:FreeRTOS/Source/queue.c **** 
 122:FreeRTOS/Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 123:FreeRTOS/Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 124:FreeRTOS/Source/queue.c **** 	#endif
 125:FreeRTOS/Source/queue.c **** 
 126:FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:FreeRTOS/Source/queue.c **** 		UBaseType_t uxQueueNumber;
 128:FreeRTOS/Source/queue.c **** 		uint8_t ucQueueType;
 129:FreeRTOS/Source/queue.c **** 	#endif
 130:FreeRTOS/Source/queue.c **** 
 131:FreeRTOS/Source/queue.c **** } xQUEUE;
 132:FreeRTOS/Source/queue.c **** 
 133:FreeRTOS/Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 134:FreeRTOS/Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 135:FreeRTOS/Source/queue.c **** typedef xQUEUE Queue_t;
 136:FreeRTOS/Source/queue.c **** 
 137:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 138:FreeRTOS/Source/queue.c **** 
 139:FreeRTOS/Source/queue.c **** /*
 140:FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 141:FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 142:FreeRTOS/Source/queue.c ****  */
 143:FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 144:FreeRTOS/Source/queue.c **** 
 145:FreeRTOS/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 146:FreeRTOS/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 147:FreeRTOS/Source/queue.c **** 	more user friendly. */
ARM GAS  /tmp/ccdqkONZ.s 			page 4


 148:FreeRTOS/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 149:FreeRTOS/Source/queue.c **** 	{
 150:FreeRTOS/Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 151:FreeRTOS/Source/queue.c **** 		QueueHandle_t xHandle;
 152:FreeRTOS/Source/queue.c **** 	} xQueueRegistryItem;
 153:FreeRTOS/Source/queue.c **** 
 154:FreeRTOS/Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 155:FreeRTOS/Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 156:FreeRTOS/Source/queue.c **** 	debuggers. */
 157:FreeRTOS/Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 158:FreeRTOS/Source/queue.c **** 
 159:FreeRTOS/Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 160:FreeRTOS/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 161:FreeRTOS/Source/queue.c **** 	array position being vacant. */
 162:FreeRTOS/Source/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 163:FreeRTOS/Source/queue.c **** 
 164:FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 165:FreeRTOS/Source/queue.c **** 
 166:FreeRTOS/Source/queue.c **** /*
 167:FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 168:FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 169:FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 170:FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 171:FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 172:FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 173:FreeRTOS/Source/queue.c ****  */
 174:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 175:FreeRTOS/Source/queue.c **** 
 176:FreeRTOS/Source/queue.c **** /*
 177:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 178:FreeRTOS/Source/queue.c ****  *
 179:FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 180:FreeRTOS/Source/queue.c ****  */
 181:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 182:FreeRTOS/Source/queue.c **** 
 183:FreeRTOS/Source/queue.c **** /*
 184:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 185:FreeRTOS/Source/queue.c ****  *
 186:FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 187:FreeRTOS/Source/queue.c ****  */
 188:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 189:FreeRTOS/Source/queue.c **** 
 190:FreeRTOS/Source/queue.c **** /*
 191:FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 192:FreeRTOS/Source/queue.c ****  * back of the queue.
 193:FreeRTOS/Source/queue.c ****  */
 194:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 195:FreeRTOS/Source/queue.c **** 
 196:FreeRTOS/Source/queue.c **** /*
 197:FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 198:FreeRTOS/Source/queue.c ****  */
 199:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 200:FreeRTOS/Source/queue.c **** 
 201:FreeRTOS/Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 202:FreeRTOS/Source/queue.c **** 	/*
 203:FreeRTOS/Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 204:FreeRTOS/Source/queue.c **** 	 * the queue set that the queue contains data.
ARM GAS  /tmp/ccdqkONZ.s 			page 5


 205:FreeRTOS/Source/queue.c **** 	 */
 206:FreeRTOS/Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 207:FreeRTOS/Source/queue.c **** #endif
 208:FreeRTOS/Source/queue.c **** 
 209:FreeRTOS/Source/queue.c **** /*
 210:FreeRTOS/Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 211:FreeRTOS/Source/queue.c ****  * dynamically to fill in the structure's members.
 212:FreeRTOS/Source/queue.c ****  */
 213:FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 214:FreeRTOS/Source/queue.c **** 
 215:FreeRTOS/Source/queue.c **** /*
 216:FreeRTOS/Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 217:FreeRTOS/Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 218:FreeRTOS/Source/queue.c ****  * as a mutex.
 219:FreeRTOS/Source/queue.c ****  */
 220:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 221:FreeRTOS/Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 222:FreeRTOS/Source/queue.c **** #endif
 223:FreeRTOS/Source/queue.c **** 
 224:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 225:FreeRTOS/Source/queue.c **** 	/*
 226:FreeRTOS/Source/queue.c **** 	 * If a task waiting for a mutex causes the mutex holder to inherit a
 227:FreeRTOS/Source/queue.c **** 	 * priority, but the waiting task times out, then the holder should
 228:FreeRTOS/Source/queue.c **** 	 * disinherit the priority - but only down to the highest priority of any
 229:FreeRTOS/Source/queue.c **** 	 * other tasks that are waiting for the same mutex.  This function returns
 230:FreeRTOS/Source/queue.c **** 	 * that priority.
 231:FreeRTOS/Source/queue.c **** 	 */
 232:FreeRTOS/Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGE
 233:FreeRTOS/Source/queue.c **** #endif
 234:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 235:FreeRTOS/Source/queue.c **** 
 236:FreeRTOS/Source/queue.c **** /*
 237:FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 238:FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 239:FreeRTOS/Source/queue.c ****  */
 240:FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )								\
 241:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();									\
 242:FreeRTOS/Source/queue.c **** 	{														\
 243:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 244:FreeRTOS/Source/queue.c **** 		{													\
 245:FreeRTOS/Source/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 246:FreeRTOS/Source/queue.c **** 		}													\
 247:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 248:FreeRTOS/Source/queue.c **** 		{													\
 249:FreeRTOS/Source/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 250:FreeRTOS/Source/queue.c **** 		}													\
 251:FreeRTOS/Source/queue.c **** 	}														\
 252:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL()
 253:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 254:FreeRTOS/Source/queue.c **** 
 255:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 256:FreeRTOS/Source/queue.c **** {
  25              		.loc 1 256 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 16
  28              		@ frame_needed = 1, uses_anonymous_args = 0
  29 0000 80B5     		push	{r7, lr}
ARM GAS  /tmp/ccdqkONZ.s 			page 6


  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 7, -8
  32              		.cfi_offset 14, -4
  33 0002 84B0     		sub	sp, sp, #16
  34              		.cfi_def_cfa_offset 24
  35 0004 00AF     		add	r7, sp, #0
  36              		.cfi_def_cfa_register 7
  37 0006 7860     		str	r0, [r7, #4]
  38 0008 3960     		str	r1, [r7]
 257:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
  39              		.loc 1 257 0
  40 000a 7B68     		ldr	r3, [r7, #4]
  41 000c FB60     		str	r3, [r7, #12]
 258:FreeRTOS/Source/queue.c **** 
 259:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 260:FreeRTOS/Source/queue.c **** 
 261:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
  42              		.loc 1 261 0
  43 000e FFF7FEFF 		bl	vPortEnterCritical
 262:FreeRTOS/Source/queue.c **** 	{
 263:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint 
  44              		.loc 1 263 0
  45 0012 FB68     		ldr	r3, [r7, #12]
  46 0014 1A68     		ldr	r2, [r3]
  47 0016 FB68     		ldr	r3, [r7, #12]
  48 0018 DB6B     		ldr	r3, [r3, #60]
  49 001a F968     		ldr	r1, [r7, #12]
  50 001c 096C     		ldr	r1, [r1, #64]
  51 001e 01FB03F3 		mul	r3, r1, r3
  52 0022 1A44     		add	r2, r2, r3
  53 0024 FB68     		ldr	r3, [r7, #12]
  54 0026 9A60     		str	r2, [r3, #8]
 264:FreeRTOS/Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  55              		.loc 1 264 0
  56 0028 FB68     		ldr	r3, [r7, #12]
  57 002a 0022     		movs	r2, #0
  58 002c 9A63     		str	r2, [r3, #56]
 265:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  59              		.loc 1 265 0
  60 002e FB68     		ldr	r3, [r7, #12]
  61 0030 1A68     		ldr	r2, [r3]
  62 0032 FB68     		ldr	r3, [r7, #12]
  63 0034 5A60     		str	r2, [r3, #4]
 266:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSi
  64              		.loc 1 266 0
  65 0036 FB68     		ldr	r3, [r7, #12]
  66 0038 1A68     		ldr	r2, [r3]
  67 003a FB68     		ldr	r3, [r7, #12]
  68 003c DB6B     		ldr	r3, [r3, #60]
  69 003e 013B     		subs	r3, r3, #1
  70 0040 F968     		ldr	r1, [r7, #12]
  71 0042 096C     		ldr	r1, [r1, #64]
  72 0044 01FB03F3 		mul	r3, r1, r3
  73 0048 1A44     		add	r2, r2, r3
  74 004a FB68     		ldr	r3, [r7, #12]
  75 004c DA60     		str	r2, [r3, #12]
 267:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
ARM GAS  /tmp/ccdqkONZ.s 			page 7


  76              		.loc 1 267 0
  77 004e FB68     		ldr	r3, [r7, #12]
  78 0050 FF22     		movs	r2, #255
  79 0052 83F84420 		strb	r2, [r3, #68]
 268:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
  80              		.loc 1 268 0
  81 0056 FB68     		ldr	r3, [r7, #12]
  82 0058 FF22     		movs	r2, #255
  83 005a 83F84520 		strb	r2, [r3, #69]
 269:FreeRTOS/Source/queue.c **** 
 270:FreeRTOS/Source/queue.c **** 		if( xNewQueue == pdFALSE )
  84              		.loc 1 270 0
  85 005e 3B68     		ldr	r3, [r7]
  86 0060 002B     		cmp	r3, #0
  87 0062 14D1     		bne	.L2
 271:FreeRTOS/Source/queue.c **** 		{
 272:FreeRTOS/Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 273:FreeRTOS/Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 274:FreeRTOS/Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 275:FreeRTOS/Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 276:FreeRTOS/Source/queue.c **** 			it will be possible to write to it. */
 277:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  88              		.loc 1 277 0
  89 0064 FB68     		ldr	r3, [r7, #12]
  90 0066 1B69     		ldr	r3, [r3, #16]
  91 0068 002B     		cmp	r3, #0
  92 006a 1AD0     		beq	.L3
 278:FreeRTOS/Source/queue.c **** 			{
 279:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  93              		.loc 1 279 0
  94 006c FB68     		ldr	r3, [r7, #12]
  95 006e 1033     		adds	r3, r3, #16
  96 0070 1846     		mov	r0, r3
  97 0072 FFF7FEFF 		bl	xTaskRemoveFromEventList
  98 0076 0346     		mov	r3, r0
  99 0078 002B     		cmp	r3, #0
 100 007a 12D0     		beq	.L3
 280:FreeRTOS/Source/queue.c **** 				{
 281:FreeRTOS/Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 101              		.loc 1 281 0
 102 007c 0C4B     		ldr	r3, .L5
 103 007e 4FF08052 		mov	r2, #268435456
 104 0082 1A60     		str	r2, [r3]
 105              		.syntax unified
 106              	@ 281 "FreeRTOS/Source/queue.c" 1
 107 0084 BFF34F8F 		dsb
 108              	@ 0 "" 2
 109              	@ 281 "FreeRTOS/Source/queue.c" 1
 110 0088 BFF36F8F 		isb
 111              	@ 0 "" 2
 112              		.thumb
 113              		.syntax unified
 114 008c 09E0     		b	.L3
 115              	.L2:
 282:FreeRTOS/Source/queue.c **** 				}
 283:FreeRTOS/Source/queue.c **** 				else
 284:FreeRTOS/Source/queue.c **** 				{
ARM GAS  /tmp/ccdqkONZ.s 			page 8


 285:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 286:FreeRTOS/Source/queue.c **** 				}
 287:FreeRTOS/Source/queue.c **** 			}
 288:FreeRTOS/Source/queue.c **** 			else
 289:FreeRTOS/Source/queue.c **** 			{
 290:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 291:FreeRTOS/Source/queue.c **** 			}
 292:FreeRTOS/Source/queue.c **** 		}
 293:FreeRTOS/Source/queue.c **** 		else
 294:FreeRTOS/Source/queue.c **** 		{
 295:FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 296:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 116              		.loc 1 296 0
 117 008e FB68     		ldr	r3, [r7, #12]
 118 0090 1033     		adds	r3, r3, #16
 119 0092 1846     		mov	r0, r3
 120 0094 FFF7FEFF 		bl	vListInitialise
 297:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 121              		.loc 1 297 0
 122 0098 FB68     		ldr	r3, [r7, #12]
 123 009a 2433     		adds	r3, r3, #36
 124 009c 1846     		mov	r0, r3
 125 009e FFF7FEFF 		bl	vListInitialise
 126              	.L3:
 298:FreeRTOS/Source/queue.c **** 		}
 299:FreeRTOS/Source/queue.c **** 	}
 300:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 127              		.loc 1 300 0
 128 00a2 FFF7FEFF 		bl	vPortExitCritical
 301:FreeRTOS/Source/queue.c **** 
 302:FreeRTOS/Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 303:FreeRTOS/Source/queue.c **** 	versions. */
 304:FreeRTOS/Source/queue.c **** 	return pdPASS;
 129              		.loc 1 304 0
 130 00a6 0123     		movs	r3, #1
 305:FreeRTOS/Source/queue.c **** }
 131              		.loc 1 305 0
 132 00a8 1846     		mov	r0, r3
 133 00aa 1037     		adds	r7, r7, #16
 134              		.cfi_def_cfa_offset 8
 135 00ac BD46     		mov	sp, r7
 136              		.cfi_def_cfa_register 13
 137              		@ sp needed
 138 00ae 80BD     		pop	{r7, pc}
 139              	.L6:
 140              		.align	2
 141              	.L5:
 142 00b0 04ED00E0 		.word	-536810236
 143              		.cfi_endproc
 144              	.LFE5:
 145              		.size	xQueueGenericReset, .-xQueueGenericReset
 146              		.align	1
 147              		.global	xQueueGenericCreate
 148              		.syntax unified
 149              		.thumb
 150              		.thumb_func
 151              		.fpu softvfp
ARM GAS  /tmp/ccdqkONZ.s 			page 9


 152              		.type	xQueueGenericCreate, %function
 153              	xQueueGenericCreate:
 154              	.LFB6:
 306:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 307:FreeRTOS/Source/queue.c **** 
 308:FreeRTOS/Source/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 309:FreeRTOS/Source/queue.c **** 
 310:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 311:FreeRTOS/Source/queue.c **** 	{
 312:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 313:FreeRTOS/Source/queue.c **** 
 314:FreeRTOS/Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 315:FreeRTOS/Source/queue.c **** 
 316:FreeRTOS/Source/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 317:FreeRTOS/Source/queue.c **** 		supplied. */
 318:FreeRTOS/Source/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 319:FreeRTOS/Source/queue.c **** 
 320:FreeRTOS/Source/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 321:FreeRTOS/Source/queue.c **** 		should not be provided if the item size is 0. */
 322:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 323:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 324:FreeRTOS/Source/queue.c **** 
 325:FreeRTOS/Source/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 326:FreeRTOS/Source/queue.c **** 		{
 327:FreeRTOS/Source/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 328:FreeRTOS/Source/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 329:FreeRTOS/Source/queue.c **** 			the real queue and semaphore structures. */
 330:FreeRTOS/Source/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 331:FreeRTOS/Source/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 332:FreeRTOS/Source/queue.c **** 			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 333:FreeRTOS/Source/queue.c **** 		}
 334:FreeRTOS/Source/queue.c **** 		#endif /* configASSERT_DEFINED */
 335:FreeRTOS/Source/queue.c **** 
 336:FreeRTOS/Source/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 337:FreeRTOS/Source/queue.c **** 		The address of a statically allocated storage area was also passed in
 338:FreeRTOS/Source/queue.c **** 		but is already set. */
 339:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structure
 340:FreeRTOS/Source/queue.c **** 
 341:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 342:FreeRTOS/Source/queue.c **** 		{
 343:FreeRTOS/Source/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 344:FreeRTOS/Source/queue.c **** 			{
 345:FreeRTOS/Source/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 346:FreeRTOS/Source/queue.c **** 				note this queue was allocated statically in case the queue is
 347:FreeRTOS/Source/queue.c **** 				later deleted. */
 348:FreeRTOS/Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 349:FreeRTOS/Source/queue.c **** 			}
 350:FreeRTOS/Source/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 351:FreeRTOS/Source/queue.c **** 
 352:FreeRTOS/Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 353:FreeRTOS/Source/queue.c **** 		}
 354:FreeRTOS/Source/queue.c **** 		else
 355:FreeRTOS/Source/queue.c **** 		{
 356:FreeRTOS/Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 357:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 358:FreeRTOS/Source/queue.c **** 		}
 359:FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccdqkONZ.s 			page 10


 360:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 361:FreeRTOS/Source/queue.c **** 	}
 362:FreeRTOS/Source/queue.c **** 
 363:FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 364:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 365:FreeRTOS/Source/queue.c **** 
 366:FreeRTOS/Source/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 367:FreeRTOS/Source/queue.c **** 
 368:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 369:FreeRTOS/Source/queue.c **** 	{
 155              		.loc 1 369 0
 156              		.cfi_startproc
 157              		@ args = 0, pretend = 0, frame = 32
 158              		@ frame_needed = 1, uses_anonymous_args = 0
 159 00b4 80B5     		push	{r7, lr}
 160              		.cfi_def_cfa_offset 8
 161              		.cfi_offset 7, -8
 162              		.cfi_offset 14, -4
 163 00b6 8AB0     		sub	sp, sp, #40
 164              		.cfi_def_cfa_offset 48
 165 00b8 02AF     		add	r7, sp, #8
 166              		.cfi_def_cfa 7, 40
 167 00ba F860     		str	r0, [r7, #12]
 168 00bc B960     		str	r1, [r7, #8]
 169 00be 1346     		mov	r3, r2
 170 00c0 FB71     		strb	r3, [r7, #7]
 370:FreeRTOS/Source/queue.c **** 	Queue_t *pxNewQueue;
 371:FreeRTOS/Source/queue.c **** 	size_t xQueueSizeInBytes;
 372:FreeRTOS/Source/queue.c **** 	uint8_t *pucQueueStorage;
 373:FreeRTOS/Source/queue.c **** 
 374:FreeRTOS/Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 375:FreeRTOS/Source/queue.c **** 
 376:FreeRTOS/Source/queue.c **** 		/* Allocate enough space to hold the maximum number of items that
 377:FreeRTOS/Source/queue.c **** 		can be in the queue at any time.  It is valid for uxItemSize to be
 378:FreeRTOS/Source/queue.c **** 		zero in the case the queue is used as a semaphore. */
 379:FreeRTOS/Source/queue.c **** 		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as th
 171              		.loc 1 379 0
 172 00c2 FB68     		ldr	r3, [r7, #12]
 173 00c4 BA68     		ldr	r2, [r7, #8]
 174 00c6 02FB03F3 		mul	r3, r2, r3
 175 00ca FB61     		str	r3, [r7, #28]
 380:FreeRTOS/Source/queue.c **** 
 381:FreeRTOS/Source/queue.c **** 		/* Allocate the queue and storage area.  Justification for MISRA
 382:FreeRTOS/Source/queue.c **** 		deviation as follows:  pvPortMalloc() always ensures returned memory
 383:FreeRTOS/Source/queue.c **** 		blocks are aligned per the requirements of the MCU stack.  In this case
 384:FreeRTOS/Source/queue.c **** 		pvPortMalloc() must return a pointer that is guaranteed to meet the
 385:FreeRTOS/Source/queue.c **** 		alignment requirements of the Queue_t structure - which in this case
 386:FreeRTOS/Source/queue.c **** 		is an int8_t *.  Therefore, whenever the stack alignment requirements
 387:FreeRTOS/Source/queue.c **** 		are greater than or equal to the pointer to char requirements the cast
 388:FreeRTOS/Source/queue.c **** 		is safe.  In other cases alignment requirements are not strict (one or
 389:FreeRTOS/Source/queue.c **** 		two bytes). */
 390:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !
 176              		.loc 1 390 0
 177 00cc FB69     		ldr	r3, [r7, #28]
 178 00ce 4833     		adds	r3, r3, #72
 179 00d0 1846     		mov	r0, r3
 180 00d2 FFF7FEFF 		bl	pvPortMalloc
ARM GAS  /tmp/ccdqkONZ.s 			page 11


 181 00d6 B861     		str	r0, [r7, #24]
 391:FreeRTOS/Source/queue.c **** 
 392:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 182              		.loc 1 392 0
 183 00d8 BB69     		ldr	r3, [r7, #24]
 184 00da 002B     		cmp	r3, #0
 185 00dc 0DD0     		beq	.L8
 393:FreeRTOS/Source/queue.c **** 		{
 394:FreeRTOS/Source/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 395:FreeRTOS/Source/queue.c **** 			storage area. */
 396:FreeRTOS/Source/queue.c **** 			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 186              		.loc 1 396 0
 187 00de BB69     		ldr	r3, [r7, #24]
 188 00e0 7B61     		str	r3, [r7, #20]
 397:FreeRTOS/Source/queue.c **** 			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, es
 189              		.loc 1 397 0
 190 00e2 7B69     		ldr	r3, [r7, #20]
 191 00e4 4833     		adds	r3, r3, #72
 192 00e6 7B61     		str	r3, [r7, #20]
 398:FreeRTOS/Source/queue.c **** 
 399:FreeRTOS/Source/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 400:FreeRTOS/Source/queue.c **** 			{
 401:FreeRTOS/Source/queue.c **** 				/* Queues can be created either statically or dynamically, so
 402:FreeRTOS/Source/queue.c **** 				note this task was created dynamically in case it is later
 403:FreeRTOS/Source/queue.c **** 				deleted. */
 404:FreeRTOS/Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 405:FreeRTOS/Source/queue.c **** 			}
 406:FreeRTOS/Source/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 407:FreeRTOS/Source/queue.c **** 
 408:FreeRTOS/Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 193              		.loc 1 408 0
 194 00e8 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 195 00ea BB69     		ldr	r3, [r7, #24]
 196 00ec 0093     		str	r3, [sp]
 197 00ee 1346     		mov	r3, r2
 198 00f0 7A69     		ldr	r2, [r7, #20]
 199 00f2 B968     		ldr	r1, [r7, #8]
 200 00f4 F868     		ldr	r0, [r7, #12]
 201 00f6 00F005F8 		bl	prvInitialiseNewQueue
 202              	.L8:
 409:FreeRTOS/Source/queue.c **** 		}
 410:FreeRTOS/Source/queue.c **** 		else
 411:FreeRTOS/Source/queue.c **** 		{
 412:FreeRTOS/Source/queue.c **** 			traceQUEUE_CREATE_FAILED( ucQueueType );
 413:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
 414:FreeRTOS/Source/queue.c **** 		}
 415:FreeRTOS/Source/queue.c **** 
 416:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 203              		.loc 1 416 0
 204 00fa BB69     		ldr	r3, [r7, #24]
 417:FreeRTOS/Source/queue.c **** 	}
 205              		.loc 1 417 0
 206 00fc 1846     		mov	r0, r3
 207 00fe 2037     		adds	r7, r7, #32
 208              		.cfi_def_cfa_offset 8
 209 0100 BD46     		mov	sp, r7
 210              		.cfi_def_cfa_register 13
ARM GAS  /tmp/ccdqkONZ.s 			page 12


 211              		@ sp needed
 212 0102 80BD     		pop	{r7, pc}
 213              		.cfi_endproc
 214              	.LFE6:
 215              		.size	xQueueGenericCreate, .-xQueueGenericCreate
 216              		.align	1
 217              		.syntax unified
 218              		.thumb
 219              		.thumb_func
 220              		.fpu softvfp
 221              		.type	prvInitialiseNewQueue, %function
 222              	prvInitialiseNewQueue:
 223              	.LFB7:
 418:FreeRTOS/Source/queue.c **** 
 419:FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 420:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 421:FreeRTOS/Source/queue.c **** 
 422:FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 423:FreeRTOS/Source/queue.c **** {
 224              		.loc 1 423 0
 225              		.cfi_startproc
 226              		@ args = 4, pretend = 0, frame = 16
 227              		@ frame_needed = 1, uses_anonymous_args = 0
 228 0104 80B5     		push	{r7, lr}
 229              		.cfi_def_cfa_offset 8
 230              		.cfi_offset 7, -8
 231              		.cfi_offset 14, -4
 232 0106 84B0     		sub	sp, sp, #16
 233              		.cfi_def_cfa_offset 24
 234 0108 00AF     		add	r7, sp, #0
 235              		.cfi_def_cfa_register 7
 236 010a F860     		str	r0, [r7, #12]
 237 010c B960     		str	r1, [r7, #8]
 238 010e 7A60     		str	r2, [r7, #4]
 239 0110 FB70     		strb	r3, [r7, #3]
 424:FreeRTOS/Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 425:FreeRTOS/Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 426:FreeRTOS/Source/queue.c **** 	( void ) ucQueueType;
 427:FreeRTOS/Source/queue.c **** 
 428:FreeRTOS/Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 240              		.loc 1 428 0
 241 0112 BB68     		ldr	r3, [r7, #8]
 242 0114 002B     		cmp	r3, #0
 243 0116 03D1     		bne	.L11
 429:FreeRTOS/Source/queue.c **** 	{
 430:FreeRTOS/Source/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 431:FreeRTOS/Source/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 432:FreeRTOS/Source/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 433:FreeRTOS/Source/queue.c **** 		value that is known to be within the memory map. */
 434:FreeRTOS/Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 244              		.loc 1 434 0
 245 0118 BB69     		ldr	r3, [r7, #24]
 246 011a BA69     		ldr	r2, [r7, #24]
 247 011c 1A60     		str	r2, [r3]
 248 011e 02E0     		b	.L12
 249              	.L11:
 435:FreeRTOS/Source/queue.c **** 	}
ARM GAS  /tmp/ccdqkONZ.s 			page 13


 436:FreeRTOS/Source/queue.c **** 	else
 437:FreeRTOS/Source/queue.c **** 	{
 438:FreeRTOS/Source/queue.c **** 		/* Set the head to the start of the queue storage area. */
 439:FreeRTOS/Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 250              		.loc 1 439 0
 251 0120 BB69     		ldr	r3, [r7, #24]
 252 0122 7A68     		ldr	r2, [r7, #4]
 253 0124 1A60     		str	r2, [r3]
 254              	.L12:
 440:FreeRTOS/Source/queue.c **** 	}
 441:FreeRTOS/Source/queue.c **** 
 442:FreeRTOS/Source/queue.c **** 	/* Initialise the queue members as described where the queue type is
 443:FreeRTOS/Source/queue.c **** 	defined. */
 444:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 255              		.loc 1 444 0
 256 0126 BB69     		ldr	r3, [r7, #24]
 257 0128 FA68     		ldr	r2, [r7, #12]
 258 012a DA63     		str	r2, [r3, #60]
 445:FreeRTOS/Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 259              		.loc 1 445 0
 260 012c BB69     		ldr	r3, [r7, #24]
 261 012e BA68     		ldr	r2, [r7, #8]
 262 0130 1A64     		str	r2, [r3, #64]
 446:FreeRTOS/Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 263              		.loc 1 446 0
 264 0132 0121     		movs	r1, #1
 265 0134 B869     		ldr	r0, [r7, #24]
 266 0136 FFF7FEFF 		bl	xQueueGenericReset
 447:FreeRTOS/Source/queue.c **** 
 448:FreeRTOS/Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 449:FreeRTOS/Source/queue.c **** 	{
 450:FreeRTOS/Source/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 451:FreeRTOS/Source/queue.c **** 	}
 452:FreeRTOS/Source/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 453:FreeRTOS/Source/queue.c **** 
 454:FreeRTOS/Source/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 455:FreeRTOS/Source/queue.c **** 	{
 456:FreeRTOS/Source/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 457:FreeRTOS/Source/queue.c **** 	}
 458:FreeRTOS/Source/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 459:FreeRTOS/Source/queue.c **** 
 460:FreeRTOS/Source/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 461:FreeRTOS/Source/queue.c **** }
 267              		.loc 1 461 0
 268 013a 00BF     		nop
 269 013c 1037     		adds	r7, r7, #16
 270              		.cfi_def_cfa_offset 8
 271 013e BD46     		mov	sp, r7
 272              		.cfi_def_cfa_register 13
 273              		@ sp needed
 274 0140 80BD     		pop	{r7, pc}
 275              		.cfi_endproc
 276              	.LFE7:
 277              		.size	prvInitialiseNewQueue, .-prvInitialiseNewQueue
 278              		.align	1
 279              		.global	xQueueGenericSend
 280              		.syntax unified
ARM GAS  /tmp/ccdqkONZ.s 			page 14


 281              		.thumb
 282              		.thumb_func
 283              		.fpu softvfp
 284              		.type	xQueueGenericSend, %function
 285              	xQueueGenericSend:
 286              	.LFB8:
 462:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 463:FreeRTOS/Source/queue.c **** 
 464:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 465:FreeRTOS/Source/queue.c **** 
 466:FreeRTOS/Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 467:FreeRTOS/Source/queue.c **** 	{
 468:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 469:FreeRTOS/Source/queue.c **** 		{
 470:FreeRTOS/Source/queue.c **** 			/* The queue create function will set all the queue structure members
 471:FreeRTOS/Source/queue.c **** 			correctly for a generic queue, but this function is creating a
 472:FreeRTOS/Source/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 473:FreeRTOS/Source/queue.c **** 			in particular the information required for priority inheritance. */
 474:FreeRTOS/Source/queue.c **** 			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 475:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 476:FreeRTOS/Source/queue.c **** 
 477:FreeRTOS/Source/queue.c **** 			/* In case this is a recursive mutex. */
 478:FreeRTOS/Source/queue.c **** 			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 479:FreeRTOS/Source/queue.c **** 
 480:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 481:FreeRTOS/Source/queue.c **** 
 482:FreeRTOS/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 483:FreeRTOS/Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 484:FreeRTOS/Source/queue.c **** 		}
 485:FreeRTOS/Source/queue.c **** 		else
 486:FreeRTOS/Source/queue.c **** 		{
 487:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 488:FreeRTOS/Source/queue.c **** 		}
 489:FreeRTOS/Source/queue.c **** 	}
 490:FreeRTOS/Source/queue.c **** 
 491:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 492:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 493:FreeRTOS/Source/queue.c **** 
 494:FreeRTOS/Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 495:FreeRTOS/Source/queue.c **** 
 496:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 497:FreeRTOS/Source/queue.c **** 	{
 498:FreeRTOS/Source/queue.c **** 	QueueHandle_t xNewQueue;
 499:FreeRTOS/Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 500:FreeRTOS/Source/queue.c **** 
 501:FreeRTOS/Source/queue.c **** 		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 502:FreeRTOS/Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 503:FreeRTOS/Source/queue.c **** 
 504:FreeRTOS/Source/queue.c **** 		return xNewQueue;
 505:FreeRTOS/Source/queue.c **** 	}
 506:FreeRTOS/Source/queue.c **** 
 507:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 508:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 509:FreeRTOS/Source/queue.c **** 
 510:FreeRTOS/Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 511:FreeRTOS/Source/queue.c **** 
 512:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
ARM GAS  /tmp/ccdqkONZ.s 			page 15


 513:FreeRTOS/Source/queue.c **** 	{
 514:FreeRTOS/Source/queue.c **** 	QueueHandle_t xNewQueue;
 515:FreeRTOS/Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 516:FreeRTOS/Source/queue.c **** 
 517:FreeRTOS/Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 518:FreeRTOS/Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 519:FreeRTOS/Source/queue.c **** 		( void ) ucQueueType;
 520:FreeRTOS/Source/queue.c **** 
 521:FreeRTOS/Source/queue.c **** 		xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueTy
 522:FreeRTOS/Source/queue.c **** 		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 523:FreeRTOS/Source/queue.c **** 
 524:FreeRTOS/Source/queue.c **** 		return xNewQueue;
 525:FreeRTOS/Source/queue.c **** 	}
 526:FreeRTOS/Source/queue.c **** 
 527:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 528:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 529:FreeRTOS/Source/queue.c **** 
 530:FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 531:FreeRTOS/Source/queue.c **** 
 532:FreeRTOS/Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 533:FreeRTOS/Source/queue.c **** 	{
 534:FreeRTOS/Source/queue.c **** 	TaskHandle_t pxReturn;
 535:FreeRTOS/Source/queue.c **** 	Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 536:FreeRTOS/Source/queue.c **** 
 537:FreeRTOS/Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 538:FreeRTOS/Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 539:FreeRTOS/Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 540:FreeRTOS/Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 541:FreeRTOS/Source/queue.c **** 		following critical section exiting and the function returning. */
 542:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 543:FreeRTOS/Source/queue.c **** 		{
 544:FreeRTOS/Source/queue.c **** 			if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 545:FreeRTOS/Source/queue.c **** 			{
 546:FreeRTOS/Source/queue.c **** 				pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 547:FreeRTOS/Source/queue.c **** 			}
 548:FreeRTOS/Source/queue.c **** 			else
 549:FreeRTOS/Source/queue.c **** 			{
 550:FreeRTOS/Source/queue.c **** 				pxReturn = NULL;
 551:FreeRTOS/Source/queue.c **** 			}
 552:FreeRTOS/Source/queue.c **** 		}
 553:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 554:FreeRTOS/Source/queue.c **** 
 555:FreeRTOS/Source/queue.c **** 		return pxReturn;
 556:FreeRTOS/Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 557:FreeRTOS/Source/queue.c **** 
 558:FreeRTOS/Source/queue.c **** #endif
 559:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 560:FreeRTOS/Source/queue.c **** 
 561:FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 562:FreeRTOS/Source/queue.c **** 
 563:FreeRTOS/Source/queue.c **** 	TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 564:FreeRTOS/Source/queue.c **** 	{
 565:FreeRTOS/Source/queue.c **** 	TaskHandle_t pxReturn;
 566:FreeRTOS/Source/queue.c **** 
 567:FreeRTOS/Source/queue.c **** 		configASSERT( xSemaphore );
 568:FreeRTOS/Source/queue.c **** 
 569:FreeRTOS/Source/queue.c **** 		/* Mutexes cannot be used in interrupt service routines, so the mutex
ARM GAS  /tmp/ccdqkONZ.s 			page 16


 570:FreeRTOS/Source/queue.c **** 		holder should not change in an ISR, and therefore a critical section is
 571:FreeRTOS/Source/queue.c **** 		not required here. */
 572:FreeRTOS/Source/queue.c **** 		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 573:FreeRTOS/Source/queue.c **** 		{
 574:FreeRTOS/Source/queue.c **** 			pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 575:FreeRTOS/Source/queue.c **** 		}
 576:FreeRTOS/Source/queue.c **** 		else
 577:FreeRTOS/Source/queue.c **** 		{
 578:FreeRTOS/Source/queue.c **** 			pxReturn = NULL;
 579:FreeRTOS/Source/queue.c **** 		}
 580:FreeRTOS/Source/queue.c **** 
 581:FreeRTOS/Source/queue.c **** 		return pxReturn;
 582:FreeRTOS/Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 583:FreeRTOS/Source/queue.c **** 
 584:FreeRTOS/Source/queue.c **** #endif
 585:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 586:FreeRTOS/Source/queue.c **** 
 587:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 588:FreeRTOS/Source/queue.c **** 
 589:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 590:FreeRTOS/Source/queue.c **** 	{
 591:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 592:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 593:FreeRTOS/Source/queue.c **** 
 594:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 595:FreeRTOS/Source/queue.c **** 
 596:FreeRTOS/Source/queue.c **** 		/* If this is the task that holds the mutex then xMutexHolder will not
 597:FreeRTOS/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 598:FreeRTOS/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 599:FreeRTOS/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 600:FreeRTOS/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 601:FreeRTOS/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 602:FreeRTOS/Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 603:FreeRTOS/Source/queue.c **** 		{
 604:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 605:FreeRTOS/Source/queue.c **** 
 606:FreeRTOS/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 607:FreeRTOS/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 608:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 609:FreeRTOS/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 610:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount member. */
 611:FreeRTOS/Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 612:FreeRTOS/Source/queue.c **** 
 613:FreeRTOS/Source/queue.c **** 			/* Has the recursive call count unwound to 0? */
 614:FreeRTOS/Source/queue.c **** 			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 615:FreeRTOS/Source/queue.c **** 			{
 616:FreeRTOS/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 617:FreeRTOS/Source/queue.c **** 				task that might be waiting to access the mutex. */
 618:FreeRTOS/Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 619:FreeRTOS/Source/queue.c **** 			}
 620:FreeRTOS/Source/queue.c **** 			else
 621:FreeRTOS/Source/queue.c **** 			{
 622:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 623:FreeRTOS/Source/queue.c **** 			}
 624:FreeRTOS/Source/queue.c **** 
 625:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 626:FreeRTOS/Source/queue.c **** 		}
ARM GAS  /tmp/ccdqkONZ.s 			page 17


 627:FreeRTOS/Source/queue.c **** 		else
 628:FreeRTOS/Source/queue.c **** 		{
 629:FreeRTOS/Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 630:FreeRTOS/Source/queue.c **** 			holder. */
 631:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 632:FreeRTOS/Source/queue.c **** 
 633:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 634:FreeRTOS/Source/queue.c **** 		}
 635:FreeRTOS/Source/queue.c **** 
 636:FreeRTOS/Source/queue.c **** 		return xReturn;
 637:FreeRTOS/Source/queue.c **** 	}
 638:FreeRTOS/Source/queue.c **** 
 639:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 640:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 641:FreeRTOS/Source/queue.c **** 
 642:FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 643:FreeRTOS/Source/queue.c **** 
 644:FreeRTOS/Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 645:FreeRTOS/Source/queue.c **** 	{
 646:FreeRTOS/Source/queue.c **** 	BaseType_t xReturn;
 647:FreeRTOS/Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 648:FreeRTOS/Source/queue.c **** 
 649:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 650:FreeRTOS/Source/queue.c **** 
 651:FreeRTOS/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 652:FreeRTOS/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 653:FreeRTOS/Source/queue.c **** 
 654:FreeRTOS/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 655:FreeRTOS/Source/queue.c **** 
 656:FreeRTOS/Source/queue.c **** 		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 657:FreeRTOS/Source/queue.c **** 		{
 658:FreeRTOS/Source/queue.c **** 			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 659:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 660:FreeRTOS/Source/queue.c **** 		}
 661:FreeRTOS/Source/queue.c **** 		else
 662:FreeRTOS/Source/queue.c **** 		{
 663:FreeRTOS/Source/queue.c **** 			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 664:FreeRTOS/Source/queue.c **** 
 665:FreeRTOS/Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 666:FreeRTOS/Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 667:FreeRTOS/Source/queue.c **** 			before reaching here. */
 668:FreeRTOS/Source/queue.c **** 			if( xReturn != pdFAIL )
 669:FreeRTOS/Source/queue.c **** 			{
 670:FreeRTOS/Source/queue.c **** 				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 671:FreeRTOS/Source/queue.c **** 			}
 672:FreeRTOS/Source/queue.c **** 			else
 673:FreeRTOS/Source/queue.c **** 			{
 674:FreeRTOS/Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 675:FreeRTOS/Source/queue.c **** 			}
 676:FreeRTOS/Source/queue.c **** 		}
 677:FreeRTOS/Source/queue.c **** 
 678:FreeRTOS/Source/queue.c **** 		return xReturn;
 679:FreeRTOS/Source/queue.c **** 	}
 680:FreeRTOS/Source/queue.c **** 
 681:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 682:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 683:FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccdqkONZ.s 			page 18


 684:FreeRTOS/Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 685:FreeRTOS/Source/queue.c **** 
 686:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 687:FreeRTOS/Source/queue.c **** 	{
 688:FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 689:FreeRTOS/Source/queue.c **** 
 690:FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 691:FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 692:FreeRTOS/Source/queue.c **** 
 693:FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 694:FreeRTOS/Source/queue.c **** 
 695:FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 696:FreeRTOS/Source/queue.c **** 		{
 697:FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 698:FreeRTOS/Source/queue.c **** 
 699:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 700:FreeRTOS/Source/queue.c **** 		}
 701:FreeRTOS/Source/queue.c **** 		else
 702:FreeRTOS/Source/queue.c **** 		{
 703:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 704:FreeRTOS/Source/queue.c **** 		}
 705:FreeRTOS/Source/queue.c **** 
 706:FreeRTOS/Source/queue.c **** 		return xHandle;
 707:FreeRTOS/Source/queue.c **** 	}
 708:FreeRTOS/Source/queue.c **** 
 709:FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 710:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 711:FreeRTOS/Source/queue.c **** 
 712:FreeRTOS/Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 713:FreeRTOS/Source/queue.c **** 
 714:FreeRTOS/Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 715:FreeRTOS/Source/queue.c **** 	{
 716:FreeRTOS/Source/queue.c **** 	QueueHandle_t xHandle;
 717:FreeRTOS/Source/queue.c **** 
 718:FreeRTOS/Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 719:FreeRTOS/Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 720:FreeRTOS/Source/queue.c **** 
 721:FreeRTOS/Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 722:FreeRTOS/Source/queue.c **** 
 723:FreeRTOS/Source/queue.c **** 		if( xHandle != NULL )
 724:FreeRTOS/Source/queue.c **** 		{
 725:FreeRTOS/Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 726:FreeRTOS/Source/queue.c **** 
 727:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 728:FreeRTOS/Source/queue.c **** 		}
 729:FreeRTOS/Source/queue.c **** 		else
 730:FreeRTOS/Source/queue.c **** 		{
 731:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 732:FreeRTOS/Source/queue.c **** 		}
 733:FreeRTOS/Source/queue.c **** 
 734:FreeRTOS/Source/queue.c **** 		return xHandle;
 735:FreeRTOS/Source/queue.c **** 	}
 736:FreeRTOS/Source/queue.c **** 
 737:FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 738:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 739:FreeRTOS/Source/queue.c **** 
 740:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
ARM GAS  /tmp/ccdqkONZ.s 			page 19


 741:FreeRTOS/Source/queue.c **** {
 287              		.loc 1 741 0
 288              		.cfi_startproc
 289              		@ args = 0, pretend = 0, frame = 40
 290              		@ frame_needed = 1, uses_anonymous_args = 0
 291 0142 80B5     		push	{r7, lr}
 292              		.cfi_def_cfa_offset 8
 293              		.cfi_offset 7, -8
 294              		.cfi_offset 14, -4
 295 0144 8AB0     		sub	sp, sp, #40
 296              		.cfi_def_cfa_offset 48
 297 0146 00AF     		add	r7, sp, #0
 298              		.cfi_def_cfa_register 7
 299 0148 F860     		str	r0, [r7, #12]
 300 014a B960     		str	r1, [r7, #8]
 301 014c 7A60     		str	r2, [r7, #4]
 302 014e 3B60     		str	r3, [r7]
 742:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 303              		.loc 1 742 0
 304 0150 0023     		movs	r3, #0
 305 0152 7B62     		str	r3, [r7, #36]
 743:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
 744:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 306              		.loc 1 744 0
 307 0154 FB68     		ldr	r3, [r7, #12]
 308 0156 3B62     		str	r3, [r7, #32]
 309              	.L28:
 745:FreeRTOS/Source/queue.c **** 
 746:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 747:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 748:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 749:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 750:FreeRTOS/Source/queue.c **** 	{
 751:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 752:FreeRTOS/Source/queue.c **** 	}
 753:FreeRTOS/Source/queue.c **** 	#endif
 754:FreeRTOS/Source/queue.c **** 
 755:FreeRTOS/Source/queue.c **** 
 756:FreeRTOS/Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to
 757:FreeRTOS/Source/queue.c **** 	allow return statements within the function itself.  This is done in the
 758:FreeRTOS/Source/queue.c **** 	interest of execution time efficiency. */
 759:FreeRTOS/Source/queue.c **** 	for( ;; )
 760:FreeRTOS/Source/queue.c **** 	{
 761:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 310              		.loc 1 761 0
 311 0158 FFF7FEFF 		bl	vPortEnterCritical
 762:FreeRTOS/Source/queue.c **** 		{
 763:FreeRTOS/Source/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 764:FreeRTOS/Source/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 765:FreeRTOS/Source/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 766:FreeRTOS/Source/queue.c **** 			queue is full. */
 767:FreeRTOS/Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 312              		.loc 1 767 0
 313 015c 3B6A     		ldr	r3, [r7, #32]
 314 015e 9A6B     		ldr	r2, [r3, #56]
 315 0160 3B6A     		ldr	r3, [r7, #32]
 316 0162 DB6B     		ldr	r3, [r3, #60]
ARM GAS  /tmp/ccdqkONZ.s 			page 20


 317 0164 9A42     		cmp	r2, r3
 318 0166 02D3     		bcc	.L14
 319              		.loc 1 767 0 is_stmt 0 discriminator 1
 320 0168 3B68     		ldr	r3, [r7]
 321 016a 022B     		cmp	r3, #2
 322 016c 29D1     		bne	.L15
 323              	.L14:
 768:FreeRTOS/Source/queue.c **** 			{
 769:FreeRTOS/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 770:FreeRTOS/Source/queue.c **** 
 771:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 772:FreeRTOS/Source/queue.c **** 				{
 773:FreeRTOS/Source/queue.c **** 				const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 774:FreeRTOS/Source/queue.c **** 
 775:FreeRTOS/Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 776:FreeRTOS/Source/queue.c **** 
 777:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 778:FreeRTOS/Source/queue.c **** 					{
 779:FreeRTOS/Source/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
 780:FreeRTOS/Source/queue.c **** 						{
 781:FreeRTOS/Source/queue.c **** 							/* Do not notify the queue set as an existing item
 782:FreeRTOS/Source/queue.c **** 							was overwritten in the queue so the number of items
 783:FreeRTOS/Source/queue.c **** 							in the queue has not changed. */
 784:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 785:FreeRTOS/Source/queue.c **** 						}
 786:FreeRTOS/Source/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 787:FreeRTOS/Source/queue.c **** 						{
 788:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 789:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
 790:FreeRTOS/Source/queue.c **** 							unblock. A context switch is required. */
 791:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 792:FreeRTOS/Source/queue.c **** 						}
 793:FreeRTOS/Source/queue.c **** 						else
 794:FreeRTOS/Source/queue.c **** 						{
 795:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 796:FreeRTOS/Source/queue.c **** 						}
 797:FreeRTOS/Source/queue.c **** 					}
 798:FreeRTOS/Source/queue.c **** 					else
 799:FreeRTOS/Source/queue.c **** 					{
 800:FreeRTOS/Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 801:FreeRTOS/Source/queue.c **** 						queue then unblock it now. */
 802:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 803:FreeRTOS/Source/queue.c **** 						{
 804:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 805:FreeRTOS/Source/queue.c **** 							{
 806:FreeRTOS/Source/queue.c **** 								/* The unblocked task has a priority higher than
 807:FreeRTOS/Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 808:FreeRTOS/Source/queue.c **** 								do this from within the critical section - the
 809:FreeRTOS/Source/queue.c **** 								kernel takes care of that. */
 810:FreeRTOS/Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 811:FreeRTOS/Source/queue.c **** 							}
 812:FreeRTOS/Source/queue.c **** 							else
 813:FreeRTOS/Source/queue.c **** 							{
 814:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 815:FreeRTOS/Source/queue.c **** 							}
 816:FreeRTOS/Source/queue.c **** 						}
 817:FreeRTOS/Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
ARM GAS  /tmp/ccdqkONZ.s 			page 21


 818:FreeRTOS/Source/queue.c **** 						{
 819:FreeRTOS/Source/queue.c **** 							/* This path is a special case that will only get
 820:FreeRTOS/Source/queue.c **** 							executed if the task was holding multiple mutexes
 821:FreeRTOS/Source/queue.c **** 							and the mutexes were given back in an order that is
 822:FreeRTOS/Source/queue.c **** 							different to that in which they were taken. */
 823:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 824:FreeRTOS/Source/queue.c **** 						}
 825:FreeRTOS/Source/queue.c **** 						else
 826:FreeRTOS/Source/queue.c **** 						{
 827:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 828:FreeRTOS/Source/queue.c **** 						}
 829:FreeRTOS/Source/queue.c **** 					}
 830:FreeRTOS/Source/queue.c **** 				}
 831:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 832:FreeRTOS/Source/queue.c **** 				{
 833:FreeRTOS/Source/queue.c **** 					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 324              		.loc 1 833 0 is_stmt 1
 325 016e 3A68     		ldr	r2, [r7]
 326 0170 B968     		ldr	r1, [r7, #8]
 327 0172 386A     		ldr	r0, [r7, #32]
 328 0174 00F0EDFB 		bl	prvCopyDataToQueue
 329 0178 F861     		str	r0, [r7, #28]
 834:FreeRTOS/Source/queue.c **** 
 835:FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 836:FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 837:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 330              		.loc 1 837 0
 331 017a 3B6A     		ldr	r3, [r7, #32]
 332 017c 5B6A     		ldr	r3, [r3, #36]
 333 017e 002B     		cmp	r3, #0
 334 0180 10D0     		beq	.L16
 838:FreeRTOS/Source/queue.c **** 					{
 839:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 335              		.loc 1 839 0
 336 0182 3B6A     		ldr	r3, [r7, #32]
 337 0184 2433     		adds	r3, r3, #36
 338 0186 1846     		mov	r0, r3
 339 0188 FFF7FEFF 		bl	xTaskRemoveFromEventList
 340 018c 0346     		mov	r3, r0
 341 018e 002B     		cmp	r3, #0
 342 0190 13D0     		beq	.L17
 840:FreeRTOS/Source/queue.c **** 						{
 841:FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 842:FreeRTOS/Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 843:FreeRTOS/Source/queue.c **** 							this from within the critical section - the kernel
 844:FreeRTOS/Source/queue.c **** 							takes care of that. */
 845:FreeRTOS/Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 343              		.loc 1 845 0
 344 0192 404B     		ldr	r3, .L30
 345 0194 4FF08052 		mov	r2, #268435456
 346 0198 1A60     		str	r2, [r3]
 347              		.syntax unified
 348              	@ 845 "FreeRTOS/Source/queue.c" 1
 349 019a BFF34F8F 		dsb
 350              	@ 0 "" 2
 351              	@ 845 "FreeRTOS/Source/queue.c" 1
 352 019e BFF36F8F 		isb
ARM GAS  /tmp/ccdqkONZ.s 			page 22


 353              	@ 0 "" 2
 354              		.thumb
 355              		.syntax unified
 356 01a2 0AE0     		b	.L17
 357              	.L16:
 846:FreeRTOS/Source/queue.c **** 						}
 847:FreeRTOS/Source/queue.c **** 						else
 848:FreeRTOS/Source/queue.c **** 						{
 849:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 850:FreeRTOS/Source/queue.c **** 						}
 851:FreeRTOS/Source/queue.c **** 					}
 852:FreeRTOS/Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 358              		.loc 1 852 0
 359 01a4 FB69     		ldr	r3, [r7, #28]
 360 01a6 002B     		cmp	r3, #0
 361 01a8 07D0     		beq	.L17
 853:FreeRTOS/Source/queue.c **** 					{
 854:FreeRTOS/Source/queue.c **** 						/* This path is a special case that will only get
 855:FreeRTOS/Source/queue.c **** 						executed if the task was holding multiple mutexes and
 856:FreeRTOS/Source/queue.c **** 						the mutexes were given back in an order that is
 857:FreeRTOS/Source/queue.c **** 						different to that in which they were taken. */
 858:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 362              		.loc 1 858 0
 363 01aa 3A4B     		ldr	r3, .L30
 364 01ac 4FF08052 		mov	r2, #268435456
 365 01b0 1A60     		str	r2, [r3]
 366              		.syntax unified
 367              	@ 858 "FreeRTOS/Source/queue.c" 1
 368 01b2 BFF34F8F 		dsb
 369              	@ 0 "" 2
 370              	@ 858 "FreeRTOS/Source/queue.c" 1
 371 01b6 BFF36F8F 		isb
 372              	@ 0 "" 2
 373              		.thumb
 374              		.syntax unified
 375              	.L17:
 859:FreeRTOS/Source/queue.c **** 					}
 860:FreeRTOS/Source/queue.c **** 					else
 861:FreeRTOS/Source/queue.c **** 					{
 862:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 863:FreeRTOS/Source/queue.c **** 					}
 864:FreeRTOS/Source/queue.c **** 				}
 865:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 866:FreeRTOS/Source/queue.c **** 
 867:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 376              		.loc 1 867 0
 377 01ba FFF7FEFF 		bl	vPortExitCritical
 868:FreeRTOS/Source/queue.c **** 				return pdPASS;
 378              		.loc 1 868 0
 379 01be 0123     		movs	r3, #1
 380 01c0 63E0     		b	.L29
 381              	.L15:
 869:FreeRTOS/Source/queue.c **** 			}
 870:FreeRTOS/Source/queue.c **** 			else
 871:FreeRTOS/Source/queue.c **** 			{
 872:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 382              		.loc 1 872 0
ARM GAS  /tmp/ccdqkONZ.s 			page 23


 383 01c2 7B68     		ldr	r3, [r7, #4]
 384 01c4 002B     		cmp	r3, #0
 385 01c6 03D1     		bne	.L19
 873:FreeRTOS/Source/queue.c **** 				{
 874:FreeRTOS/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 875:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 876:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 386              		.loc 1 876 0
 387 01c8 FFF7FEFF 		bl	vPortExitCritical
 877:FreeRTOS/Source/queue.c **** 
 878:FreeRTOS/Source/queue.c **** 					/* Return to the original privilege level before exiting
 879:FreeRTOS/Source/queue.c **** 					the function. */
 880:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 881:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 388              		.loc 1 881 0
 389 01cc 0023     		movs	r3, #0
 390 01ce 5CE0     		b	.L29
 391              	.L19:
 882:FreeRTOS/Source/queue.c **** 				}
 883:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 392              		.loc 1 883 0
 393 01d0 7B6A     		ldr	r3, [r7, #36]
 394 01d2 002B     		cmp	r3, #0
 395 01d4 06D1     		bne	.L20
 884:FreeRTOS/Source/queue.c **** 				{
 885:FreeRTOS/Source/queue.c **** 					/* The queue was full and a block time was specified so
 886:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 887:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 396              		.loc 1 887 0
 397 01d6 07F11403 		add	r3, r7, #20
 398 01da 1846     		mov	r0, r3
 399 01dc FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 888:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 400              		.loc 1 888 0
 401 01e0 0123     		movs	r3, #1
 402 01e2 7B62     		str	r3, [r7, #36]
 403              	.L20:
 889:FreeRTOS/Source/queue.c **** 				}
 890:FreeRTOS/Source/queue.c **** 				else
 891:FreeRTOS/Source/queue.c **** 				{
 892:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
 893:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 894:FreeRTOS/Source/queue.c **** 				}
 895:FreeRTOS/Source/queue.c **** 			}
 896:FreeRTOS/Source/queue.c **** 		}
 897:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 404              		.loc 1 897 0
 405 01e4 FFF7FEFF 		bl	vPortExitCritical
 898:FreeRTOS/Source/queue.c **** 
 899:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 900:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 901:FreeRTOS/Source/queue.c **** 
 902:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 406              		.loc 1 902 0
 407 01e8 FFF7FEFF 		bl	vTaskSuspendAll
 903:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 408              		.loc 1 903 0
ARM GAS  /tmp/ccdqkONZ.s 			page 24


 409 01ec FFF7FEFF 		bl	vPortEnterCritical
 410 01f0 3B6A     		ldr	r3, [r7, #32]
 411 01f2 93F84430 		ldrb	r3, [r3, #68]
 412 01f6 5BB2     		sxtb	r3, r3
 413 01f8 B3F1FF3F 		cmp	r3, #-1
 414 01fc 03D1     		bne	.L21
 415              		.loc 1 903 0 is_stmt 0 discriminator 1
 416 01fe 3B6A     		ldr	r3, [r7, #32]
 417 0200 0022     		movs	r2, #0
 418 0202 83F84420 		strb	r2, [r3, #68]
 419              	.L21:
 420              		.loc 1 903 0 discriminator 3
 421 0206 3B6A     		ldr	r3, [r7, #32]
 422 0208 93F84530 		ldrb	r3, [r3, #69]
 423 020c 5BB2     		sxtb	r3, r3
 424 020e B3F1FF3F 		cmp	r3, #-1
 425 0212 03D1     		bne	.L22
 426              		.loc 1 903 0 discriminator 4
 427 0214 3B6A     		ldr	r3, [r7, #32]
 428 0216 0022     		movs	r2, #0
 429 0218 83F84520 		strb	r2, [r3, #69]
 430              	.L22:
 431              		.loc 1 903 0 discriminator 6
 432 021c FFF7FEFF 		bl	vPortExitCritical
 904:FreeRTOS/Source/queue.c **** 
 905:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 906:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 433              		.loc 1 906 0 is_stmt 1 discriminator 6
 434 0220 3A1D     		adds	r2, r7, #4
 435 0222 07F11403 		add	r3, r7, #20
 436 0226 1146     		mov	r1, r2
 437 0228 1846     		mov	r0, r3
 438 022a FFF7FEFF 		bl	xTaskCheckForTimeOut
 439 022e 0346     		mov	r3, r0
 440 0230 002B     		cmp	r3, #0
 441 0232 24D1     		bne	.L23
 907:FreeRTOS/Source/queue.c **** 		{
 908:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 442              		.loc 1 908 0
 443 0234 386A     		ldr	r0, [r7, #32]
 444 0236 00F08BFC 		bl	prvIsQueueFull
 445 023a 0346     		mov	r3, r0
 446 023c 002B     		cmp	r3, #0
 447 023e 18D0     		beq	.L24
 909:FreeRTOS/Source/queue.c **** 			{
 910:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 911:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 448              		.loc 1 911 0
 449 0240 3B6A     		ldr	r3, [r7, #32]
 450 0242 1033     		adds	r3, r3, #16
 451 0244 7A68     		ldr	r2, [r7, #4]
 452 0246 1146     		mov	r1, r2
 453 0248 1846     		mov	r0, r3
 454 024a FFF7FEFF 		bl	vTaskPlaceOnEventList
 912:FreeRTOS/Source/queue.c **** 
 913:FreeRTOS/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 914:FreeRTOS/Source/queue.c **** 				event list.  It is possible that interrupts occurring now
ARM GAS  /tmp/ccdqkONZ.s 			page 25


 915:FreeRTOS/Source/queue.c **** 				remove this task from the event list again - but as the
 916:FreeRTOS/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 917:FreeRTOS/Source/queue.c **** 				ready last instead of the actual ready list. */
 918:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 455              		.loc 1 918 0
 456 024e 386A     		ldr	r0, [r7, #32]
 457 0250 00F001FC 		bl	prvUnlockQueue
 919:FreeRTOS/Source/queue.c **** 
 920:FreeRTOS/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 921:FreeRTOS/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 922:FreeRTOS/Source/queue.c **** 				task is already in a ready list before it yields - in which
 923:FreeRTOS/Source/queue.c **** 				case the yield will not cause a context switch unless there
 924:FreeRTOS/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 925:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 458              		.loc 1 925 0
 459 0254 FFF7FEFF 		bl	xTaskResumeAll
 460 0258 0346     		mov	r3, r0
 461 025a 002B     		cmp	r3, #0
 462 025c 7FF47CAF 		bne	.L28
 926:FreeRTOS/Source/queue.c **** 				{
 927:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 463              		.loc 1 927 0
 464 0260 0C4B     		ldr	r3, .L30
 465 0262 4FF08052 		mov	r2, #268435456
 466 0266 1A60     		str	r2, [r3]
 467              		.syntax unified
 468              	@ 927 "FreeRTOS/Source/queue.c" 1
 469 0268 BFF34F8F 		dsb
 470              	@ 0 "" 2
 471              	@ 927 "FreeRTOS/Source/queue.c" 1
 472 026c BFF36F8F 		isb
 473              	@ 0 "" 2
 474              		.thumb
 475              		.syntax unified
 476 0270 72E7     		b	.L28
 477              	.L24:
 928:FreeRTOS/Source/queue.c **** 				}
 929:FreeRTOS/Source/queue.c **** 			}
 930:FreeRTOS/Source/queue.c **** 			else
 931:FreeRTOS/Source/queue.c **** 			{
 932:FreeRTOS/Source/queue.c **** 				/* Try again. */
 933:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 478              		.loc 1 933 0
 479 0272 386A     		ldr	r0, [r7, #32]
 480 0274 00F0EFFB 		bl	prvUnlockQueue
 934:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 481              		.loc 1 934 0
 482 0278 FFF7FEFF 		bl	xTaskResumeAll
 483 027c 6CE7     		b	.L28
 484              	.L23:
 935:FreeRTOS/Source/queue.c **** 			}
 936:FreeRTOS/Source/queue.c **** 		}
 937:FreeRTOS/Source/queue.c **** 		else
 938:FreeRTOS/Source/queue.c **** 		{
 939:FreeRTOS/Source/queue.c **** 			/* The timeout has expired. */
 940:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 485              		.loc 1 940 0
ARM GAS  /tmp/ccdqkONZ.s 			page 26


 486 027e 386A     		ldr	r0, [r7, #32]
 487 0280 00F0E9FB 		bl	prvUnlockQueue
 941:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 488              		.loc 1 941 0
 489 0284 FFF7FEFF 		bl	xTaskResumeAll
 942:FreeRTOS/Source/queue.c **** 
 943:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 944:FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 490              		.loc 1 944 0
 491 0288 0023     		movs	r3, #0
 492              	.L29:
 945:FreeRTOS/Source/queue.c **** 		}
 946:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
 947:FreeRTOS/Source/queue.c **** }
 493              		.loc 1 947 0 discriminator 3
 494 028a 1846     		mov	r0, r3
 495 028c 2837     		adds	r7, r7, #40
 496              		.cfi_def_cfa_offset 8
 497 028e BD46     		mov	sp, r7
 498              		.cfi_def_cfa_register 13
 499              		@ sp needed
 500 0290 80BD     		pop	{r7, pc}
 501              	.L31:
 502 0292 00BF     		.align	2
 503              	.L30:
 504 0294 04ED00E0 		.word	-536810236
 505              		.cfi_endproc
 506              	.LFE8:
 507              		.size	xQueueGenericSend, .-xQueueGenericSend
 508              		.align	1
 509              		.global	xQueueGenericSendFromISR
 510              		.syntax unified
 511              		.thumb
 512              		.thumb_func
 513              		.fpu softvfp
 514              		.type	xQueueGenericSendFromISR, %function
 515              	xQueueGenericSendFromISR:
 516              	.LFB9:
 948:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 949:FreeRTOS/Source/queue.c **** 
 950:FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 951:FreeRTOS/Source/queue.c **** {
 517              		.loc 1 951 0
 518              		.cfi_startproc
 519              		@ args = 0, pretend = 0, frame = 48
 520              		@ frame_needed = 1, uses_anonymous_args = 0
 521 0298 80B5     		push	{r7, lr}
 522              		.cfi_def_cfa_offset 8
 523              		.cfi_offset 7, -8
 524              		.cfi_offset 14, -4
 525 029a 8CB0     		sub	sp, sp, #48
 526              		.cfi_def_cfa_offset 56
 527 029c 00AF     		add	r7, sp, #0
 528              		.cfi_def_cfa_register 7
 529 029e F860     		str	r0, [r7, #12]
 530 02a0 B960     		str	r1, [r7, #8]
 531 02a2 7A60     		str	r2, [r7, #4]
ARM GAS  /tmp/ccdqkONZ.s 			page 27


 532 02a4 3B60     		str	r3, [r7]
 952:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
 953:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
 954:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 533              		.loc 1 954 0
 534 02a6 FB68     		ldr	r3, [r7, #12]
 535 02a8 BB62     		str	r3, [r7, #40]
 536              	.LBB23:
 537              	.LBB24:
 538              		.file 2 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h"
   1:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*
   2:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * FreeRTOS Kernel V10.3.1
   3:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
   5:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * subject to the following conditions:
  11:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  12:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * copies or substantial portions of the Software.
  14:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  15:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  22:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * http://www.FreeRTOS.org
  23:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * http://aws.amazon.com/freertos
  24:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  25:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * 1 tab == 4 spaces!
  26:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  */
  27:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  28:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  29:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #ifndef PORTMACRO_H
  30:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define PORTMACRO_H
  31:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  32:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #ifdef __cplusplus
  33:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** extern "C" {
  34:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
  35:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  36:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------
  37:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * Port specific definitions.
  38:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  39:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * given hardware and compiler.
  41:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  42:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * These settings should not be altered.
  43:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *-----------------------------------------------------------
  44:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  */
  45:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  46:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Type definitions. */
  47:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portCHAR		char
ARM GAS  /tmp/ccdqkONZ.s 			page 28


  48:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portFLOAT		float
  49:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portDOUBLE		double
  50:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portLONG		long
  51:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portSHORT		short
  52:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portSTACK_TYPE	uint32_t
  53:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portBASE_TYPE	long
  54:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  55:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  56:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** typedef long BaseType_t;
  57:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** typedef unsigned long UBaseType_t;
  58:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  59:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
  60:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	typedef uint16_t TickType_t;
  61:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
  62:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #else
  63:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	typedef uint32_t TickType_t;
  64:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
  65:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  66:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	not need to be guarded with a critical section. */
  68:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
  69:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
  70:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  71:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  72:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Architecture specifics. */
  73:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portSTACK_GROWTH			( -1 )
  74:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portBYTE_ALIGNMENT			8
  76:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  77:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  78:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Scheduler utilities. */
  79:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portYIELD() 															\
  80:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** {																				\
  81:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
  82:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
  83:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 																				\
  84:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
  85:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	within the specified behaviour for the architecture. */						\
  86:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile( "dsb" ::: "memory" );										\
  87:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile( "isb" );													\
  88:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
  89:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  90:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
  91:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
  92:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
  93:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
  94:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  95:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  96:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Critical section management. */
  97:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** extern void vPortEnterCritical( void );
  98:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** extern void vPortExitCritical( void );
  99:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 100:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 101:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 102:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 103:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 104:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
ARM GAS  /tmp/ccdqkONZ.s 			page 29


 105:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 106:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 107:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 108:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 109:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 110:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** (which build with all the ports) will build. */
 111:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 112:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 113:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 114:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 115:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Tickless idle/low power functionality. */
 116:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 117:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 118:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 119:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
 120:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 121:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 122:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Architecture specific optimisations. */
 123:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 124:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 125:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
 126:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 127:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 128:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 129:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Generic helper function. */
 130:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 131:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	{
 132:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	uint8_t ucReturn;
 133:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 134:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 135:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		return ucReturn;
 136:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	}
 137:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 138:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Check the configuration. */
 139:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 140:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 141:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#endif
 142:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 143:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 144:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 145:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 146:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 147:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/*-----------------------------------------------------------*/
 148:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 149:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 150:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 151:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 152:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 153:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 154:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 155:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #ifdef configASSERT
 156:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 157:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 158:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
 159:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 160:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* portNOP() is not required by this port. */
 161:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portNOP()
ARM GAS  /tmp/ccdqkONZ.s 			page 30


 162:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 163:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portINLINE	__inline
 164:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 165:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #ifndef portFORCE_INLINE
 166:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 167:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
 168:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 169:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 170:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 171:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** {
 173:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** uint32_t ulCurrentInterrupt;
 174:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** BaseType_t xReturn;
 175:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 176:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 177:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 178:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 179:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 180:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	{
 181:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		xReturn = pdFALSE;
 182:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	}
 183:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	else
 184:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	{
 185:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		xReturn = pdTRUE;
 186:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	}
 187:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 188:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	return xReturn;
 189:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
 190:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 191:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 192:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 193:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** {
 195:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** uint32_t ulNewBASEPRI;
 196:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 197:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile
 198:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 199:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	mov %0, %1												\n" \
 200:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	msr basepri, %0											\n" \
 201:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	isb														\n" \
 202:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 203:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 204:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	);
 205:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
 206:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 207:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 208:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 209:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 210:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** {
 211:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 212:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 213:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile
 539              		.loc 2 213 0
 540              		.syntax unified
 541              	@ 213 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 542 02aa EFF31182 			mrs r2, basepri											
 543 02ae 4FF0BF03 		mov r3, #191												
ARM GAS  /tmp/ccdqkONZ.s 			page 31


 544 02b2 83F31188 		msr basepri, r3											
 545 02b6 BFF36F8F 		isb														
 546 02ba BFF34F8F 		dsb														
 547              	
 548              	@ 0 "" 2
 549              		.thumb
 550              		.syntax unified
 551 02be BA61     		str	r2, [r7, #24]
 552 02c0 7B61     		str	r3, [r7, #20]
 214:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 215:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	mrs %0, basepri											\n" \
 216:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	mov %1, %2												\n" \
 217:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	msr basepri, %1											\n" \
 218:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	isb														\n" \
 219:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 220:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "
 221:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	);
 222:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 223:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 224:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	warnings. */
 225:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	return ulOriginalBASEPRI;
 553              		.loc 2 225 0
 554 02c2 BB69     		ldr	r3, [r7, #24]
 555              	.LBE24:
 556              	.LBE23:
 955:FreeRTOS/Source/queue.c **** 
 956:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 957:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 958:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 959:FreeRTOS/Source/queue.c **** 
 960:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 961:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 962:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 963:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 964:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 965:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 966:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 967:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 968:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 969:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 970:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 971:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 972:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 973:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 974:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 975:FreeRTOS/Source/queue.c **** 
 976:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 977:FreeRTOS/Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 978:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 979:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 980:FreeRTOS/Source/queue.c **** 	post). */
 981:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 557              		.loc 1 981 0
 558 02c4 7B62     		str	r3, [r7, #36]
 982:FreeRTOS/Source/queue.c **** 	{
 983:FreeRTOS/Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 559              		.loc 1 983 0
ARM GAS  /tmp/ccdqkONZ.s 			page 32


 560 02c6 BB6A     		ldr	r3, [r7, #40]
 561 02c8 9A6B     		ldr	r2, [r3, #56]
 562 02ca BB6A     		ldr	r3, [r7, #40]
 563 02cc DB6B     		ldr	r3, [r3, #60]
 564 02ce 9A42     		cmp	r2, r3
 565 02d0 02D3     		bcc	.L34
 566              		.loc 1 983 0 is_stmt 0 discriminator 1
 567 02d2 3B68     		ldr	r3, [r7]
 568 02d4 022B     		cmp	r3, #2
 569 02d6 2FD1     		bne	.L35
 570              	.L34:
 571              	.LBB25:
 984:FreeRTOS/Source/queue.c **** 		{
 985:FreeRTOS/Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 572              		.loc 1 985 0 is_stmt 1
 573 02d8 BB6A     		ldr	r3, [r7, #40]
 574 02da 93F84530 		ldrb	r3, [r3, #69]
 575 02de 87F82330 		strb	r3, [r7, #35]
 986:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 576              		.loc 1 986 0
 577 02e2 BB6A     		ldr	r3, [r7, #40]
 578 02e4 9B6B     		ldr	r3, [r3, #56]
 579 02e6 FB61     		str	r3, [r7, #28]
 987:FreeRTOS/Source/queue.c **** 
 988:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 989:FreeRTOS/Source/queue.c **** 
 990:FreeRTOS/Source/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 991:FreeRTOS/Source/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 992:FreeRTOS/Source/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 993:FreeRTOS/Source/queue.c **** 			called here even though the disinherit function does not check if
 994:FreeRTOS/Source/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
 995:FreeRTOS/Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 580              		.loc 1 995 0
 581 02e8 3A68     		ldr	r2, [r7]
 582 02ea B968     		ldr	r1, [r7, #8]
 583 02ec B86A     		ldr	r0, [r7, #40]
 584 02ee 00F030FB 		bl	prvCopyDataToQueue
 996:FreeRTOS/Source/queue.c **** 
 997:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
 998:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
 999:FreeRTOS/Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
 585              		.loc 1 999 0
 586 02f2 97F92330 		ldrsb	r3, [r7, #35]
 587 02f6 B3F1FF3F 		cmp	r3, #-1
 588 02fa 12D1     		bne	.L36
1000:FreeRTOS/Source/queue.c **** 			{
1001:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1002:FreeRTOS/Source/queue.c **** 				{
1003:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1004:FreeRTOS/Source/queue.c **** 					{
1005:FreeRTOS/Source/queue.c **** 						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 )
1006:FreeRTOS/Source/queue.c **** 						{
1007:FreeRTOS/Source/queue.c **** 							/* Do not notify the queue set as an existing item
1008:FreeRTOS/Source/queue.c **** 							was overwritten in the queue so the number of items
1009:FreeRTOS/Source/queue.c **** 							in the queue has not changed. */
1010:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1011:FreeRTOS/Source/queue.c **** 						}
ARM GAS  /tmp/ccdqkONZ.s 			page 33


1012:FreeRTOS/Source/queue.c **** 						else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1013:FreeRTOS/Source/queue.c **** 						{
1014:FreeRTOS/Source/queue.c **** 							/* The queue is a member of a queue set, and posting
1015:FreeRTOS/Source/queue.c **** 							to the queue set caused a higher priority task to
1016:FreeRTOS/Source/queue.c **** 							unblock.  A context switch is required. */
1017:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1018:FreeRTOS/Source/queue.c **** 							{
1019:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1020:FreeRTOS/Source/queue.c **** 							}
1021:FreeRTOS/Source/queue.c **** 							else
1022:FreeRTOS/Source/queue.c **** 							{
1023:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1024:FreeRTOS/Source/queue.c **** 							}
1025:FreeRTOS/Source/queue.c **** 						}
1026:FreeRTOS/Source/queue.c **** 						else
1027:FreeRTOS/Source/queue.c **** 						{
1028:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1029:FreeRTOS/Source/queue.c **** 						}
1030:FreeRTOS/Source/queue.c **** 					}
1031:FreeRTOS/Source/queue.c **** 					else
1032:FreeRTOS/Source/queue.c **** 					{
1033:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1034:FreeRTOS/Source/queue.c **** 						{
1035:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1036:FreeRTOS/Source/queue.c **** 							{
1037:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1038:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1039:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1040:FreeRTOS/Source/queue.c **** 								{
1041:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1042:FreeRTOS/Source/queue.c **** 								}
1043:FreeRTOS/Source/queue.c **** 								else
1044:FreeRTOS/Source/queue.c **** 								{
1045:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1046:FreeRTOS/Source/queue.c **** 								}
1047:FreeRTOS/Source/queue.c **** 							}
1048:FreeRTOS/Source/queue.c **** 							else
1049:FreeRTOS/Source/queue.c **** 							{
1050:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1051:FreeRTOS/Source/queue.c **** 							}
1052:FreeRTOS/Source/queue.c **** 						}
1053:FreeRTOS/Source/queue.c **** 						else
1054:FreeRTOS/Source/queue.c **** 						{
1055:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1056:FreeRTOS/Source/queue.c **** 						}
1057:FreeRTOS/Source/queue.c **** 					}
1058:FreeRTOS/Source/queue.c **** 				}
1059:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1060:FreeRTOS/Source/queue.c **** 				{
1061:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 589              		.loc 1 1061 0
 590 02fc BB6A     		ldr	r3, [r7, #40]
 591 02fe 5B6A     		ldr	r3, [r3, #36]
 592 0300 002B     		cmp	r3, #0
 593 0302 16D0     		beq	.L37
1062:FreeRTOS/Source/queue.c **** 					{
1063:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
ARM GAS  /tmp/ccdqkONZ.s 			page 34


 594              		.loc 1 1063 0
 595 0304 BB6A     		ldr	r3, [r7, #40]
 596 0306 2433     		adds	r3, r3, #36
 597 0308 1846     		mov	r0, r3
 598 030a FFF7FEFF 		bl	xTaskRemoveFromEventList
 599 030e 0346     		mov	r3, r0
 600 0310 002B     		cmp	r3, #0
 601 0312 0ED0     		beq	.L37
1064:FreeRTOS/Source/queue.c **** 						{
1065:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1066:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1067:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 602              		.loc 1 1067 0
 603 0314 7B68     		ldr	r3, [r7, #4]
 604 0316 002B     		cmp	r3, #0
 605 0318 0BD0     		beq	.L37
1068:FreeRTOS/Source/queue.c **** 							{
1069:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 606              		.loc 1 1069 0
 607 031a 7B68     		ldr	r3, [r7, #4]
 608 031c 0122     		movs	r2, #1
 609 031e 1A60     		str	r2, [r3]
 610 0320 07E0     		b	.L37
 611              	.L36:
1070:FreeRTOS/Source/queue.c **** 							}
1071:FreeRTOS/Source/queue.c **** 							else
1072:FreeRTOS/Source/queue.c **** 							{
1073:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1074:FreeRTOS/Source/queue.c **** 							}
1075:FreeRTOS/Source/queue.c **** 						}
1076:FreeRTOS/Source/queue.c **** 						else
1077:FreeRTOS/Source/queue.c **** 						{
1078:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1079:FreeRTOS/Source/queue.c **** 						}
1080:FreeRTOS/Source/queue.c **** 					}
1081:FreeRTOS/Source/queue.c **** 					else
1082:FreeRTOS/Source/queue.c **** 					{
1083:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1084:FreeRTOS/Source/queue.c **** 					}
1085:FreeRTOS/Source/queue.c **** 					
1086:FreeRTOS/Source/queue.c **** 					/* Not used in this path. */
1087:FreeRTOS/Source/queue.c **** 					( void ) uxPreviousMessagesWaiting;
1088:FreeRTOS/Source/queue.c **** 				}
1089:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1090:FreeRTOS/Source/queue.c **** 			}
1091:FreeRTOS/Source/queue.c **** 			else
1092:FreeRTOS/Source/queue.c **** 			{
1093:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1094:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1095:FreeRTOS/Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 612              		.loc 1 1095 0
 613 0322 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 614 0326 0133     		adds	r3, r3, #1
 615 0328 DBB2     		uxtb	r3, r3
 616 032a 5AB2     		sxtb	r2, r3
 617 032c BB6A     		ldr	r3, [r7, #40]
 618 032e 83F84520 		strb	r2, [r3, #69]
ARM GAS  /tmp/ccdqkONZ.s 			page 35


 619              	.L37:
1096:FreeRTOS/Source/queue.c **** 			}
1097:FreeRTOS/Source/queue.c **** 
1098:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 620              		.loc 1 1098 0
 621 0332 0123     		movs	r3, #1
 622 0334 FB62     		str	r3, [r7, #44]
 623              	.LBE25:
 984:FreeRTOS/Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 624              		.loc 1 984 0
 625 0336 01E0     		b	.L38
 626              	.L35:
1099:FreeRTOS/Source/queue.c **** 		}
1100:FreeRTOS/Source/queue.c **** 		else
1101:FreeRTOS/Source/queue.c **** 		{
1102:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1103:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 627              		.loc 1 1103 0
 628 0338 0023     		movs	r3, #0
 629 033a FB62     		str	r3, [r7, #44]
 630              	.L38:
 631 033c 7B6A     		ldr	r3, [r7, #36]
 632 033e 3B61     		str	r3, [r7, #16]
 633              	.LBB26:
 634              	.LBB27:
 226:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
 227:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 228:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 229:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 230:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** {
 231:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile
 635              		.loc 2 231 0
 636 0340 3B69     		ldr	r3, [r7, #16]
 637              		.syntax unified
 638              	@ 231 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 639 0342 83F31188 			msr basepri, r3	
 640              	@ 0 "" 2
 641              		.thumb
 642              		.syntax unified
 643              	.LBE27:
 644              	.LBE26:
1104:FreeRTOS/Source/queue.c **** 		}
1105:FreeRTOS/Source/queue.c **** 	}
1106:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1107:FreeRTOS/Source/queue.c **** 
1108:FreeRTOS/Source/queue.c **** 	return xReturn;
 645              		.loc 1 1108 0
 646 0346 FB6A     		ldr	r3, [r7, #44]
1109:FreeRTOS/Source/queue.c **** }
 647              		.loc 1 1109 0
 648 0348 1846     		mov	r0, r3
 649 034a 3037     		adds	r7, r7, #48
 650              		.cfi_def_cfa_offset 8
 651 034c BD46     		mov	sp, r7
 652              		.cfi_def_cfa_register 13
 653              		@ sp needed
 654 034e 80BD     		pop	{r7, pc}
ARM GAS  /tmp/ccdqkONZ.s 			page 36


 655              		.cfi_endproc
 656              	.LFE9:
 657              		.size	xQueueGenericSendFromISR, .-xQueueGenericSendFromISR
 658              		.align	1
 659              		.global	xQueueGiveFromISR
 660              		.syntax unified
 661              		.thumb
 662              		.thumb_func
 663              		.fpu softvfp
 664              		.type	xQueueGiveFromISR, %function
 665              	xQueueGiveFromISR:
 666              	.LFB10:
1110:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1111:FreeRTOS/Source/queue.c **** 
1112:FreeRTOS/Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1113:FreeRTOS/Source/queue.c **** {
 667              		.loc 1 1113 0
 668              		.cfi_startproc
 669              		@ args = 0, pretend = 0, frame = 40
 670              		@ frame_needed = 1, uses_anonymous_args = 0
 671 0350 80B5     		push	{r7, lr}
 672              		.cfi_def_cfa_offset 8
 673              		.cfi_offset 7, -8
 674              		.cfi_offset 14, -4
 675 0352 8AB0     		sub	sp, sp, #40
 676              		.cfi_def_cfa_offset 48
 677 0354 00AF     		add	r7, sp, #0
 678              		.cfi_def_cfa_register 7
 679 0356 7860     		str	r0, [r7, #4]
 680 0358 3960     		str	r1, [r7]
1114:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1115:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1116:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 681              		.loc 1 1116 0
 682 035a 7B68     		ldr	r3, [r7, #4]
 683 035c 3B62     		str	r3, [r7, #32]
 684              	.LBB28:
 685              	.LBB29:
 213:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 686              		.loc 2 213 0
 687              		.syntax unified
 688              	@ 213 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 689 035e EFF31182 			mrs r2, basepri											
 690 0362 4FF0BF03 		mov r3, #191												
 691 0366 83F31188 		msr basepri, r3											
 692 036a BFF36F8F 		isb														
 693 036e BFF34F8F 		dsb														
 694              	
 695              	@ 0 "" 2
 696              		.thumb
 697              		.syntax unified
 698 0372 3A61     		str	r2, [r7, #16]
 699 0374 FB60     		str	r3, [r7, #12]
 225:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
 700              		.loc 2 225 0
 701 0376 3B69     		ldr	r3, [r7, #16]
 702              	.LBE29:
ARM GAS  /tmp/ccdqkONZ.s 			page 37


 703              	.LBE28:
1117:FreeRTOS/Source/queue.c **** 
1118:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1119:FreeRTOS/Source/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1120:FreeRTOS/Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1121:FreeRTOS/Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1122:FreeRTOS/Source/queue.c **** 	post). */
1123:FreeRTOS/Source/queue.c **** 
1124:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1125:FreeRTOS/Source/queue.c **** 
1126:FreeRTOS/Source/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1127:FreeRTOS/Source/queue.c **** 	if the item size is not 0. */
1128:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1129:FreeRTOS/Source/queue.c **** 
1130:FreeRTOS/Source/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1131:FreeRTOS/Source/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1132:FreeRTOS/Source/queue.c **** 	interrupts, only tasks. */
1133:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutex
1134:FreeRTOS/Source/queue.c **** 
1135:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1136:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1137:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1138:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1139:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1140:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1141:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1142:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1143:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1144:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1145:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1146:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1147:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1148:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1149:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1150:FreeRTOS/Source/queue.c **** 
1151:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 704              		.loc 1 1151 0
 705 0378 FB61     		str	r3, [r7, #28]
 706              	.LBB30:
1152:FreeRTOS/Source/queue.c **** 	{
1153:FreeRTOS/Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 707              		.loc 1 1153 0
 708 037a 3B6A     		ldr	r3, [r7, #32]
 709 037c 9B6B     		ldr	r3, [r3, #56]
 710 037e BB61     		str	r3, [r7, #24]
1154:FreeRTOS/Source/queue.c **** 
1155:FreeRTOS/Source/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1156:FreeRTOS/Source/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1157:FreeRTOS/Source/queue.c **** 		space'. */
1158:FreeRTOS/Source/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
 711              		.loc 1 1158 0
 712 0380 3B6A     		ldr	r3, [r7, #32]
 713 0382 DA6B     		ldr	r2, [r3, #60]
 714 0384 BB69     		ldr	r3, [r7, #24]
 715 0386 9A42     		cmp	r2, r3
 716 0388 29D9     		bls	.L42
 717              	.LBB31:
ARM GAS  /tmp/ccdqkONZ.s 			page 38


1159:FreeRTOS/Source/queue.c **** 		{
1160:FreeRTOS/Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 718              		.loc 1 1160 0
 719 038a 3B6A     		ldr	r3, [r7, #32]
 720 038c 93F84530 		ldrb	r3, [r3, #69]
 721 0390 FB75     		strb	r3, [r7, #23]
1161:FreeRTOS/Source/queue.c **** 
1162:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1163:FreeRTOS/Source/queue.c **** 
1164:FreeRTOS/Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1165:FreeRTOS/Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1166:FreeRTOS/Source/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1167:FreeRTOS/Source/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1168:FreeRTOS/Source/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1169:FreeRTOS/Source/queue.c **** 			messages (semaphores) available. */
1170:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 722              		.loc 1 1170 0
 723 0392 BB69     		ldr	r3, [r7, #24]
 724 0394 5A1C     		adds	r2, r3, #1
 725 0396 3B6A     		ldr	r3, [r7, #32]
 726 0398 9A63     		str	r2, [r3, #56]
1171:FreeRTOS/Source/queue.c **** 
1172:FreeRTOS/Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1173:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
1174:FreeRTOS/Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
 727              		.loc 1 1174 0
 728 039a 97F91730 		ldrsb	r3, [r7, #23]
 729 039e B3F1FF3F 		cmp	r3, #-1
 730 03a2 12D1     		bne	.L43
1175:FreeRTOS/Source/queue.c **** 			{
1176:FreeRTOS/Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1177:FreeRTOS/Source/queue.c **** 				{
1178:FreeRTOS/Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1179:FreeRTOS/Source/queue.c **** 					{
1180:FreeRTOS/Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1181:FreeRTOS/Source/queue.c **** 						{
1182:FreeRTOS/Source/queue.c **** 							/* The semaphore is a member of a queue set, and
1183:FreeRTOS/Source/queue.c **** 							posting	to the queue set caused a higher priority
1184:FreeRTOS/Source/queue.c **** 							task to	unblock.  A context switch is required. */
1185:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1186:FreeRTOS/Source/queue.c **** 							{
1187:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1188:FreeRTOS/Source/queue.c **** 							}
1189:FreeRTOS/Source/queue.c **** 							else
1190:FreeRTOS/Source/queue.c **** 							{
1191:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1192:FreeRTOS/Source/queue.c **** 							}
1193:FreeRTOS/Source/queue.c **** 						}
1194:FreeRTOS/Source/queue.c **** 						else
1195:FreeRTOS/Source/queue.c **** 						{
1196:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1197:FreeRTOS/Source/queue.c **** 						}
1198:FreeRTOS/Source/queue.c **** 					}
1199:FreeRTOS/Source/queue.c **** 					else
1200:FreeRTOS/Source/queue.c **** 					{
1201:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1202:FreeRTOS/Source/queue.c **** 						{
ARM GAS  /tmp/ccdqkONZ.s 			page 39


1203:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1204:FreeRTOS/Source/queue.c **** 							{
1205:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority so
1206:FreeRTOS/Source/queue.c **** 								record that a context switch is required. */
1207:FreeRTOS/Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1208:FreeRTOS/Source/queue.c **** 								{
1209:FreeRTOS/Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1210:FreeRTOS/Source/queue.c **** 								}
1211:FreeRTOS/Source/queue.c **** 								else
1212:FreeRTOS/Source/queue.c **** 								{
1213:FreeRTOS/Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1214:FreeRTOS/Source/queue.c **** 								}
1215:FreeRTOS/Source/queue.c **** 							}
1216:FreeRTOS/Source/queue.c **** 							else
1217:FreeRTOS/Source/queue.c **** 							{
1218:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1219:FreeRTOS/Source/queue.c **** 							}
1220:FreeRTOS/Source/queue.c **** 						}
1221:FreeRTOS/Source/queue.c **** 						else
1222:FreeRTOS/Source/queue.c **** 						{
1223:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1224:FreeRTOS/Source/queue.c **** 						}
1225:FreeRTOS/Source/queue.c **** 					}
1226:FreeRTOS/Source/queue.c **** 				}
1227:FreeRTOS/Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1228:FreeRTOS/Source/queue.c **** 				{
1229:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 731              		.loc 1 1229 0
 732 03a4 3B6A     		ldr	r3, [r7, #32]
 733 03a6 5B6A     		ldr	r3, [r3, #36]
 734 03a8 002B     		cmp	r3, #0
 735 03aa 15D0     		beq	.L44
1230:FreeRTOS/Source/queue.c **** 					{
1231:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 736              		.loc 1 1231 0
 737 03ac 3B6A     		ldr	r3, [r7, #32]
 738 03ae 2433     		adds	r3, r3, #36
 739 03b0 1846     		mov	r0, r3
 740 03b2 FFF7FEFF 		bl	xTaskRemoveFromEventList
 741 03b6 0346     		mov	r3, r0
 742 03b8 002B     		cmp	r3, #0
 743 03ba 0DD0     		beq	.L44
1232:FreeRTOS/Source/queue.c **** 						{
1233:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1234:FreeRTOS/Source/queue.c **** 							context	switch is required. */
1235:FreeRTOS/Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 744              		.loc 1 1235 0
 745 03bc 3B68     		ldr	r3, [r7]
 746 03be 002B     		cmp	r3, #0
 747 03c0 0AD0     		beq	.L44
1236:FreeRTOS/Source/queue.c **** 							{
1237:FreeRTOS/Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 748              		.loc 1 1237 0
 749 03c2 3B68     		ldr	r3, [r7]
 750 03c4 0122     		movs	r2, #1
 751 03c6 1A60     		str	r2, [r3]
 752 03c8 06E0     		b	.L44
ARM GAS  /tmp/ccdqkONZ.s 			page 40


 753              	.L43:
1238:FreeRTOS/Source/queue.c **** 							}
1239:FreeRTOS/Source/queue.c **** 							else
1240:FreeRTOS/Source/queue.c **** 							{
1241:FreeRTOS/Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1242:FreeRTOS/Source/queue.c **** 							}
1243:FreeRTOS/Source/queue.c **** 						}
1244:FreeRTOS/Source/queue.c **** 						else
1245:FreeRTOS/Source/queue.c **** 						{
1246:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1247:FreeRTOS/Source/queue.c **** 						}
1248:FreeRTOS/Source/queue.c **** 					}
1249:FreeRTOS/Source/queue.c **** 					else
1250:FreeRTOS/Source/queue.c **** 					{
1251:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1252:FreeRTOS/Source/queue.c **** 					}
1253:FreeRTOS/Source/queue.c **** 				}
1254:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1255:FreeRTOS/Source/queue.c **** 			}
1256:FreeRTOS/Source/queue.c **** 			else
1257:FreeRTOS/Source/queue.c **** 			{
1258:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1259:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
1260:FreeRTOS/Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 754              		.loc 1 1260 0
 755 03ca FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 756 03cc 0133     		adds	r3, r3, #1
 757 03ce DBB2     		uxtb	r3, r3
 758 03d0 5AB2     		sxtb	r2, r3
 759 03d2 3B6A     		ldr	r3, [r7, #32]
 760 03d4 83F84520 		strb	r2, [r3, #69]
 761              	.L44:
1261:FreeRTOS/Source/queue.c **** 			}
1262:FreeRTOS/Source/queue.c **** 
1263:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 762              		.loc 1 1263 0
 763 03d8 0123     		movs	r3, #1
 764 03da 7B62     		str	r3, [r7, #36]
 765              	.LBE31:
 766 03dc 01E0     		b	.L45
 767              	.L42:
1264:FreeRTOS/Source/queue.c **** 		}
1265:FreeRTOS/Source/queue.c **** 		else
1266:FreeRTOS/Source/queue.c **** 		{
1267:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1268:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 768              		.loc 1 1268 0
 769 03de 0023     		movs	r3, #0
 770 03e0 7B62     		str	r3, [r7, #36]
 771              	.L45:
 772 03e2 FB69     		ldr	r3, [r7, #28]
 773 03e4 BB60     		str	r3, [r7, #8]
 774              	.LBE30:
 775              	.LBB32:
 776              	.LBB33:
 777              		.loc 2 231 0
 778 03e6 BB68     		ldr	r3, [r7, #8]
ARM GAS  /tmp/ccdqkONZ.s 			page 41


 779              		.syntax unified
 780              	@ 231 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 781 03e8 83F31188 			msr basepri, r3	
 782              	@ 0 "" 2
 783              		.thumb
 784              		.syntax unified
 785              	.LBE33:
 786              	.LBE32:
1269:FreeRTOS/Source/queue.c **** 		}
1270:FreeRTOS/Source/queue.c **** 	}
1271:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1272:FreeRTOS/Source/queue.c **** 
1273:FreeRTOS/Source/queue.c **** 	return xReturn;
 787              		.loc 1 1273 0
 788 03ec 7B6A     		ldr	r3, [r7, #36]
1274:FreeRTOS/Source/queue.c **** }
 789              		.loc 1 1274 0
 790 03ee 1846     		mov	r0, r3
 791 03f0 2837     		adds	r7, r7, #40
 792              		.cfi_def_cfa_offset 8
 793 03f2 BD46     		mov	sp, r7
 794              		.cfi_def_cfa_register 13
 795              		@ sp needed
 796 03f4 80BD     		pop	{r7, pc}
 797              		.cfi_endproc
 798              	.LFE10:
 799              		.size	xQueueGiveFromISR, .-xQueueGiveFromISR
 800              		.align	1
 801              		.global	xQueueReceive
 802              		.syntax unified
 803              		.thumb
 804              		.thumb_func
 805              		.fpu softvfp
 806              		.type	xQueueReceive, %function
 807              	xQueueReceive:
 808              	.LFB11:
1275:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1276:FreeRTOS/Source/queue.c **** 
1277:FreeRTOS/Source/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1278:FreeRTOS/Source/queue.c **** {
 809              		.loc 1 1278 0
 810              		.cfi_startproc
 811              		@ args = 0, pretend = 0, frame = 40
 812              		@ frame_needed = 1, uses_anonymous_args = 0
 813 03f6 80B5     		push	{r7, lr}
 814              		.cfi_def_cfa_offset 8
 815              		.cfi_offset 7, -8
 816              		.cfi_offset 14, -4
 817 03f8 8AB0     		sub	sp, sp, #40
 818              		.cfi_def_cfa_offset 48
 819 03fa 00AF     		add	r7, sp, #0
 820              		.cfi_def_cfa_register 7
 821 03fc F860     		str	r0, [r7, #12]
 822 03fe B960     		str	r1, [r7, #8]
 823 0400 7A60     		str	r2, [r7, #4]
1279:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 824              		.loc 1 1279 0
ARM GAS  /tmp/ccdqkONZ.s 			page 42


 825 0402 0023     		movs	r3, #0
 826 0404 7B62     		str	r3, [r7, #36]
1280:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1281:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 827              		.loc 1 1281 0
 828 0406 FB68     		ldr	r3, [r7, #12]
 829 0408 3B62     		str	r3, [r7, #32]
 830              	.L59:
1282:FreeRTOS/Source/queue.c **** 
1283:FreeRTOS/Source/queue.c **** 	/* Check the pointer is not NULL. */
1284:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1285:FreeRTOS/Source/queue.c **** 
1286:FreeRTOS/Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1287:FreeRTOS/Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1288:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1289:FreeRTOS/Source/queue.c **** 
1290:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1291:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1292:FreeRTOS/Source/queue.c **** 	{
1293:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1294:FreeRTOS/Source/queue.c **** 	}
1295:FreeRTOS/Source/queue.c **** 	#endif
1296:FreeRTOS/Source/queue.c **** 
1297:FreeRTOS/Source/queue.c **** 
1298:FreeRTOS/Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1299:FreeRTOS/Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1300:FreeRTOS/Source/queue.c **** 	interest of execution time efficiency. */
1301:FreeRTOS/Source/queue.c **** 	for( ;; )
1302:FreeRTOS/Source/queue.c **** 	{
1303:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 831              		.loc 1 1303 0
 832 040a FFF7FEFF 		bl	vPortEnterCritical
 833              	.LBB34:
1304:FreeRTOS/Source/queue.c **** 		{
1305:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 834              		.loc 1 1305 0
 835 040e 3B6A     		ldr	r3, [r7, #32]
 836 0410 9B6B     		ldr	r3, [r3, #56]
 837 0412 FB61     		str	r3, [r7, #28]
1306:FreeRTOS/Source/queue.c **** 
1307:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1308:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1309:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 838              		.loc 1 1309 0
 839 0414 FB69     		ldr	r3, [r7, #28]
 840 0416 002B     		cmp	r3, #0
 841 0418 1FD0     		beq	.L48
1310:FreeRTOS/Source/queue.c **** 			{
1311:FreeRTOS/Source/queue.c **** 				/* Data available, remove one item. */
1312:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 842              		.loc 1 1312 0
 843 041a B968     		ldr	r1, [r7, #8]
 844 041c 386A     		ldr	r0, [r7, #32]
 845 041e 00F0F4FA 		bl	prvCopyDataFromQueue
1313:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1314:FreeRTOS/Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 846              		.loc 1 1314 0
ARM GAS  /tmp/ccdqkONZ.s 			page 43


 847 0422 FB69     		ldr	r3, [r7, #28]
 848 0424 5A1E     		subs	r2, r3, #1
 849 0426 3B6A     		ldr	r3, [r7, #32]
 850 0428 9A63     		str	r2, [r3, #56]
1315:FreeRTOS/Source/queue.c **** 
1316:FreeRTOS/Source/queue.c **** 				/* There is now space in the queue, were any tasks waiting to
1317:FreeRTOS/Source/queue.c **** 				post to the queue?  If so, unblock the highest priority waiting
1318:FreeRTOS/Source/queue.c **** 				task. */
1319:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 851              		.loc 1 1319 0
 852 042a 3B6A     		ldr	r3, [r7, #32]
 853 042c 1B69     		ldr	r3, [r3, #16]
 854 042e 002B     		cmp	r3, #0
 855 0430 0FD0     		beq	.L49
1320:FreeRTOS/Source/queue.c **** 				{
1321:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 856              		.loc 1 1321 0
 857 0432 3B6A     		ldr	r3, [r7, #32]
 858 0434 1033     		adds	r3, r3, #16
 859 0436 1846     		mov	r0, r3
 860 0438 FFF7FEFF 		bl	xTaskRemoveFromEventList
 861 043c 0346     		mov	r3, r0
 862 043e 002B     		cmp	r3, #0
 863 0440 07D0     		beq	.L49
1322:FreeRTOS/Source/queue.c **** 					{
1323:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 864              		.loc 1 1323 0
 865 0442 3D4B     		ldr	r3, .L61
 866 0444 4FF08052 		mov	r2, #268435456
 867 0448 1A60     		str	r2, [r3]
 868              		.syntax unified
 869              	@ 1323 "FreeRTOS/Source/queue.c" 1
 870 044a BFF34F8F 		dsb
 871              	@ 0 "" 2
 872              	@ 1323 "FreeRTOS/Source/queue.c" 1
 873 044e BFF36F8F 		isb
 874              	@ 0 "" 2
 875              		.thumb
 876              		.syntax unified
 877              	.L49:
1324:FreeRTOS/Source/queue.c **** 					}
1325:FreeRTOS/Source/queue.c **** 					else
1326:FreeRTOS/Source/queue.c **** 					{
1327:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1328:FreeRTOS/Source/queue.c **** 					}
1329:FreeRTOS/Source/queue.c **** 				}
1330:FreeRTOS/Source/queue.c **** 				else
1331:FreeRTOS/Source/queue.c **** 				{
1332:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1333:FreeRTOS/Source/queue.c **** 				}
1334:FreeRTOS/Source/queue.c **** 
1335:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 878              		.loc 1 1335 0
 879 0452 FFF7FEFF 		bl	vPortExitCritical
1336:FreeRTOS/Source/queue.c **** 				return pdPASS;
 880              		.loc 1 1336 0
 881 0456 0123     		movs	r3, #1
ARM GAS  /tmp/ccdqkONZ.s 			page 44


 882 0458 69E0     		b	.L60
 883              	.L48:
1337:FreeRTOS/Source/queue.c **** 			}
1338:FreeRTOS/Source/queue.c **** 			else
1339:FreeRTOS/Source/queue.c **** 			{
1340:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 884              		.loc 1 1340 0
 885 045a 7B68     		ldr	r3, [r7, #4]
 886 045c 002B     		cmp	r3, #0
 887 045e 03D1     		bne	.L51
1341:FreeRTOS/Source/queue.c **** 				{
1342:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1343:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1344:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 888              		.loc 1 1344 0
 889 0460 FFF7FEFF 		bl	vPortExitCritical
1345:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1346:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 890              		.loc 1 1346 0
 891 0464 0023     		movs	r3, #0
 892 0466 62E0     		b	.L60
 893              	.L51:
1347:FreeRTOS/Source/queue.c **** 				}
1348:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 894              		.loc 1 1348 0
 895 0468 7B6A     		ldr	r3, [r7, #36]
 896 046a 002B     		cmp	r3, #0
 897 046c 06D1     		bne	.L52
1349:FreeRTOS/Source/queue.c **** 				{
1350:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1351:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
1352:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 898              		.loc 1 1352 0
 899 046e 07F11403 		add	r3, r7, #20
 900 0472 1846     		mov	r0, r3
 901 0474 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1353:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 902              		.loc 1 1353 0
 903 0478 0123     		movs	r3, #1
 904 047a 7B62     		str	r3, [r7, #36]
 905              	.L52:
 906              	.LBE34:
1354:FreeRTOS/Source/queue.c **** 				}
1355:FreeRTOS/Source/queue.c **** 				else
1356:FreeRTOS/Source/queue.c **** 				{
1357:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1358:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1359:FreeRTOS/Source/queue.c **** 				}
1360:FreeRTOS/Source/queue.c **** 			}
1361:FreeRTOS/Source/queue.c **** 		}
1362:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 907              		.loc 1 1362 0
 908 047c FFF7FEFF 		bl	vPortExitCritical
1363:FreeRTOS/Source/queue.c **** 
1364:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1365:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1366:FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccdqkONZ.s 			page 45


1367:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 909              		.loc 1 1367 0
 910 0480 FFF7FEFF 		bl	vTaskSuspendAll
1368:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 911              		.loc 1 1368 0
 912 0484 FFF7FEFF 		bl	vPortEnterCritical
 913 0488 3B6A     		ldr	r3, [r7, #32]
 914 048a 93F84430 		ldrb	r3, [r3, #68]
 915 048e 5BB2     		sxtb	r3, r3
 916 0490 B3F1FF3F 		cmp	r3, #-1
 917 0494 03D1     		bne	.L53
 918              		.loc 1 1368 0 is_stmt 0 discriminator 1
 919 0496 3B6A     		ldr	r3, [r7, #32]
 920 0498 0022     		movs	r2, #0
 921 049a 83F84420 		strb	r2, [r3, #68]
 922              	.L53:
 923              		.loc 1 1368 0 discriminator 3
 924 049e 3B6A     		ldr	r3, [r7, #32]
 925 04a0 93F84530 		ldrb	r3, [r3, #69]
 926 04a4 5BB2     		sxtb	r3, r3
 927 04a6 B3F1FF3F 		cmp	r3, #-1
 928 04aa 03D1     		bne	.L54
 929              		.loc 1 1368 0 discriminator 4
 930 04ac 3B6A     		ldr	r3, [r7, #32]
 931 04ae 0022     		movs	r2, #0
 932 04b0 83F84520 		strb	r2, [r3, #69]
 933              	.L54:
 934              		.loc 1 1368 0 discriminator 6
 935 04b4 FFF7FEFF 		bl	vPortExitCritical
1369:FreeRTOS/Source/queue.c **** 
1370:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1371:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 936              		.loc 1 1371 0 is_stmt 1 discriminator 6
 937 04b8 3A1D     		adds	r2, r7, #4
 938 04ba 07F11403 		add	r3, r7, #20
 939 04be 1146     		mov	r1, r2
 940 04c0 1846     		mov	r0, r3
 941 04c2 FFF7FEFF 		bl	xTaskCheckForTimeOut
 942 04c6 0346     		mov	r3, r0
 943 04c8 002B     		cmp	r3, #0
 944 04ca 23D1     		bne	.L55
1372:FreeRTOS/Source/queue.c **** 		{
1373:FreeRTOS/Source/queue.c **** 			/* The timeout has not expired.  If the queue is still empty place
1374:FreeRTOS/Source/queue.c **** 			the task on the list of tasks waiting to receive from the queue. */
1375:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 945              		.loc 1 1375 0
 946 04cc 386A     		ldr	r0, [r7, #32]
 947 04ce 00F014FB 		bl	prvIsQueueEmpty
 948 04d2 0346     		mov	r3, r0
 949 04d4 002B     		cmp	r3, #0
 950 04d6 17D0     		beq	.L56
1376:FreeRTOS/Source/queue.c **** 			{
1377:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1378:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 951              		.loc 1 1378 0
 952 04d8 3B6A     		ldr	r3, [r7, #32]
 953 04da 2433     		adds	r3, r3, #36
ARM GAS  /tmp/ccdqkONZ.s 			page 46


 954 04dc 7A68     		ldr	r2, [r7, #4]
 955 04de 1146     		mov	r1, r2
 956 04e0 1846     		mov	r0, r3
 957 04e2 FFF7FEFF 		bl	vTaskPlaceOnEventList
1379:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 958              		.loc 1 1379 0
 959 04e6 386A     		ldr	r0, [r7, #32]
 960 04e8 00F0B5FA 		bl	prvUnlockQueue
1380:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 961              		.loc 1 1380 0
 962 04ec FFF7FEFF 		bl	xTaskResumeAll
 963 04f0 0346     		mov	r3, r0
 964 04f2 002B     		cmp	r3, #0
 965 04f4 89D1     		bne	.L59
1381:FreeRTOS/Source/queue.c **** 				{
1382:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 966              		.loc 1 1382 0
 967 04f6 104B     		ldr	r3, .L61
 968 04f8 4FF08052 		mov	r2, #268435456
 969 04fc 1A60     		str	r2, [r3]
 970              		.syntax unified
 971              	@ 1382 "FreeRTOS/Source/queue.c" 1
 972 04fe BFF34F8F 		dsb
 973              	@ 0 "" 2
 974              	@ 1382 "FreeRTOS/Source/queue.c" 1
 975 0502 BFF36F8F 		isb
 976              	@ 0 "" 2
 977              		.thumb
 978              		.syntax unified
 979 0506 80E7     		b	.L59
 980              	.L56:
1383:FreeRTOS/Source/queue.c **** 				}
1384:FreeRTOS/Source/queue.c **** 				else
1385:FreeRTOS/Source/queue.c **** 				{
1386:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1387:FreeRTOS/Source/queue.c **** 				}
1388:FreeRTOS/Source/queue.c **** 			}
1389:FreeRTOS/Source/queue.c **** 			else
1390:FreeRTOS/Source/queue.c **** 			{
1391:FreeRTOS/Source/queue.c **** 				/* The queue contains data again.  Loop back to try and read the
1392:FreeRTOS/Source/queue.c **** 				data. */
1393:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 981              		.loc 1 1393 0
 982 0508 386A     		ldr	r0, [r7, #32]
 983 050a 00F0A4FA 		bl	prvUnlockQueue
1394:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 984              		.loc 1 1394 0
 985 050e FFF7FEFF 		bl	xTaskResumeAll
 986 0512 7AE7     		b	.L59
 987              	.L55:
1395:FreeRTOS/Source/queue.c **** 			}
1396:FreeRTOS/Source/queue.c **** 		}
1397:FreeRTOS/Source/queue.c **** 		else
1398:FreeRTOS/Source/queue.c **** 		{
1399:FreeRTOS/Source/queue.c **** 			/* Timed out.  If there is no data in the queue exit, otherwise loop
1400:FreeRTOS/Source/queue.c **** 			back and attempt to read the data. */
1401:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
ARM GAS  /tmp/ccdqkONZ.s 			page 47


 988              		.loc 1 1401 0
 989 0514 386A     		ldr	r0, [r7, #32]
 990 0516 00F09EFA 		bl	prvUnlockQueue
1402:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 991              		.loc 1 1402 0
 992 051a FFF7FEFF 		bl	xTaskResumeAll
1403:FreeRTOS/Source/queue.c **** 
1404:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 993              		.loc 1 1404 0
 994 051e 386A     		ldr	r0, [r7, #32]
 995 0520 00F0EBFA 		bl	prvIsQueueEmpty
 996 0524 0346     		mov	r3, r0
 997 0526 002B     		cmp	r3, #0
 998 0528 3FF46FAF 		beq	.L59
1405:FreeRTOS/Source/queue.c **** 			{
1406:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1407:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
 999              		.loc 1 1407 0
 1000 052c 0023     		movs	r3, #0
 1001              	.L60:
1408:FreeRTOS/Source/queue.c **** 			}
1409:FreeRTOS/Source/queue.c **** 			else
1410:FreeRTOS/Source/queue.c **** 			{
1411:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1412:FreeRTOS/Source/queue.c **** 			}
1413:FreeRTOS/Source/queue.c **** 		}
1414:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
1415:FreeRTOS/Source/queue.c **** }
 1002              		.loc 1 1415 0 discriminator 3
 1003 052e 1846     		mov	r0, r3
 1004 0530 2837     		adds	r7, r7, #40
 1005              		.cfi_def_cfa_offset 8
 1006 0532 BD46     		mov	sp, r7
 1007              		.cfi_def_cfa_register 13
 1008              		@ sp needed
 1009 0534 80BD     		pop	{r7, pc}
 1010              	.L62:
 1011 0536 00BF     		.align	2
 1012              	.L61:
 1013 0538 04ED00E0 		.word	-536810236
 1014              		.cfi_endproc
 1015              	.LFE11:
 1016              		.size	xQueueReceive, .-xQueueReceive
 1017              		.align	1
 1018              		.global	xQueueSemaphoreTake
 1019              		.syntax unified
 1020              		.thumb
 1021              		.thumb_func
 1022              		.fpu softvfp
 1023              		.type	xQueueSemaphoreTake, %function
 1024              	xQueueSemaphoreTake:
 1025              	.LFB12:
1416:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1417:FreeRTOS/Source/queue.c **** 
1418:FreeRTOS/Source/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
1419:FreeRTOS/Source/queue.c **** {
 1026              		.loc 1 1419 0
ARM GAS  /tmp/ccdqkONZ.s 			page 48


 1027              		.cfi_startproc
 1028              		@ args = 0, pretend = 0, frame = 32
 1029              		@ frame_needed = 1, uses_anonymous_args = 0
 1030 053c 80B5     		push	{r7, lr}
 1031              		.cfi_def_cfa_offset 8
 1032              		.cfi_offset 7, -8
 1033              		.cfi_offset 14, -4
 1034 053e 88B0     		sub	sp, sp, #32
 1035              		.cfi_def_cfa_offset 40
 1036 0540 00AF     		add	r7, sp, #0
 1037              		.cfi_def_cfa_register 7
 1038 0542 7860     		str	r0, [r7, #4]
 1039 0544 3960     		str	r1, [r7]
1420:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1040              		.loc 1 1420 0
 1041 0546 0023     		movs	r3, #0
 1042 0548 FB61     		str	r3, [r7, #28]
1421:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1422:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1043              		.loc 1 1422 0
 1044 054a 7B68     		ldr	r3, [r7, #4]
 1045 054c BB61     		str	r3, [r7, #24]
 1046              	.L75:
1423:FreeRTOS/Source/queue.c **** 
1424:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
1425:FreeRTOS/Source/queue.c **** 	BaseType_t xInheritanceOccurred = pdFALSE;
1426:FreeRTOS/Source/queue.c **** #endif
1427:FreeRTOS/Source/queue.c **** 
1428:FreeRTOS/Source/queue.c **** 	/* Check the queue pointer is not NULL. */
1429:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1430:FreeRTOS/Source/queue.c **** 
1431:FreeRTOS/Source/queue.c **** 	/* Check this really is a semaphore, in which case the item size will be
1432:FreeRTOS/Source/queue.c **** 	0. */
1433:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1434:FreeRTOS/Source/queue.c **** 
1435:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1436:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1437:FreeRTOS/Source/queue.c **** 	{
1438:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1439:FreeRTOS/Source/queue.c **** 	}
1440:FreeRTOS/Source/queue.c **** 	#endif
1441:FreeRTOS/Source/queue.c **** 
1442:FreeRTOS/Source/queue.c **** 
1443:FreeRTOS/Source/queue.c **** 	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1444:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
1445:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
1446:FreeRTOS/Source/queue.c **** 	for( ;; )
1447:FreeRTOS/Source/queue.c **** 	{
1448:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 1047              		.loc 1 1448 0
 1048 054e FFF7FEFF 		bl	vPortEnterCritical
 1049              	.LBB35:
1449:FreeRTOS/Source/queue.c **** 		{
1450:FreeRTOS/Source/queue.c **** 			/* Semaphores are queues with an item size of 0, and where the
1451:FreeRTOS/Source/queue.c **** 			number of messages in the queue is the semaphore's count value. */
1452:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 1050              		.loc 1 1452 0
ARM GAS  /tmp/ccdqkONZ.s 			page 49


 1051 0552 BB69     		ldr	r3, [r7, #24]
 1052 0554 9B6B     		ldr	r3, [r3, #56]
 1053 0556 7B61     		str	r3, [r7, #20]
1453:FreeRTOS/Source/queue.c **** 
1454:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1455:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1456:FreeRTOS/Source/queue.c **** 			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 1054              		.loc 1 1456 0
 1055 0558 7B69     		ldr	r3, [r7, #20]
 1056 055a 002B     		cmp	r3, #0
 1057 055c 1BD0     		beq	.L64
1457:FreeRTOS/Source/queue.c **** 			{
1458:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE( pxQueue );
1459:FreeRTOS/Source/queue.c **** 
1460:FreeRTOS/Source/queue.c **** 				/* Semaphores are queues with a data size of zero and where the
1461:FreeRTOS/Source/queue.c **** 				messages waiting is the semaphore's count.  Reduce the count. */
1462:FreeRTOS/Source/queue.c **** 				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 1058              		.loc 1 1462 0
 1059 055e 7B69     		ldr	r3, [r7, #20]
 1060 0560 5A1E     		subs	r2, r3, #1
 1061 0562 BB69     		ldr	r3, [r7, #24]
 1062 0564 9A63     		str	r2, [r3, #56]
1463:FreeRTOS/Source/queue.c **** 
1464:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1465:FreeRTOS/Source/queue.c **** 				{
1466:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1467:FreeRTOS/Source/queue.c **** 					{
1468:FreeRTOS/Source/queue.c **** 						/* Record the information required to implement
1469:FreeRTOS/Source/queue.c **** 						priority inheritance should it become necessary. */
1470:FreeRTOS/Source/queue.c **** 						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
1471:FreeRTOS/Source/queue.c **** 					}
1472:FreeRTOS/Source/queue.c **** 					else
1473:FreeRTOS/Source/queue.c **** 					{
1474:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1475:FreeRTOS/Source/queue.c **** 					}
1476:FreeRTOS/Source/queue.c **** 				}
1477:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1478:FreeRTOS/Source/queue.c **** 
1479:FreeRTOS/Source/queue.c **** 				/* Check to see if other tasks are blocked waiting to give the
1480:FreeRTOS/Source/queue.c **** 				semaphore, and if so, unblock the highest priority such task. */
1481:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1063              		.loc 1 1481 0
 1064 0566 BB69     		ldr	r3, [r7, #24]
 1065 0568 1B69     		ldr	r3, [r3, #16]
 1066 056a 002B     		cmp	r3, #0
 1067 056c 0FD0     		beq	.L65
1482:FreeRTOS/Source/queue.c **** 				{
1483:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1068              		.loc 1 1483 0
 1069 056e BB69     		ldr	r3, [r7, #24]
 1070 0570 1033     		adds	r3, r3, #16
 1071 0572 1846     		mov	r0, r3
 1072 0574 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1073 0578 0346     		mov	r3, r0
 1074 057a 002B     		cmp	r3, #0
 1075 057c 07D0     		beq	.L65
1484:FreeRTOS/Source/queue.c **** 					{
ARM GAS  /tmp/ccdqkONZ.s 			page 50


1485:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 1076              		.loc 1 1485 0
 1077 057e 3D4B     		ldr	r3, .L77
 1078 0580 4FF08052 		mov	r2, #268435456
 1079 0584 1A60     		str	r2, [r3]
 1080              		.syntax unified
 1081              	@ 1485 "FreeRTOS/Source/queue.c" 1
 1082 0586 BFF34F8F 		dsb
 1083              	@ 0 "" 2
 1084              	@ 1485 "FreeRTOS/Source/queue.c" 1
 1085 058a BFF36F8F 		isb
 1086              	@ 0 "" 2
 1087              		.thumb
 1088              		.syntax unified
 1089              	.L65:
1486:FreeRTOS/Source/queue.c **** 					}
1487:FreeRTOS/Source/queue.c **** 					else
1488:FreeRTOS/Source/queue.c **** 					{
1489:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1490:FreeRTOS/Source/queue.c **** 					}
1491:FreeRTOS/Source/queue.c **** 				}
1492:FreeRTOS/Source/queue.c **** 				else
1493:FreeRTOS/Source/queue.c **** 				{
1494:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1495:FreeRTOS/Source/queue.c **** 				}
1496:FreeRTOS/Source/queue.c **** 
1497:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 1090              		.loc 1 1497 0
 1091 058e FFF7FEFF 		bl	vPortExitCritical
1498:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1092              		.loc 1 1498 0
 1093 0592 0123     		movs	r3, #1
 1094 0594 69E0     		b	.L76
 1095              	.L64:
1499:FreeRTOS/Source/queue.c **** 			}
1500:FreeRTOS/Source/queue.c **** 			else
1501:FreeRTOS/Source/queue.c **** 			{
1502:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1096              		.loc 1 1502 0
 1097 0596 3B68     		ldr	r3, [r7]
 1098 0598 002B     		cmp	r3, #0
 1099 059a 03D1     		bne	.L67
1503:FreeRTOS/Source/queue.c **** 				{
1504:FreeRTOS/Source/queue.c **** 					/* For inheritance to have occurred there must have been an
1505:FreeRTOS/Source/queue.c **** 					initial timeout, and an adjusted timeout cannot become 0, as
1506:FreeRTOS/Source/queue.c **** 					if it were 0 the function would have exited. */
1507:FreeRTOS/Source/queue.c **** 					#if( configUSE_MUTEXES == 1 )
1508:FreeRTOS/Source/queue.c **** 					{
1509:FreeRTOS/Source/queue.c **** 						configASSERT( xInheritanceOccurred == pdFALSE );
1510:FreeRTOS/Source/queue.c **** 					}
1511:FreeRTOS/Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1512:FreeRTOS/Source/queue.c **** 
1513:FreeRTOS/Source/queue.c **** 					/* The semaphore count was 0 and no block time is specified
1514:FreeRTOS/Source/queue.c **** 					(or the block time has expired) so exit now. */
1515:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 1100              		.loc 1 1515 0
 1101 059c FFF7FEFF 		bl	vPortExitCritical
ARM GAS  /tmp/ccdqkONZ.s 			page 51


1516:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1517:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 1102              		.loc 1 1517 0
 1103 05a0 0023     		movs	r3, #0
 1104 05a2 62E0     		b	.L76
 1105              	.L67:
1518:FreeRTOS/Source/queue.c **** 				}
1519:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1106              		.loc 1 1519 0
 1107 05a4 FB69     		ldr	r3, [r7, #28]
 1108 05a6 002B     		cmp	r3, #0
 1109 05a8 06D1     		bne	.L68
1520:FreeRTOS/Source/queue.c **** 				{
1521:FreeRTOS/Source/queue.c **** 					/* The semaphore count was 0 and a block time was specified
1522:FreeRTOS/Source/queue.c **** 					so configure the timeout structure ready to block. */
1523:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 1110              		.loc 1 1523 0
 1111 05aa 07F10C03 		add	r3, r7, #12
 1112 05ae 1846     		mov	r0, r3
 1113 05b0 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1524:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1114              		.loc 1 1524 0
 1115 05b4 0123     		movs	r3, #1
 1116 05b6 FB61     		str	r3, [r7, #28]
 1117              	.L68:
 1118              	.LBE35:
1525:FreeRTOS/Source/queue.c **** 				}
1526:FreeRTOS/Source/queue.c **** 				else
1527:FreeRTOS/Source/queue.c **** 				{
1528:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1529:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1530:FreeRTOS/Source/queue.c **** 				}
1531:FreeRTOS/Source/queue.c **** 			}
1532:FreeRTOS/Source/queue.c **** 		}
1533:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 1119              		.loc 1 1533 0
 1120 05b8 FFF7FEFF 		bl	vPortExitCritical
1534:FreeRTOS/Source/queue.c **** 
1535:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can give to and take from the semaphore
1536:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
1537:FreeRTOS/Source/queue.c **** 
1538:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 1121              		.loc 1 1538 0
 1122 05bc FFF7FEFF 		bl	vTaskSuspendAll
1539:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1123              		.loc 1 1539 0
 1124 05c0 FFF7FEFF 		bl	vPortEnterCritical
 1125 05c4 BB69     		ldr	r3, [r7, #24]
 1126 05c6 93F84430 		ldrb	r3, [r3, #68]
 1127 05ca 5BB2     		sxtb	r3, r3
 1128 05cc B3F1FF3F 		cmp	r3, #-1
 1129 05d0 03D1     		bne	.L69
 1130              		.loc 1 1539 0 is_stmt 0 discriminator 1
 1131 05d2 BB69     		ldr	r3, [r7, #24]
 1132 05d4 0022     		movs	r2, #0
 1133 05d6 83F84420 		strb	r2, [r3, #68]
 1134              	.L69:
ARM GAS  /tmp/ccdqkONZ.s 			page 52


 1135              		.loc 1 1539 0 discriminator 3
 1136 05da BB69     		ldr	r3, [r7, #24]
 1137 05dc 93F84530 		ldrb	r3, [r3, #69]
 1138 05e0 5BB2     		sxtb	r3, r3
 1139 05e2 B3F1FF3F 		cmp	r3, #-1
 1140 05e6 03D1     		bne	.L70
 1141              		.loc 1 1539 0 discriminator 4
 1142 05e8 BB69     		ldr	r3, [r7, #24]
 1143 05ea 0022     		movs	r2, #0
 1144 05ec 83F84520 		strb	r2, [r3, #69]
 1145              	.L70:
 1146              		.loc 1 1539 0 discriminator 6
 1147 05f0 FFF7FEFF 		bl	vPortExitCritical
1540:FreeRTOS/Source/queue.c **** 
1541:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1542:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1148              		.loc 1 1542 0 is_stmt 1 discriminator 6
 1149 05f4 3A46     		mov	r2, r7
 1150 05f6 07F10C03 		add	r3, r7, #12
 1151 05fa 1146     		mov	r1, r2
 1152 05fc 1846     		mov	r0, r3
 1153 05fe FFF7FEFF 		bl	xTaskCheckForTimeOut
 1154 0602 0346     		mov	r3, r0
 1155 0604 002B     		cmp	r3, #0
 1156 0606 23D1     		bne	.L71
1543:FreeRTOS/Source/queue.c **** 		{
1544:FreeRTOS/Source/queue.c **** 			/* A block time is specified and not expired.  If the semaphore
1545:FreeRTOS/Source/queue.c **** 			count is 0 then enter the Blocked state to wait for a semaphore to
1546:FreeRTOS/Source/queue.c **** 			become available.  As semaphores are implemented with queues the
1547:FreeRTOS/Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1548:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1157              		.loc 1 1548 0
 1158 0608 B869     		ldr	r0, [r7, #24]
 1159 060a 00F076FA 		bl	prvIsQueueEmpty
 1160 060e 0346     		mov	r3, r0
 1161 0610 002B     		cmp	r3, #0
 1162 0612 17D0     		beq	.L72
1549:FreeRTOS/Source/queue.c **** 			{
1550:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1551:FreeRTOS/Source/queue.c **** 
1552:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1553:FreeRTOS/Source/queue.c **** 				{
1554:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1555:FreeRTOS/Source/queue.c **** 					{
1556:FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
1557:FreeRTOS/Source/queue.c **** 						{
1558:FreeRTOS/Source/queue.c **** 							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
1559:FreeRTOS/Source/queue.c **** 						}
1560:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
1561:FreeRTOS/Source/queue.c **** 					}
1562:FreeRTOS/Source/queue.c **** 					else
1563:FreeRTOS/Source/queue.c **** 					{
1564:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1565:FreeRTOS/Source/queue.c **** 					}
1566:FreeRTOS/Source/queue.c **** 				}
1567:FreeRTOS/Source/queue.c **** 				#endif
1568:FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccdqkONZ.s 			page 53


1569:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1163              		.loc 1 1569 0
 1164 0614 BB69     		ldr	r3, [r7, #24]
 1165 0616 2433     		adds	r3, r3, #36
 1166 0618 3A68     		ldr	r2, [r7]
 1167 061a 1146     		mov	r1, r2
 1168 061c 1846     		mov	r0, r3
 1169 061e FFF7FEFF 		bl	vTaskPlaceOnEventList
1570:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1170              		.loc 1 1570 0
 1171 0622 B869     		ldr	r0, [r7, #24]
 1172 0624 00F017FA 		bl	prvUnlockQueue
1571:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1173              		.loc 1 1571 0
 1174 0628 FFF7FEFF 		bl	xTaskResumeAll
 1175 062c 0346     		mov	r3, r0
 1176 062e 002B     		cmp	r3, #0
 1177 0630 8DD1     		bne	.L75
1572:FreeRTOS/Source/queue.c **** 				{
1573:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 1178              		.loc 1 1573 0
 1179 0632 104B     		ldr	r3, .L77
 1180 0634 4FF08052 		mov	r2, #268435456
 1181 0638 1A60     		str	r2, [r3]
 1182              		.syntax unified
 1183              	@ 1573 "FreeRTOS/Source/queue.c" 1
 1184 063a BFF34F8F 		dsb
 1185              	@ 0 "" 2
 1186              	@ 1573 "FreeRTOS/Source/queue.c" 1
 1187 063e BFF36F8F 		isb
 1188              	@ 0 "" 2
 1189              		.thumb
 1190              		.syntax unified
 1191 0642 84E7     		b	.L75
 1192              	.L72:
1574:FreeRTOS/Source/queue.c **** 				}
1575:FreeRTOS/Source/queue.c **** 				else
1576:FreeRTOS/Source/queue.c **** 				{
1577:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1578:FreeRTOS/Source/queue.c **** 				}
1579:FreeRTOS/Source/queue.c **** 			}
1580:FreeRTOS/Source/queue.c **** 			else
1581:FreeRTOS/Source/queue.c **** 			{
1582:FreeRTOS/Source/queue.c **** 				/* There was no timeout and the semaphore count was not 0, so
1583:FreeRTOS/Source/queue.c **** 				attempt to take the semaphore again. */
1584:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1193              		.loc 1 1584 0
 1194 0644 B869     		ldr	r0, [r7, #24]
 1195 0646 00F006FA 		bl	prvUnlockQueue
1585:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1196              		.loc 1 1585 0
 1197 064a FFF7FEFF 		bl	xTaskResumeAll
 1198 064e 7EE7     		b	.L75
 1199              	.L71:
1586:FreeRTOS/Source/queue.c **** 			}
1587:FreeRTOS/Source/queue.c **** 		}
1588:FreeRTOS/Source/queue.c **** 		else
ARM GAS  /tmp/ccdqkONZ.s 			page 54


1589:FreeRTOS/Source/queue.c **** 		{
1590:FreeRTOS/Source/queue.c **** 			/* Timed out. */
1591:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1200              		.loc 1 1591 0
 1201 0650 B869     		ldr	r0, [r7, #24]
 1202 0652 00F000FA 		bl	prvUnlockQueue
1592:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1203              		.loc 1 1592 0
 1204 0656 FFF7FEFF 		bl	xTaskResumeAll
1593:FreeRTOS/Source/queue.c **** 
1594:FreeRTOS/Source/queue.c **** 			/* If the semaphore count is 0 exit now as the timeout has
1595:FreeRTOS/Source/queue.c **** 			expired.  Otherwise return to attempt to take the semaphore that is
1596:FreeRTOS/Source/queue.c **** 			known to be available.  As semaphores are implemented by queues the
1597:FreeRTOS/Source/queue.c **** 			queue being empty is equivalent to the semaphore count being 0. */
1598:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1205              		.loc 1 1598 0
 1206 065a B869     		ldr	r0, [r7, #24]
 1207 065c 00F04DFA 		bl	prvIsQueueEmpty
 1208 0660 0346     		mov	r3, r0
 1209 0662 002B     		cmp	r3, #0
 1210 0664 3FF473AF 		beq	.L75
1599:FreeRTOS/Source/queue.c **** 			{
1600:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1601:FreeRTOS/Source/queue.c **** 				{
1602:FreeRTOS/Source/queue.c **** 					/* xInheritanceOccurred could only have be set if
1603:FreeRTOS/Source/queue.c **** 					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1604:FreeRTOS/Source/queue.c **** 					test the mutex type again to check it is actually a mutex. */
1605:FreeRTOS/Source/queue.c **** 					if( xInheritanceOccurred != pdFALSE )
1606:FreeRTOS/Source/queue.c **** 					{
1607:FreeRTOS/Source/queue.c **** 						taskENTER_CRITICAL();
1608:FreeRTOS/Source/queue.c **** 						{
1609:FreeRTOS/Source/queue.c **** 							UBaseType_t uxHighestWaitingPriority;
1610:FreeRTOS/Source/queue.c **** 
1611:FreeRTOS/Source/queue.c **** 							/* This task blocking on the mutex caused another
1612:FreeRTOS/Source/queue.c **** 							task to inherit this task's priority.  Now this task
1613:FreeRTOS/Source/queue.c **** 							has timed out the priority should be disinherited
1614:FreeRTOS/Source/queue.c **** 							again, but only as low as the next highest priority
1615:FreeRTOS/Source/queue.c **** 							task that is waiting for the same mutex. */
1616:FreeRTOS/Source/queue.c **** 							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
1617:FreeRTOS/Source/queue.c **** 							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPri
1618:FreeRTOS/Source/queue.c **** 						}
1619:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
1620:FreeRTOS/Source/queue.c **** 					}
1621:FreeRTOS/Source/queue.c **** 				}
1622:FreeRTOS/Source/queue.c **** 				#endif /* configUSE_MUTEXES */
1623:FreeRTOS/Source/queue.c **** 
1624:FreeRTOS/Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1625:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
 1211              		.loc 1 1625 0
 1212 0668 0023     		movs	r3, #0
 1213              	.L76:
1626:FreeRTOS/Source/queue.c **** 			}
1627:FreeRTOS/Source/queue.c **** 			else
1628:FreeRTOS/Source/queue.c **** 			{
1629:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1630:FreeRTOS/Source/queue.c **** 			}
1631:FreeRTOS/Source/queue.c **** 		}
ARM GAS  /tmp/ccdqkONZ.s 			page 55


1632:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
1633:FreeRTOS/Source/queue.c **** }
 1214              		.loc 1 1633 0 discriminator 3
 1215 066a 1846     		mov	r0, r3
 1216 066c 2037     		adds	r7, r7, #32
 1217              		.cfi_def_cfa_offset 8
 1218 066e BD46     		mov	sp, r7
 1219              		.cfi_def_cfa_register 13
 1220              		@ sp needed
 1221 0670 80BD     		pop	{r7, pc}
 1222              	.L78:
 1223 0672 00BF     		.align	2
 1224              	.L77:
 1225 0674 04ED00E0 		.word	-536810236
 1226              		.cfi_endproc
 1227              	.LFE12:
 1228              		.size	xQueueSemaphoreTake, .-xQueueSemaphoreTake
 1229              		.align	1
 1230              		.global	xQueuePeek
 1231              		.syntax unified
 1232              		.thumb
 1233              		.thumb_func
 1234              		.fpu softvfp
 1235              		.type	xQueuePeek, %function
 1236              	xQueuePeek:
 1237              	.LFB13:
1634:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1635:FreeRTOS/Source/queue.c **** 
1636:FreeRTOS/Source/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
1637:FreeRTOS/Source/queue.c **** {
 1238              		.loc 1 1637 0
 1239              		.cfi_startproc
 1240              		@ args = 0, pretend = 0, frame = 40
 1241              		@ frame_needed = 1, uses_anonymous_args = 0
 1242 0678 80B5     		push	{r7, lr}
 1243              		.cfi_def_cfa_offset 8
 1244              		.cfi_offset 7, -8
 1245              		.cfi_offset 14, -4
 1246 067a 8AB0     		sub	sp, sp, #40
 1247              		.cfi_def_cfa_offset 48
 1248 067c 00AF     		add	r7, sp, #0
 1249              		.cfi_def_cfa_register 7
 1250 067e F860     		str	r0, [r7, #12]
 1251 0680 B960     		str	r1, [r7, #8]
 1252 0682 7A60     		str	r2, [r7, #4]
1638:FreeRTOS/Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1253              		.loc 1 1638 0
 1254 0684 0023     		movs	r3, #0
 1255 0686 7B62     		str	r3, [r7, #36]
1639:FreeRTOS/Source/queue.c **** TimeOut_t xTimeOut;
1640:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1641:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1256              		.loc 1 1641 0
 1257 0688 FB68     		ldr	r3, [r7, #12]
 1258 068a 3B62     		str	r3, [r7, #32]
 1259              	.L91:
1642:FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccdqkONZ.s 			page 56


1643:FreeRTOS/Source/queue.c **** 	/* Check the pointer is not NULL. */
1644:FreeRTOS/Source/queue.c **** 	configASSERT( ( pxQueue ) );
1645:FreeRTOS/Source/queue.c **** 
1646:FreeRTOS/Source/queue.c **** 	/* The buffer into which data is received can only be NULL if the data size
1647:FreeRTOS/Source/queue.c **** 	is zero (so no data is copied into the buffer. */
1648:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) )
1649:FreeRTOS/Source/queue.c **** 
1650:FreeRTOS/Source/queue.c **** 	/* Cannot block if the scheduler is suspended. */
1651:FreeRTOS/Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1652:FreeRTOS/Source/queue.c **** 	{
1653:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1654:FreeRTOS/Source/queue.c **** 	}
1655:FreeRTOS/Source/queue.c **** 	#endif
1656:FreeRTOS/Source/queue.c **** 
1657:FreeRTOS/Source/queue.c **** 
1658:FreeRTOS/Source/queue.c **** 	/*lint -save -e904  This function relaxes the coding standard somewhat to
1659:FreeRTOS/Source/queue.c **** 	allow return statements within the function itself.  This is done in the
1660:FreeRTOS/Source/queue.c **** 	interest of execution time efficiency. */
1661:FreeRTOS/Source/queue.c **** 	for( ;; )
1662:FreeRTOS/Source/queue.c **** 	{
1663:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 1260              		.loc 1 1663 0
 1261 068c FFF7FEFF 		bl	vPortEnterCritical
 1262              	.LBB36:
1664:FreeRTOS/Source/queue.c **** 		{
1665:FreeRTOS/Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1263              		.loc 1 1665 0
 1264 0690 3B6A     		ldr	r3, [r7, #32]
 1265 0692 9B6B     		ldr	r3, [r3, #56]
 1266 0694 FB61     		str	r3, [r7, #28]
1666:FreeRTOS/Source/queue.c **** 
1667:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1668:FreeRTOS/Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1669:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1267              		.loc 1 1669 0
 1268 0696 FB69     		ldr	r3, [r7, #28]
 1269 0698 002B     		cmp	r3, #0
 1270 069a 21D0     		beq	.L80
1670:FreeRTOS/Source/queue.c **** 			{
1671:FreeRTOS/Source/queue.c **** 				/* Remember the read position so it can be reset after the data
1672:FreeRTOS/Source/queue.c **** 				is read from the queue as this function is only peeking the
1673:FreeRTOS/Source/queue.c **** 				data, not removing it. */
1674:FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 1271              		.loc 1 1674 0
 1272 069c 3B6A     		ldr	r3, [r7, #32]
 1273 069e DB68     		ldr	r3, [r3, #12]
 1274 06a0 BB61     		str	r3, [r7, #24]
1675:FreeRTOS/Source/queue.c **** 
1676:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1275              		.loc 1 1676 0
 1276 06a2 B968     		ldr	r1, [r7, #8]
 1277 06a4 386A     		ldr	r0, [r7, #32]
 1278 06a6 00F0B0F9 		bl	prvCopyDataFromQueue
1677:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK( pxQueue );
1678:FreeRTOS/Source/queue.c **** 
1679:FreeRTOS/Source/queue.c **** 				/* The data is not being removed, so reset the read pointer. */
1680:FreeRTOS/Source/queue.c **** 				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
ARM GAS  /tmp/ccdqkONZ.s 			page 57


 1279              		.loc 1 1680 0
 1280 06aa 3B6A     		ldr	r3, [r7, #32]
 1281 06ac BA69     		ldr	r2, [r7, #24]
 1282 06ae DA60     		str	r2, [r3, #12]
1681:FreeRTOS/Source/queue.c **** 
1682:FreeRTOS/Source/queue.c **** 				/* The data is being left in the queue, so see if there are
1683:FreeRTOS/Source/queue.c **** 				any other tasks waiting for the data. */
1684:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1283              		.loc 1 1684 0
 1284 06b0 3B6A     		ldr	r3, [r7, #32]
 1285 06b2 5B6A     		ldr	r3, [r3, #36]
 1286 06b4 002B     		cmp	r3, #0
 1287 06b6 0FD0     		beq	.L81
1685:FreeRTOS/Source/queue.c **** 				{
1686:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1288              		.loc 1 1686 0
 1289 06b8 3B6A     		ldr	r3, [r7, #32]
 1290 06ba 2433     		adds	r3, r3, #36
 1291 06bc 1846     		mov	r0, r3
 1292 06be FFF7FEFF 		bl	xTaskRemoveFromEventList
 1293 06c2 0346     		mov	r3, r0
 1294 06c4 002B     		cmp	r3, #0
 1295 06c6 07D0     		beq	.L81
1687:FreeRTOS/Source/queue.c **** 					{
1688:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than this task. */
1689:FreeRTOS/Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 1296              		.loc 1 1689 0
 1297 06c8 3C4B     		ldr	r3, .L93
 1298 06ca 4FF08052 		mov	r2, #268435456
 1299 06ce 1A60     		str	r2, [r3]
 1300              		.syntax unified
 1301              	@ 1689 "FreeRTOS/Source/queue.c" 1
 1302 06d0 BFF34F8F 		dsb
 1303              	@ 0 "" 2
 1304              	@ 1689 "FreeRTOS/Source/queue.c" 1
 1305 06d4 BFF36F8F 		isb
 1306              	@ 0 "" 2
 1307              		.thumb
 1308              		.syntax unified
 1309              	.L81:
1690:FreeRTOS/Source/queue.c **** 					}
1691:FreeRTOS/Source/queue.c **** 					else
1692:FreeRTOS/Source/queue.c **** 					{
1693:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1694:FreeRTOS/Source/queue.c **** 					}
1695:FreeRTOS/Source/queue.c **** 				}
1696:FreeRTOS/Source/queue.c **** 				else
1697:FreeRTOS/Source/queue.c **** 				{
1698:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1699:FreeRTOS/Source/queue.c **** 				}
1700:FreeRTOS/Source/queue.c **** 
1701:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 1310              		.loc 1 1701 0
 1311 06d8 FFF7FEFF 		bl	vPortExitCritical
1702:FreeRTOS/Source/queue.c **** 				return pdPASS;
 1312              		.loc 1 1702 0
 1313 06dc 0123     		movs	r3, #1
ARM GAS  /tmp/ccdqkONZ.s 			page 58


 1314 06de 69E0     		b	.L92
 1315              	.L80:
1703:FreeRTOS/Source/queue.c **** 			}
1704:FreeRTOS/Source/queue.c **** 			else
1705:FreeRTOS/Source/queue.c **** 			{
1706:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1316              		.loc 1 1706 0
 1317 06e0 7B68     		ldr	r3, [r7, #4]
 1318 06e2 002B     		cmp	r3, #0
 1319 06e4 03D1     		bne	.L83
1707:FreeRTOS/Source/queue.c **** 				{
1708:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1709:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
1710:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 1320              		.loc 1 1710 0
 1321 06e6 FFF7FEFF 		bl	vPortExitCritical
1711:FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK_FAILED( pxQueue );
1712:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 1322              		.loc 1 1712 0
 1323 06ea 0023     		movs	r3, #0
 1324 06ec 62E0     		b	.L92
 1325              	.L83:
1713:FreeRTOS/Source/queue.c **** 				}
1714:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1326              		.loc 1 1714 0
 1327 06ee 7B6A     		ldr	r3, [r7, #36]
 1328 06f0 002B     		cmp	r3, #0
 1329 06f2 06D1     		bne	.L84
1715:FreeRTOS/Source/queue.c **** 				{
1716:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
1717:FreeRTOS/Source/queue.c **** 					configure the timeout structure ready to enter the blocked
1718:FreeRTOS/Source/queue.c **** 					state. */
1719:FreeRTOS/Source/queue.c **** 					vTaskInternalSetTimeOutState( &xTimeOut );
 1330              		.loc 1 1719 0
 1331 06f4 07F11003 		add	r3, r7, #16
 1332 06f8 1846     		mov	r0, r3
 1333 06fa FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1720:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1334              		.loc 1 1720 0
 1335 06fe 0123     		movs	r3, #1
 1336 0700 7B62     		str	r3, [r7, #36]
 1337              	.L84:
 1338              	.LBE36:
1721:FreeRTOS/Source/queue.c **** 				}
1722:FreeRTOS/Source/queue.c **** 				else
1723:FreeRTOS/Source/queue.c **** 				{
1724:FreeRTOS/Source/queue.c **** 					/* Entry time was already set. */
1725:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1726:FreeRTOS/Source/queue.c **** 				}
1727:FreeRTOS/Source/queue.c **** 			}
1728:FreeRTOS/Source/queue.c **** 		}
1729:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 1339              		.loc 1 1729 0
 1340 0702 FFF7FEFF 		bl	vPortExitCritical
1730:FreeRTOS/Source/queue.c **** 
1731:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1732:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
ARM GAS  /tmp/ccdqkONZ.s 			page 59


1733:FreeRTOS/Source/queue.c **** 
1734:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 1341              		.loc 1 1734 0
 1342 0706 FFF7FEFF 		bl	vTaskSuspendAll
1735:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 1343              		.loc 1 1735 0
 1344 070a FFF7FEFF 		bl	vPortEnterCritical
 1345 070e 3B6A     		ldr	r3, [r7, #32]
 1346 0710 93F84430 		ldrb	r3, [r3, #68]
 1347 0714 5BB2     		sxtb	r3, r3
 1348 0716 B3F1FF3F 		cmp	r3, #-1
 1349 071a 03D1     		bne	.L85
 1350              		.loc 1 1735 0 is_stmt 0 discriminator 1
 1351 071c 3B6A     		ldr	r3, [r7, #32]
 1352 071e 0022     		movs	r2, #0
 1353 0720 83F84420 		strb	r2, [r3, #68]
 1354              	.L85:
 1355              		.loc 1 1735 0 discriminator 3
 1356 0724 3B6A     		ldr	r3, [r7, #32]
 1357 0726 93F84530 		ldrb	r3, [r3, #69]
 1358 072a 5BB2     		sxtb	r3, r3
 1359 072c B3F1FF3F 		cmp	r3, #-1
 1360 0730 03D1     		bne	.L86
 1361              		.loc 1 1735 0 discriminator 4
 1362 0732 3B6A     		ldr	r3, [r7, #32]
 1363 0734 0022     		movs	r2, #0
 1364 0736 83F84520 		strb	r2, [r3, #69]
 1365              	.L86:
 1366              		.loc 1 1735 0 discriminator 6
 1367 073a FFF7FEFF 		bl	vPortExitCritical
1736:FreeRTOS/Source/queue.c **** 
1737:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1738:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1368              		.loc 1 1738 0 is_stmt 1 discriminator 6
 1369 073e 3A1D     		adds	r2, r7, #4
 1370 0740 07F11003 		add	r3, r7, #16
 1371 0744 1146     		mov	r1, r2
 1372 0746 1846     		mov	r0, r3
 1373 0748 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1374 074c 0346     		mov	r3, r0
 1375 074e 002B     		cmp	r3, #0
 1376 0750 23D1     		bne	.L87
1739:FreeRTOS/Source/queue.c **** 		{
1740:FreeRTOS/Source/queue.c **** 			/* Timeout has not expired yet, check to see if there is data in the
1741:FreeRTOS/Source/queue.c **** 			queue now, and if not enter the Blocked state to wait for data. */
1742:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1377              		.loc 1 1742 0
 1378 0752 386A     		ldr	r0, [r7, #32]
 1379 0754 00F0D1F9 		bl	prvIsQueueEmpty
 1380 0758 0346     		mov	r3, r0
 1381 075a 002B     		cmp	r3, #0
 1382 075c 17D0     		beq	.L88
1743:FreeRTOS/Source/queue.c **** 			{
1744:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1745:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1383              		.loc 1 1745 0
 1384 075e 3B6A     		ldr	r3, [r7, #32]
ARM GAS  /tmp/ccdqkONZ.s 			page 60


 1385 0760 2433     		adds	r3, r3, #36
 1386 0762 7A68     		ldr	r2, [r7, #4]
 1387 0764 1146     		mov	r1, r2
 1388 0766 1846     		mov	r0, r3
 1389 0768 FFF7FEFF 		bl	vTaskPlaceOnEventList
1746:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1390              		.loc 1 1746 0
 1391 076c 386A     		ldr	r0, [r7, #32]
 1392 076e 00F072F9 		bl	prvUnlockQueue
1747:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1393              		.loc 1 1747 0
 1394 0772 FFF7FEFF 		bl	xTaskResumeAll
 1395 0776 0346     		mov	r3, r0
 1396 0778 002B     		cmp	r3, #0
 1397 077a 87D1     		bne	.L91
1748:FreeRTOS/Source/queue.c **** 				{
1749:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 1398              		.loc 1 1749 0
 1399 077c 0F4B     		ldr	r3, .L93
 1400 077e 4FF08052 		mov	r2, #268435456
 1401 0782 1A60     		str	r2, [r3]
 1402              		.syntax unified
 1403              	@ 1749 "FreeRTOS/Source/queue.c" 1
 1404 0784 BFF34F8F 		dsb
 1405              	@ 0 "" 2
 1406              	@ 1749 "FreeRTOS/Source/queue.c" 1
 1407 0788 BFF36F8F 		isb
 1408              	@ 0 "" 2
 1409              		.thumb
 1410              		.syntax unified
 1411 078c 7EE7     		b	.L91
 1412              	.L88:
1750:FreeRTOS/Source/queue.c **** 				}
1751:FreeRTOS/Source/queue.c **** 				else
1752:FreeRTOS/Source/queue.c **** 				{
1753:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1754:FreeRTOS/Source/queue.c **** 				}
1755:FreeRTOS/Source/queue.c **** 			}
1756:FreeRTOS/Source/queue.c **** 			else
1757:FreeRTOS/Source/queue.c **** 			{
1758:FreeRTOS/Source/queue.c **** 				/* There is data in the queue now, so don't enter the blocked
1759:FreeRTOS/Source/queue.c **** 				state, instead return to try and obtain the data. */
1760:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1413              		.loc 1 1760 0
 1414 078e 386A     		ldr	r0, [r7, #32]
 1415 0790 00F061F9 		bl	prvUnlockQueue
1761:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 1416              		.loc 1 1761 0
 1417 0794 FFF7FEFF 		bl	xTaskResumeAll
 1418 0798 78E7     		b	.L91
 1419              	.L87:
1762:FreeRTOS/Source/queue.c **** 			}
1763:FreeRTOS/Source/queue.c **** 		}
1764:FreeRTOS/Source/queue.c **** 		else
1765:FreeRTOS/Source/queue.c **** 		{
1766:FreeRTOS/Source/queue.c **** 			/* The timeout has expired.  If there is still no data in the queue
1767:FreeRTOS/Source/queue.c **** 			exit, otherwise go back and try to read the data again. */
ARM GAS  /tmp/ccdqkONZ.s 			page 61


1768:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1420              		.loc 1 1768 0
 1421 079a 386A     		ldr	r0, [r7, #32]
 1422 079c 00F05BF9 		bl	prvUnlockQueue
1769:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 1423              		.loc 1 1769 0
 1424 07a0 FFF7FEFF 		bl	xTaskResumeAll
1770:FreeRTOS/Source/queue.c **** 
1771:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1425              		.loc 1 1771 0
 1426 07a4 386A     		ldr	r0, [r7, #32]
 1427 07a6 00F0A8F9 		bl	prvIsQueueEmpty
 1428 07aa 0346     		mov	r3, r0
 1429 07ac 002B     		cmp	r3, #0
 1430 07ae 3FF46DAF 		beq	.L91
1772:FreeRTOS/Source/queue.c **** 			{
1773:FreeRTOS/Source/queue.c **** 				traceQUEUE_PEEK_FAILED( pxQueue );
1774:FreeRTOS/Source/queue.c **** 				return errQUEUE_EMPTY;
 1431              		.loc 1 1774 0
 1432 07b2 0023     		movs	r3, #0
 1433              	.L92:
1775:FreeRTOS/Source/queue.c **** 			}
1776:FreeRTOS/Source/queue.c **** 			else
1777:FreeRTOS/Source/queue.c **** 			{
1778:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1779:FreeRTOS/Source/queue.c **** 			}
1780:FreeRTOS/Source/queue.c **** 		}
1781:FreeRTOS/Source/queue.c **** 	} /*lint -restore */
1782:FreeRTOS/Source/queue.c **** }
 1434              		.loc 1 1782 0 discriminator 3
 1435 07b4 1846     		mov	r0, r3
 1436 07b6 2837     		adds	r7, r7, #40
 1437              		.cfi_def_cfa_offset 8
 1438 07b8 BD46     		mov	sp, r7
 1439              		.cfi_def_cfa_register 13
 1440              		@ sp needed
 1441 07ba 80BD     		pop	{r7, pc}
 1442              	.L94:
 1443              		.align	2
 1444              	.L93:
 1445 07bc 04ED00E0 		.word	-536810236
 1446              		.cfi_endproc
 1447              	.LFE13:
 1448              		.size	xQueuePeek, .-xQueuePeek
 1449              		.align	1
 1450              		.global	xQueueReceiveFromISR
 1451              		.syntax unified
 1452              		.thumb
 1453              		.thumb_func
 1454              		.fpu softvfp
 1455              		.type	xQueueReceiveFromISR, %function
 1456              	xQueueReceiveFromISR:
 1457              	.LFB14:
1783:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1784:FreeRTOS/Source/queue.c **** 
1785:FreeRTOS/Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1786:FreeRTOS/Source/queue.c **** {
ARM GAS  /tmp/ccdqkONZ.s 			page 62


 1458              		.loc 1 1786 0
 1459              		.cfi_startproc
 1460              		@ args = 0, pretend = 0, frame = 48
 1461              		@ frame_needed = 1, uses_anonymous_args = 0
 1462 07c0 80B5     		push	{r7, lr}
 1463              		.cfi_def_cfa_offset 8
 1464              		.cfi_offset 7, -8
 1465              		.cfi_offset 14, -4
 1466 07c2 8CB0     		sub	sp, sp, #48
 1467              		.cfi_def_cfa_offset 56
 1468 07c4 00AF     		add	r7, sp, #0
 1469              		.cfi_def_cfa_register 7
 1470 07c6 F860     		str	r0, [r7, #12]
 1471 07c8 B960     		str	r1, [r7, #8]
 1472 07ca 7A60     		str	r2, [r7, #4]
1787:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1788:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1789:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1473              		.loc 1 1789 0
 1474 07cc FB68     		ldr	r3, [r7, #12]
 1475 07ce BB62     		str	r3, [r7, #40]
 1476              	.LBB37:
 1477              	.LBB38:
 213:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 1478              		.loc 2 213 0
 1479              		.syntax unified
 1480              	@ 213 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1481 07d0 EFF31182 			mrs r2, basepri											
 1482 07d4 4FF0BF03 		mov r3, #191												
 1483 07d8 83F31188 		msr basepri, r3											
 1484 07dc BFF36F8F 		isb														
 1485 07e0 BFF34F8F 		dsb														
 1486              	
 1487              	@ 0 "" 2
 1488              		.thumb
 1489              		.syntax unified
 1490 07e4 BA61     		str	r2, [r7, #24]
 1491 07e6 7B61     		str	r3, [r7, #20]
 225:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
 1492              		.loc 2 225 0
 1493 07e8 BB69     		ldr	r3, [r7, #24]
 1494              	.LBE38:
 1495              	.LBE37:
1790:FreeRTOS/Source/queue.c **** 
1791:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1792:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1793:FreeRTOS/Source/queue.c **** 
1794:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1795:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1796:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1797:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1798:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1799:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1800:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1801:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1802:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1803:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
ARM GAS  /tmp/ccdqkONZ.s 			page 63


1804:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1805:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1806:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1807:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1808:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1809:FreeRTOS/Source/queue.c **** 
1810:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1496              		.loc 1 1810 0
 1497 07ea 7B62     		str	r3, [r7, #36]
 1498              	.LBB39:
1811:FreeRTOS/Source/queue.c **** 	{
1812:FreeRTOS/Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1499              		.loc 1 1812 0
 1500 07ec BB6A     		ldr	r3, [r7, #40]
 1501 07ee 9B6B     		ldr	r3, [r3, #56]
 1502 07f0 3B62     		str	r3, [r7, #32]
1813:FreeRTOS/Source/queue.c **** 
1814:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1815:FreeRTOS/Source/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1503              		.loc 1 1815 0
 1504 07f2 3B6A     		ldr	r3, [r7, #32]
 1505 07f4 002B     		cmp	r3, #0
 1506 07f6 2DD0     		beq	.L97
 1507              	.LBB40:
1816:FreeRTOS/Source/queue.c **** 		{
1817:FreeRTOS/Source/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
 1508              		.loc 1 1817 0
 1509 07f8 BB6A     		ldr	r3, [r7, #40]
 1510 07fa 93F84430 		ldrb	r3, [r3, #68]
 1511 07fe FB77     		strb	r3, [r7, #31]
1818:FreeRTOS/Source/queue.c **** 
1819:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1820:FreeRTOS/Source/queue.c **** 
1821:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1512              		.loc 1 1821 0
 1513 0800 B968     		ldr	r1, [r7, #8]
 1514 0802 B86A     		ldr	r0, [r7, #40]
 1515 0804 00F001F9 		bl	prvCopyDataFromQueue
1822:FreeRTOS/Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1516              		.loc 1 1822 0
 1517 0808 3B6A     		ldr	r3, [r7, #32]
 1518 080a 5A1E     		subs	r2, r3, #1
 1519 080c BB6A     		ldr	r3, [r7, #40]
 1520 080e 9A63     		str	r2, [r3, #56]
1823:FreeRTOS/Source/queue.c **** 
1824:FreeRTOS/Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1825:FreeRTOS/Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1826:FreeRTOS/Source/queue.c **** 			will know that an ISR has removed data while the queue was
1827:FreeRTOS/Source/queue.c **** 			locked. */
1828:FreeRTOS/Source/queue.c **** 			if( cRxLock == queueUNLOCKED )
 1521              		.loc 1 1828 0
 1522 0810 97F91F30 		ldrsb	r3, [r7, #31]
 1523 0814 B3F1FF3F 		cmp	r3, #-1
 1524 0818 12D1     		bne	.L98
1829:FreeRTOS/Source/queue.c **** 			{
1830:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1525              		.loc 1 1830 0
ARM GAS  /tmp/ccdqkONZ.s 			page 64


 1526 081a BB6A     		ldr	r3, [r7, #40]
 1527 081c 1B69     		ldr	r3, [r3, #16]
 1528 081e 002B     		cmp	r3, #0
 1529 0820 15D0     		beq	.L99
1831:FreeRTOS/Source/queue.c **** 				{
1832:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1530              		.loc 1 1832 0
 1531 0822 BB6A     		ldr	r3, [r7, #40]
 1532 0824 1033     		adds	r3, r3, #16
 1533 0826 1846     		mov	r0, r3
 1534 0828 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1535 082c 0346     		mov	r3, r0
 1536 082e 002B     		cmp	r3, #0
 1537 0830 0DD0     		beq	.L99
1833:FreeRTOS/Source/queue.c **** 					{
1834:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1835:FreeRTOS/Source/queue.c **** 						force a context switch. */
1836:FreeRTOS/Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1538              		.loc 1 1836 0
 1539 0832 7B68     		ldr	r3, [r7, #4]
 1540 0834 002B     		cmp	r3, #0
 1541 0836 0AD0     		beq	.L99
1837:FreeRTOS/Source/queue.c **** 						{
1838:FreeRTOS/Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1542              		.loc 1 1838 0
 1543 0838 7B68     		ldr	r3, [r7, #4]
 1544 083a 0122     		movs	r2, #1
 1545 083c 1A60     		str	r2, [r3]
 1546 083e 06E0     		b	.L99
 1547              	.L98:
1839:FreeRTOS/Source/queue.c **** 						}
1840:FreeRTOS/Source/queue.c **** 						else
1841:FreeRTOS/Source/queue.c **** 						{
1842:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1843:FreeRTOS/Source/queue.c **** 						}
1844:FreeRTOS/Source/queue.c **** 					}
1845:FreeRTOS/Source/queue.c **** 					else
1846:FreeRTOS/Source/queue.c **** 					{
1847:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1848:FreeRTOS/Source/queue.c **** 					}
1849:FreeRTOS/Source/queue.c **** 				}
1850:FreeRTOS/Source/queue.c **** 				else
1851:FreeRTOS/Source/queue.c **** 				{
1852:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1853:FreeRTOS/Source/queue.c **** 				}
1854:FreeRTOS/Source/queue.c **** 			}
1855:FreeRTOS/Source/queue.c **** 			else
1856:FreeRTOS/Source/queue.c **** 			{
1857:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1858:FreeRTOS/Source/queue.c **** 				knows that data was removed while it was locked. */
1859:FreeRTOS/Source/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 1548              		.loc 1 1859 0
 1549 0840 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 1550 0842 0133     		adds	r3, r3, #1
 1551 0844 DBB2     		uxtb	r3, r3
 1552 0846 5AB2     		sxtb	r2, r3
 1553 0848 BB6A     		ldr	r3, [r7, #40]
ARM GAS  /tmp/ccdqkONZ.s 			page 65


 1554 084a 83F84420 		strb	r2, [r3, #68]
 1555              	.L99:
1860:FreeRTOS/Source/queue.c **** 			}
1861:FreeRTOS/Source/queue.c **** 
1862:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 1556              		.loc 1 1862 0
 1557 084e 0123     		movs	r3, #1
 1558 0850 FB62     		str	r3, [r7, #44]
 1559              	.LBE40:
 1560 0852 01E0     		b	.L100
 1561              	.L97:
1863:FreeRTOS/Source/queue.c **** 		}
1864:FreeRTOS/Source/queue.c **** 		else
1865:FreeRTOS/Source/queue.c **** 		{
1866:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 1562              		.loc 1 1866 0
 1563 0854 0023     		movs	r3, #0
 1564 0856 FB62     		str	r3, [r7, #44]
 1565              	.L100:
 1566 0858 7B6A     		ldr	r3, [r7, #36]
 1567 085a 3B61     		str	r3, [r7, #16]
 1568              	.LBE39:
 1569              	.LBB41:
 1570              	.LBB42:
 1571              		.loc 2 231 0
 1572 085c 3B69     		ldr	r3, [r7, #16]
 1573              		.syntax unified
 1574              	@ 231 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1575 085e 83F31188 			msr basepri, r3	
 1576              	@ 0 "" 2
 1577              		.thumb
 1578              		.syntax unified
 1579              	.LBE42:
 1580              	.LBE41:
1867:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1868:FreeRTOS/Source/queue.c **** 		}
1869:FreeRTOS/Source/queue.c **** 	}
1870:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1871:FreeRTOS/Source/queue.c **** 
1872:FreeRTOS/Source/queue.c **** 	return xReturn;
 1581              		.loc 1 1872 0
 1582 0862 FB6A     		ldr	r3, [r7, #44]
1873:FreeRTOS/Source/queue.c **** }
 1583              		.loc 1 1873 0
 1584 0864 1846     		mov	r0, r3
 1585 0866 3037     		adds	r7, r7, #48
 1586              		.cfi_def_cfa_offset 8
 1587 0868 BD46     		mov	sp, r7
 1588              		.cfi_def_cfa_register 13
 1589              		@ sp needed
 1590 086a 80BD     		pop	{r7, pc}
 1591              		.cfi_endproc
 1592              	.LFE14:
 1593              		.size	xQueueReceiveFromISR, .-xQueueReceiveFromISR
 1594              		.align	1
 1595              		.global	xQueuePeekFromISR
 1596              		.syntax unified
ARM GAS  /tmp/ccdqkONZ.s 			page 66


 1597              		.thumb
 1598              		.thumb_func
 1599              		.fpu softvfp
 1600              		.type	xQueuePeekFromISR, %function
 1601              	xQueuePeekFromISR:
 1602              	.LFB15:
1874:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1875:FreeRTOS/Source/queue.c **** 
1876:FreeRTOS/Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1877:FreeRTOS/Source/queue.c **** {
 1603              		.loc 1 1877 0
 1604              		.cfi_startproc
 1605              		@ args = 0, pretend = 0, frame = 40
 1606              		@ frame_needed = 1, uses_anonymous_args = 0
 1607 086c 80B5     		push	{r7, lr}
 1608              		.cfi_def_cfa_offset 8
 1609              		.cfi_offset 7, -8
 1610              		.cfi_offset 14, -4
 1611 086e 8AB0     		sub	sp, sp, #40
 1612              		.cfi_def_cfa_offset 48
 1613 0870 00AF     		add	r7, sp, #0
 1614              		.cfi_def_cfa_register 7
 1615 0872 7860     		str	r0, [r7, #4]
 1616 0874 3960     		str	r1, [r7]
1878:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
1879:FreeRTOS/Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1880:FreeRTOS/Source/queue.c **** int8_t *pcOriginalReadPosition;
1881:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1617              		.loc 1 1881 0
 1618 0876 7B68     		ldr	r3, [r7, #4]
 1619 0878 3B62     		str	r3, [r7, #32]
 1620              	.LBB43:
 1621              	.LBB44:
 213:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 1622              		.loc 2 213 0
 1623              		.syntax unified
 1624              	@ 213 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1625 087a EFF31182 			mrs r2, basepri											
 1626 087e 4FF0BF03 		mov r3, #191												
 1627 0882 83F31188 		msr basepri, r3											
 1628 0886 BFF36F8F 		isb														
 1629 088a BFF34F8F 		dsb														
 1630              	
 1631              	@ 0 "" 2
 1632              		.thumb
 1633              		.syntax unified
 1634 088e 7A61     		str	r2, [r7, #20]
 1635 0890 3B61     		str	r3, [r7, #16]
 225:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
 1636              		.loc 2 225 0
 1637 0892 7B69     		ldr	r3, [r7, #20]
 1638              	.LBE44:
 1639              	.LBE43:
1882:FreeRTOS/Source/queue.c **** 
1883:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1884:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1885:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
ARM GAS  /tmp/ccdqkONZ.s 			page 67


1886:FreeRTOS/Source/queue.c **** 
1887:FreeRTOS/Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1888:FreeRTOS/Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1889:FreeRTOS/Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1890:FreeRTOS/Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1891:FreeRTOS/Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1892:FreeRTOS/Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1893:FreeRTOS/Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1894:FreeRTOS/Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1895:FreeRTOS/Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1896:FreeRTOS/Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1897:FreeRTOS/Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1898:FreeRTOS/Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1899:FreeRTOS/Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1900:FreeRTOS/Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1901:FreeRTOS/Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1902:FreeRTOS/Source/queue.c **** 
1903:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1640              		.loc 1 1903 0
 1641 0894 FB61     		str	r3, [r7, #28]
1904:FreeRTOS/Source/queue.c **** 	{
1905:FreeRTOS/Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1906:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1642              		.loc 1 1906 0
 1643 0896 3B6A     		ldr	r3, [r7, #32]
 1644 0898 9B6B     		ldr	r3, [r3, #56]
 1645 089a 002B     		cmp	r3, #0
 1646 089c 0CD0     		beq	.L104
1907:FreeRTOS/Source/queue.c **** 		{
1908:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1909:FreeRTOS/Source/queue.c **** 
1910:FreeRTOS/Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1911:FreeRTOS/Source/queue.c **** 			actually being removed from the queue. */
1912:FreeRTOS/Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 1647              		.loc 1 1912 0
 1648 089e 3B6A     		ldr	r3, [r7, #32]
 1649 08a0 DB68     		ldr	r3, [r3, #12]
 1650 08a2 BB61     		str	r3, [r7, #24]
1913:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1651              		.loc 1 1913 0
 1652 08a4 3968     		ldr	r1, [r7]
 1653 08a6 386A     		ldr	r0, [r7, #32]
 1654 08a8 00F0AFF8 		bl	prvCopyDataFromQueue
1914:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 1655              		.loc 1 1914 0
 1656 08ac 3B6A     		ldr	r3, [r7, #32]
 1657 08ae BA69     		ldr	r2, [r7, #24]
 1658 08b0 DA60     		str	r2, [r3, #12]
1915:FreeRTOS/Source/queue.c **** 
1916:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 1659              		.loc 1 1916 0
 1660 08b2 0123     		movs	r3, #1
 1661 08b4 7B62     		str	r3, [r7, #36]
 1662 08b6 01E0     		b	.L105
 1663              	.L104:
1917:FreeRTOS/Source/queue.c **** 		}
1918:FreeRTOS/Source/queue.c **** 		else
ARM GAS  /tmp/ccdqkONZ.s 			page 68


1919:FreeRTOS/Source/queue.c **** 		{
1920:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 1664              		.loc 1 1920 0
 1665 08b8 0023     		movs	r3, #0
 1666 08ba 7B62     		str	r3, [r7, #36]
 1667              	.L105:
 1668 08bc FB69     		ldr	r3, [r7, #28]
 1669 08be FB60     		str	r3, [r7, #12]
 1670              	.LBB45:
 1671              	.LBB46:
 1672              		.loc 2 231 0
 1673 08c0 FB68     		ldr	r3, [r7, #12]
 1674              		.syntax unified
 1675              	@ 231 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1676 08c2 83F31188 			msr basepri, r3	
 1677              	@ 0 "" 2
 1678              		.thumb
 1679              		.syntax unified
 1680              	.LBE46:
 1681              	.LBE45:
1921:FreeRTOS/Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1922:FreeRTOS/Source/queue.c **** 		}
1923:FreeRTOS/Source/queue.c **** 	}
1924:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1925:FreeRTOS/Source/queue.c **** 
1926:FreeRTOS/Source/queue.c **** 	return xReturn;
 1682              		.loc 1 1926 0
 1683 08c6 7B6A     		ldr	r3, [r7, #36]
1927:FreeRTOS/Source/queue.c **** }
 1684              		.loc 1 1927 0
 1685 08c8 1846     		mov	r0, r3
 1686 08ca 2837     		adds	r7, r7, #40
 1687              		.cfi_def_cfa_offset 8
 1688 08cc BD46     		mov	sp, r7
 1689              		.cfi_def_cfa_register 13
 1690              		@ sp needed
 1691 08ce 80BD     		pop	{r7, pc}
 1692              		.cfi_endproc
 1693              	.LFE15:
 1694              		.size	xQueuePeekFromISR, .-xQueuePeekFromISR
 1695              		.align	1
 1696              		.global	uxQueueMessagesWaiting
 1697              		.syntax unified
 1698              		.thumb
 1699              		.thumb_func
 1700              		.fpu softvfp
 1701              		.type	uxQueueMessagesWaiting, %function
 1702              	uxQueueMessagesWaiting:
 1703              	.LFB16:
1928:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1929:FreeRTOS/Source/queue.c **** 
1930:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1931:FreeRTOS/Source/queue.c **** {
 1704              		.loc 1 1931 0
 1705              		.cfi_startproc
 1706              		@ args = 0, pretend = 0, frame = 16
 1707              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  /tmp/ccdqkONZ.s 			page 69


 1708 08d0 80B5     		push	{r7, lr}
 1709              		.cfi_def_cfa_offset 8
 1710              		.cfi_offset 7, -8
 1711              		.cfi_offset 14, -4
 1712 08d2 84B0     		sub	sp, sp, #16
 1713              		.cfi_def_cfa_offset 24
 1714 08d4 00AF     		add	r7, sp, #0
 1715              		.cfi_def_cfa_register 7
 1716 08d6 7860     		str	r0, [r7, #4]
1932:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1933:FreeRTOS/Source/queue.c **** 
1934:FreeRTOS/Source/queue.c **** 	configASSERT( xQueue );
1935:FreeRTOS/Source/queue.c **** 
1936:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1717              		.loc 1 1936 0
 1718 08d8 FFF7FEFF 		bl	vPortEnterCritical
1937:FreeRTOS/Source/queue.c **** 	{
1938:FreeRTOS/Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1719              		.loc 1 1938 0
 1720 08dc 7B68     		ldr	r3, [r7, #4]
 1721 08de 9B6B     		ldr	r3, [r3, #56]
 1722 08e0 FB60     		str	r3, [r7, #12]
1939:FreeRTOS/Source/queue.c **** 	}
1940:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1723              		.loc 1 1940 0
 1724 08e2 FFF7FEFF 		bl	vPortExitCritical
1941:FreeRTOS/Source/queue.c **** 
1942:FreeRTOS/Source/queue.c **** 	return uxReturn;
 1725              		.loc 1 1942 0
 1726 08e6 FB68     		ldr	r3, [r7, #12]
1943:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1727              		.loc 1 1943 0
 1728 08e8 1846     		mov	r0, r3
 1729 08ea 1037     		adds	r7, r7, #16
 1730              		.cfi_def_cfa_offset 8
 1731 08ec BD46     		mov	sp, r7
 1732              		.cfi_def_cfa_register 13
 1733              		@ sp needed
 1734 08ee 80BD     		pop	{r7, pc}
 1735              		.cfi_endproc
 1736              	.LFE16:
 1737              		.size	uxQueueMessagesWaiting, .-uxQueueMessagesWaiting
 1738              		.align	1
 1739              		.global	uxQueueSpacesAvailable
 1740              		.syntax unified
 1741              		.thumb
 1742              		.thumb_func
 1743              		.fpu softvfp
 1744              		.type	uxQueueSpacesAvailable, %function
 1745              	uxQueueSpacesAvailable:
 1746              	.LFB17:
1944:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1945:FreeRTOS/Source/queue.c **** 
1946:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1947:FreeRTOS/Source/queue.c **** {
 1747              		.loc 1 1947 0
 1748              		.cfi_startproc
ARM GAS  /tmp/ccdqkONZ.s 			page 70


 1749              		@ args = 0, pretend = 0, frame = 16
 1750              		@ frame_needed = 1, uses_anonymous_args = 0
 1751 08f0 80B5     		push	{r7, lr}
 1752              		.cfi_def_cfa_offset 8
 1753              		.cfi_offset 7, -8
 1754              		.cfi_offset 14, -4
 1755 08f2 84B0     		sub	sp, sp, #16
 1756              		.cfi_def_cfa_offset 24
 1757 08f4 00AF     		add	r7, sp, #0
 1758              		.cfi_def_cfa_register 7
 1759 08f6 7860     		str	r0, [r7, #4]
1948:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1949:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1760              		.loc 1 1949 0
 1761 08f8 7B68     		ldr	r3, [r7, #4]
 1762 08fa FB60     		str	r3, [r7, #12]
1950:FreeRTOS/Source/queue.c **** 
1951:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1952:FreeRTOS/Source/queue.c **** 
1953:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1763              		.loc 1 1953 0
 1764 08fc FFF7FEFF 		bl	vPortEnterCritical
1954:FreeRTOS/Source/queue.c **** 	{
1955:FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1765              		.loc 1 1955 0
 1766 0900 FB68     		ldr	r3, [r7, #12]
 1767 0902 DA6B     		ldr	r2, [r3, #60]
 1768 0904 FB68     		ldr	r3, [r7, #12]
 1769 0906 9B6B     		ldr	r3, [r3, #56]
 1770 0908 D31A     		subs	r3, r2, r3
 1771 090a BB60     		str	r3, [r7, #8]
1956:FreeRTOS/Source/queue.c **** 	}
1957:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1772              		.loc 1 1957 0
 1773 090c FFF7FEFF 		bl	vPortExitCritical
1958:FreeRTOS/Source/queue.c **** 
1959:FreeRTOS/Source/queue.c **** 	return uxReturn;
 1774              		.loc 1 1959 0
 1775 0910 BB68     		ldr	r3, [r7, #8]
1960:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1776              		.loc 1 1960 0
 1777 0912 1846     		mov	r0, r3
 1778 0914 1037     		adds	r7, r7, #16
 1779              		.cfi_def_cfa_offset 8
 1780 0916 BD46     		mov	sp, r7
 1781              		.cfi_def_cfa_register 13
 1782              		@ sp needed
 1783 0918 80BD     		pop	{r7, pc}
 1784              		.cfi_endproc
 1785              	.LFE17:
 1786              		.size	uxQueueSpacesAvailable, .-uxQueueSpacesAvailable
 1787              		.align	1
 1788              		.global	uxQueueMessagesWaitingFromISR
 1789              		.syntax unified
 1790              		.thumb
 1791              		.thumb_func
 1792              		.fpu softvfp
ARM GAS  /tmp/ccdqkONZ.s 			page 71


 1793              		.type	uxQueueMessagesWaitingFromISR, %function
 1794              	uxQueueMessagesWaitingFromISR:
 1795              	.LFB18:
1961:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1962:FreeRTOS/Source/queue.c **** 
1963:FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1964:FreeRTOS/Source/queue.c **** {
 1796              		.loc 1 1964 0
 1797              		.cfi_startproc
 1798              		@ args = 0, pretend = 0, frame = 16
 1799              		@ frame_needed = 1, uses_anonymous_args = 0
 1800              		@ link register save eliminated.
 1801 091a 80B4     		push	{r7}
 1802              		.cfi_def_cfa_offset 4
 1803              		.cfi_offset 7, -4
 1804 091c 85B0     		sub	sp, sp, #20
 1805              		.cfi_def_cfa_offset 24
 1806 091e 00AF     		add	r7, sp, #0
 1807              		.cfi_def_cfa_register 7
 1808 0920 7860     		str	r0, [r7, #4]
1965:FreeRTOS/Source/queue.c **** UBaseType_t uxReturn;
1966:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1809              		.loc 1 1966 0
 1810 0922 7B68     		ldr	r3, [r7, #4]
 1811 0924 FB60     		str	r3, [r7, #12]
1967:FreeRTOS/Source/queue.c **** 
1968:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1969:FreeRTOS/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 1812              		.loc 1 1969 0
 1813 0926 FB68     		ldr	r3, [r7, #12]
 1814 0928 9B6B     		ldr	r3, [r3, #56]
 1815 092a BB60     		str	r3, [r7, #8]
1970:FreeRTOS/Source/queue.c **** 
1971:FreeRTOS/Source/queue.c **** 	return uxReturn;
 1816              		.loc 1 1971 0
 1817 092c BB68     		ldr	r3, [r7, #8]
1972:FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1818              		.loc 1 1972 0
 1819 092e 1846     		mov	r0, r3
 1820 0930 1437     		adds	r7, r7, #20
 1821              		.cfi_def_cfa_offset 4
 1822 0932 BD46     		mov	sp, r7
 1823              		.cfi_def_cfa_register 13
 1824              		@ sp needed
 1825 0934 80BC     		pop	{r7}
 1826              		.cfi_restore 7
 1827              		.cfi_def_cfa_offset 0
 1828 0936 7047     		bx	lr
 1829              		.cfi_endproc
 1830              	.LFE18:
 1831              		.size	uxQueueMessagesWaitingFromISR, .-uxQueueMessagesWaitingFromISR
 1832              		.align	1
 1833              		.global	vQueueDelete
 1834              		.syntax unified
 1835              		.thumb
 1836              		.thumb_func
 1837              		.fpu softvfp
ARM GAS  /tmp/ccdqkONZ.s 			page 72


 1838              		.type	vQueueDelete, %function
 1839              	vQueueDelete:
 1840              	.LFB19:
1973:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1974:FreeRTOS/Source/queue.c **** 
1975:FreeRTOS/Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1976:FreeRTOS/Source/queue.c **** {
 1841              		.loc 1 1976 0
 1842              		.cfi_startproc
 1843              		@ args = 0, pretend = 0, frame = 16
 1844              		@ frame_needed = 1, uses_anonymous_args = 0
 1845 0938 80B5     		push	{r7, lr}
 1846              		.cfi_def_cfa_offset 8
 1847              		.cfi_offset 7, -8
 1848              		.cfi_offset 14, -4
 1849 093a 84B0     		sub	sp, sp, #16
 1850              		.cfi_def_cfa_offset 24
 1851 093c 00AF     		add	r7, sp, #0
 1852              		.cfi_def_cfa_register 7
 1853 093e 7860     		str	r0, [r7, #4]
1977:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 1854              		.loc 1 1977 0
 1855 0940 7B68     		ldr	r3, [r7, #4]
 1856 0942 FB60     		str	r3, [r7, #12]
1978:FreeRTOS/Source/queue.c **** 
1979:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1980:FreeRTOS/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1981:FreeRTOS/Source/queue.c **** 
1982:FreeRTOS/Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1983:FreeRTOS/Source/queue.c **** 	{
1984:FreeRTOS/Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
1985:FreeRTOS/Source/queue.c **** 	}
1986:FreeRTOS/Source/queue.c **** 	#endif
1987:FreeRTOS/Source/queue.c **** 
1988:FreeRTOS/Source/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1989:FreeRTOS/Source/queue.c **** 	{
1990:FreeRTOS/Source/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1991:FreeRTOS/Source/queue.c **** 		again. */
1992:FreeRTOS/Source/queue.c **** 		vPortFree( pxQueue );
 1857              		.loc 1 1992 0
 1858 0944 F868     		ldr	r0, [r7, #12]
 1859 0946 FFF7FEFF 		bl	vPortFree
1993:FreeRTOS/Source/queue.c **** 	}
1994:FreeRTOS/Source/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1995:FreeRTOS/Source/queue.c **** 	{
1996:FreeRTOS/Source/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1997:FreeRTOS/Source/queue.c **** 		check before attempting to free the memory. */
1998:FreeRTOS/Source/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1999:FreeRTOS/Source/queue.c **** 		{
2000:FreeRTOS/Source/queue.c **** 			vPortFree( pxQueue );
2001:FreeRTOS/Source/queue.c **** 		}
2002:FreeRTOS/Source/queue.c **** 		else
2003:FreeRTOS/Source/queue.c **** 		{
2004:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2005:FreeRTOS/Source/queue.c **** 		}
2006:FreeRTOS/Source/queue.c **** 	}
2007:FreeRTOS/Source/queue.c **** 	#else
ARM GAS  /tmp/ccdqkONZ.s 			page 73


2008:FreeRTOS/Source/queue.c **** 	{
2009:FreeRTOS/Source/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
2010:FreeRTOS/Source/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
2011:FreeRTOS/Source/queue.c **** 		( void ) pxQueue;
2012:FreeRTOS/Source/queue.c **** 	}
2013:FreeRTOS/Source/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2014:FreeRTOS/Source/queue.c **** }
 1860              		.loc 1 2014 0
 1861 094a 00BF     		nop
 1862 094c 1037     		adds	r7, r7, #16
 1863              		.cfi_def_cfa_offset 8
 1864 094e BD46     		mov	sp, r7
 1865              		.cfi_def_cfa_register 13
 1866              		@ sp needed
 1867 0950 80BD     		pop	{r7, pc}
 1868              		.cfi_endproc
 1869              	.LFE19:
 1870              		.size	vQueueDelete, .-vQueueDelete
 1871              		.align	1
 1872              		.syntax unified
 1873              		.thumb
 1874              		.thumb_func
 1875              		.fpu softvfp
 1876              		.type	prvCopyDataToQueue, %function
 1877              	prvCopyDataToQueue:
 1878              	.LFB20:
2015:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2016:FreeRTOS/Source/queue.c **** 
2017:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2018:FreeRTOS/Source/queue.c **** 
2019:FreeRTOS/Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2020:FreeRTOS/Source/queue.c **** 	{
2021:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2022:FreeRTOS/Source/queue.c **** 	}
2023:FreeRTOS/Source/queue.c **** 
2024:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2025:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2026:FreeRTOS/Source/queue.c **** 
2027:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2028:FreeRTOS/Source/queue.c **** 
2029:FreeRTOS/Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
2030:FreeRTOS/Source/queue.c **** 	{
2031:FreeRTOS/Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2032:FreeRTOS/Source/queue.c **** 	}
2033:FreeRTOS/Source/queue.c **** 
2034:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2035:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2036:FreeRTOS/Source/queue.c **** 
2037:FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2038:FreeRTOS/Source/queue.c **** 
2039:FreeRTOS/Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2040:FreeRTOS/Source/queue.c **** 	{
2041:FreeRTOS/Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
2042:FreeRTOS/Source/queue.c **** 	}
2043:FreeRTOS/Source/queue.c **** 
2044:FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2045:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  /tmp/ccdqkONZ.s 			page 74


2046:FreeRTOS/Source/queue.c **** 
2047:FreeRTOS/Source/queue.c **** #if( configUSE_MUTEXES == 1 )
2048:FreeRTOS/Source/queue.c **** 
2049:FreeRTOS/Source/queue.c **** 	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2050:FreeRTOS/Source/queue.c **** 	{
2051:FreeRTOS/Source/queue.c **** 	UBaseType_t uxHighestPriorityOfWaitingTasks;
2052:FreeRTOS/Source/queue.c **** 
2053:FreeRTOS/Source/queue.c **** 		/* If a task waiting for a mutex causes the mutex holder to inherit a
2054:FreeRTOS/Source/queue.c **** 		priority, but the waiting task times out, then the holder should
2055:FreeRTOS/Source/queue.c **** 		disinherit the priority - but only down to the highest priority of any
2056:FreeRTOS/Source/queue.c **** 		other tasks that are waiting for the same mutex.  For this purpose,
2057:FreeRTOS/Source/queue.c **** 		return the priority of the highest priority task that is waiting for the
2058:FreeRTOS/Source/queue.c **** 		mutex. */
2059:FreeRTOS/Source/queue.c **** 		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
2060:FreeRTOS/Source/queue.c **** 		{
2061:FreeRTOS/Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET
2062:FreeRTOS/Source/queue.c **** 		}
2063:FreeRTOS/Source/queue.c **** 		else
2064:FreeRTOS/Source/queue.c **** 		{
2065:FreeRTOS/Source/queue.c **** 			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
2066:FreeRTOS/Source/queue.c **** 		}
2067:FreeRTOS/Source/queue.c **** 
2068:FreeRTOS/Source/queue.c **** 		return uxHighestPriorityOfWaitingTasks;
2069:FreeRTOS/Source/queue.c **** 	}
2070:FreeRTOS/Source/queue.c **** 
2071:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
2072:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2073:FreeRTOS/Source/queue.c **** 
2074:FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
2075:FreeRTOS/Source/queue.c **** {
 1879              		.loc 1 2075 0
 1880              		.cfi_startproc
 1881              		@ args = 0, pretend = 0, frame = 24
 1882              		@ frame_needed = 1, uses_anonymous_args = 0
 1883 0952 80B5     		push	{r7, lr}
 1884              		.cfi_def_cfa_offset 8
 1885              		.cfi_offset 7, -8
 1886              		.cfi_offset 14, -4
 1887 0954 86B0     		sub	sp, sp, #24
 1888              		.cfi_def_cfa_offset 32
 1889 0956 00AF     		add	r7, sp, #0
 1890              		.cfi_def_cfa_register 7
 1891 0958 F860     		str	r0, [r7, #12]
 1892 095a B960     		str	r1, [r7, #8]
 1893 095c 7A60     		str	r2, [r7, #4]
2076:FreeRTOS/Source/queue.c **** BaseType_t xReturn = pdFALSE;
 1894              		.loc 1 2076 0
 1895 095e 0023     		movs	r3, #0
 1896 0960 3B61     		str	r3, [r7, #16]
2077:FreeRTOS/Source/queue.c **** UBaseType_t uxMessagesWaiting;
2078:FreeRTOS/Source/queue.c **** 
2079:FreeRTOS/Source/queue.c **** 	/* This function is called from a critical section. */
2080:FreeRTOS/Source/queue.c **** 
2081:FreeRTOS/Source/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1897              		.loc 1 2081 0
 1898 0962 FB68     		ldr	r3, [r7, #12]
 1899 0964 9B6B     		ldr	r3, [r3, #56]
ARM GAS  /tmp/ccdqkONZ.s 			page 75


 1900 0966 7B61     		str	r3, [r7, #20]
2082:FreeRTOS/Source/queue.c **** 
2083:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 1901              		.loc 1 2083 0
 1902 0968 FB68     		ldr	r3, [r7, #12]
 1903 096a 1B6C     		ldr	r3, [r3, #64]
 1904 096c 002B     		cmp	r3, #0
 1905 096e 43D0     		beq	.L115
2084:FreeRTOS/Source/queue.c **** 	{
2085:FreeRTOS/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
2086:FreeRTOS/Source/queue.c **** 		{
2087:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
2088:FreeRTOS/Source/queue.c **** 			{
2089:FreeRTOS/Source/queue.c **** 				/* The mutex is no longer being held. */
2090:FreeRTOS/Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
2091:FreeRTOS/Source/queue.c **** 				pxQueue->u.xSemaphore.xMutexHolder = NULL;
2092:FreeRTOS/Source/queue.c **** 			}
2093:FreeRTOS/Source/queue.c **** 			else
2094:FreeRTOS/Source/queue.c **** 			{
2095:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2096:FreeRTOS/Source/queue.c **** 			}
2097:FreeRTOS/Source/queue.c **** 		}
2098:FreeRTOS/Source/queue.c **** 		#endif /* configUSE_MUTEXES */
2099:FreeRTOS/Source/queue.c **** 	}
2100:FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1906              		.loc 1 2100 0
 1907 0970 7B68     		ldr	r3, [r7, #4]
 1908 0972 002B     		cmp	r3, #0
 1909 0974 19D1     		bne	.L116
2101:FreeRTOS/Source/queue.c **** 	{
2102:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 1910              		.loc 1 2102 0
 1911 0976 FB68     		ldr	r3, [r7, #12]
 1912 0978 5868     		ldr	r0, [r3, #4]
 1913 097a FB68     		ldr	r3, [r7, #12]
 1914 097c 1B6C     		ldr	r3, [r3, #64]
 1915 097e 1A46     		mov	r2, r3
 1916 0980 B968     		ldr	r1, [r7, #8]
 1917 0982 FFF7FEFF 		bl	memcpy
2103:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, esp
 1918              		.loc 1 2103 0
 1919 0986 FB68     		ldr	r3, [r7, #12]
 1920 0988 5A68     		ldr	r2, [r3, #4]
 1921 098a FB68     		ldr	r3, [r7, #12]
 1922 098c 1B6C     		ldr	r3, [r3, #64]
 1923 098e 1A44     		add	r2, r2, r3
 1924 0990 FB68     		ldr	r3, [r7, #12]
 1925 0992 5A60     		str	r2, [r3, #4]
2104:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as co
 1926              		.loc 1 2104 0
 1927 0994 FB68     		ldr	r3, [r7, #12]
 1928 0996 5A68     		ldr	r2, [r3, #4]
 1929 0998 FB68     		ldr	r3, [r7, #12]
 1930 099a 9B68     		ldr	r3, [r3, #8]
 1931 099c 9A42     		cmp	r2, r3
 1932 099e 2BD3     		bcc	.L115
2105:FreeRTOS/Source/queue.c **** 		{
ARM GAS  /tmp/ccdqkONZ.s 			page 76


2106:FreeRTOS/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1933              		.loc 1 2106 0
 1934 09a0 FB68     		ldr	r3, [r7, #12]
 1935 09a2 1A68     		ldr	r2, [r3]
 1936 09a4 FB68     		ldr	r3, [r7, #12]
 1937 09a6 5A60     		str	r2, [r3, #4]
 1938 09a8 26E0     		b	.L115
 1939              	.L116:
2107:FreeRTOS/Source/queue.c **** 		}
2108:FreeRTOS/Source/queue.c **** 		else
2109:FreeRTOS/Source/queue.c **** 		{
2110:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2111:FreeRTOS/Source/queue.c **** 		}
2112:FreeRTOS/Source/queue.c **** 	}
2113:FreeRTOS/Source/queue.c **** 	else
2114:FreeRTOS/Source/queue.c **** 	{
2115:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxIt
 1940              		.loc 1 2115 0
 1941 09aa FB68     		ldr	r3, [r7, #12]
 1942 09ac D868     		ldr	r0, [r3, #12]
 1943 09ae FB68     		ldr	r3, [r7, #12]
 1944 09b0 1B6C     		ldr	r3, [r3, #64]
 1945 09b2 1A46     		mov	r2, r3
 1946 09b4 B968     		ldr	r1, [r7, #8]
 1947 09b6 FFF7FEFF 		bl	memcpy
2116:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 1948              		.loc 1 2116 0
 1949 09ba FB68     		ldr	r3, [r7, #12]
 1950 09bc DA68     		ldr	r2, [r3, #12]
 1951 09be FB68     		ldr	r3, [r7, #12]
 1952 09c0 1B6C     		ldr	r3, [r3, #64]
 1953 09c2 5B42     		negs	r3, r3
 1954 09c4 1A44     		add	r2, r2, r3
 1955 09c6 FB68     		ldr	r3, [r7, #12]
 1956 09c8 DA60     		str	r2, [r3, #12]
2117:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as co
 1957              		.loc 1 2117 0
 1958 09ca FB68     		ldr	r3, [r7, #12]
 1959 09cc DA68     		ldr	r2, [r3, #12]
 1960 09ce FB68     		ldr	r3, [r7, #12]
 1961 09d0 1B68     		ldr	r3, [r3]
 1962 09d2 9A42     		cmp	r2, r3
 1963 09d4 07D2     		bcs	.L117
2118:FreeRTOS/Source/queue.c **** 		{
2119:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 1964              		.loc 1 2119 0
 1965 09d6 FB68     		ldr	r3, [r7, #12]
 1966 09d8 9A68     		ldr	r2, [r3, #8]
 1967 09da FB68     		ldr	r3, [r7, #12]
 1968 09dc 1B6C     		ldr	r3, [r3, #64]
 1969 09de 5B42     		negs	r3, r3
 1970 09e0 1A44     		add	r2, r2, r3
 1971 09e2 FB68     		ldr	r3, [r7, #12]
 1972 09e4 DA60     		str	r2, [r3, #12]
 1973              	.L117:
2120:FreeRTOS/Source/queue.c **** 		}
2121:FreeRTOS/Source/queue.c **** 		else
ARM GAS  /tmp/ccdqkONZ.s 			page 77


2122:FreeRTOS/Source/queue.c **** 		{
2123:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2124:FreeRTOS/Source/queue.c **** 		}
2125:FreeRTOS/Source/queue.c **** 
2126:FreeRTOS/Source/queue.c **** 		if( xPosition == queueOVERWRITE )
 1974              		.loc 1 2126 0
 1975 09e6 7B68     		ldr	r3, [r7, #4]
 1976 09e8 022B     		cmp	r3, #2
 1977 09ea 05D1     		bne	.L115
2127:FreeRTOS/Source/queue.c **** 		{
2128:FreeRTOS/Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1978              		.loc 1 2128 0
 1979 09ec 7B69     		ldr	r3, [r7, #20]
 1980 09ee 002B     		cmp	r3, #0
 1981 09f0 02D0     		beq	.L115
2129:FreeRTOS/Source/queue.c **** 			{
2130:FreeRTOS/Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
2131:FreeRTOS/Source/queue.c **** 				one from the recorded number of items in the queue so when
2132:FreeRTOS/Source/queue.c **** 				one is added again below the number of recorded items remains
2133:FreeRTOS/Source/queue.c **** 				correct. */
2134:FreeRTOS/Source/queue.c **** 				--uxMessagesWaiting;
 1982              		.loc 1 2134 0
 1983 09f2 7B69     		ldr	r3, [r7, #20]
 1984 09f4 013B     		subs	r3, r3, #1
 1985 09f6 7B61     		str	r3, [r7, #20]
 1986              	.L115:
2135:FreeRTOS/Source/queue.c **** 			}
2136:FreeRTOS/Source/queue.c **** 			else
2137:FreeRTOS/Source/queue.c **** 			{
2138:FreeRTOS/Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2139:FreeRTOS/Source/queue.c **** 			}
2140:FreeRTOS/Source/queue.c **** 		}
2141:FreeRTOS/Source/queue.c **** 		else
2142:FreeRTOS/Source/queue.c **** 		{
2143:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2144:FreeRTOS/Source/queue.c **** 		}
2145:FreeRTOS/Source/queue.c **** 	}
2146:FreeRTOS/Source/queue.c **** 
2147:FreeRTOS/Source/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 1987              		.loc 1 2147 0
 1988 09f8 7B69     		ldr	r3, [r7, #20]
 1989 09fa 5A1C     		adds	r2, r3, #1
 1990 09fc FB68     		ldr	r3, [r7, #12]
 1991 09fe 9A63     		str	r2, [r3, #56]
2148:FreeRTOS/Source/queue.c **** 
2149:FreeRTOS/Source/queue.c **** 	return xReturn;
 1992              		.loc 1 2149 0
 1993 0a00 3B69     		ldr	r3, [r7, #16]
2150:FreeRTOS/Source/queue.c **** }
 1994              		.loc 1 2150 0
 1995 0a02 1846     		mov	r0, r3
 1996 0a04 1837     		adds	r7, r7, #24
 1997              		.cfi_def_cfa_offset 8
 1998 0a06 BD46     		mov	sp, r7
 1999              		.cfi_def_cfa_register 13
 2000              		@ sp needed
 2001 0a08 80BD     		pop	{r7, pc}
ARM GAS  /tmp/ccdqkONZ.s 			page 78


 2002              		.cfi_endproc
 2003              	.LFE20:
 2004              		.size	prvCopyDataToQueue, .-prvCopyDataToQueue
 2005              		.align	1
 2006              		.syntax unified
 2007              		.thumb
 2008              		.thumb_func
 2009              		.fpu softvfp
 2010              		.type	prvCopyDataFromQueue, %function
 2011              	prvCopyDataFromQueue:
 2012              	.LFB21:
2151:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2152:FreeRTOS/Source/queue.c **** 
2153:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
2154:FreeRTOS/Source/queue.c **** {
 2013              		.loc 1 2154 0
 2014              		.cfi_startproc
 2015              		@ args = 0, pretend = 0, frame = 8
 2016              		@ frame_needed = 1, uses_anonymous_args = 0
 2017 0a0a 80B5     		push	{r7, lr}
 2018              		.cfi_def_cfa_offset 8
 2019              		.cfi_offset 7, -8
 2020              		.cfi_offset 14, -4
 2021 0a0c 82B0     		sub	sp, sp, #8
 2022              		.cfi_def_cfa_offset 16
 2023 0a0e 00AF     		add	r7, sp, #0
 2024              		.cfi_def_cfa_register 7
 2025 0a10 7860     		str	r0, [r7, #4]
 2026 0a12 3960     		str	r1, [r7]
2155:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 2027              		.loc 1 2155 0
 2028 0a14 7B68     		ldr	r3, [r7, #4]
 2029 0a16 1B6C     		ldr	r3, [r3, #64]
 2030 0a18 002B     		cmp	r3, #0
 2031 0a1a 18D0     		beq	.L122
2156:FreeRTOS/Source/queue.c **** 	{
2157:FreeRTOS/Source/queue.c **** 		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char typ
 2032              		.loc 1 2157 0
 2033 0a1c 7B68     		ldr	r3, [r7, #4]
 2034 0a1e DA68     		ldr	r2, [r3, #12]
 2035 0a20 7B68     		ldr	r3, [r7, #4]
 2036 0a22 1B6C     		ldr	r3, [r3, #64]
 2037 0a24 1A44     		add	r2, r2, r3
 2038 0a26 7B68     		ldr	r3, [r7, #4]
 2039 0a28 DA60     		str	r2, [r3, #12]
2158:FreeRTOS/Source/queue.c **** 		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justi
 2040              		.loc 1 2158 0
 2041 0a2a 7B68     		ldr	r3, [r7, #4]
 2042 0a2c DA68     		ldr	r2, [r3, #12]
 2043 0a2e 7B68     		ldr	r3, [r7, #4]
 2044 0a30 9B68     		ldr	r3, [r3, #8]
 2045 0a32 9A42     		cmp	r2, r3
 2046 0a34 03D3     		bcc	.L121
2159:FreeRTOS/Source/queue.c **** 		{
2160:FreeRTOS/Source/queue.c **** 			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 2047              		.loc 1 2160 0
 2048 0a36 7B68     		ldr	r3, [r7, #4]
ARM GAS  /tmp/ccdqkONZ.s 			page 79


 2049 0a38 1A68     		ldr	r2, [r3]
 2050 0a3a 7B68     		ldr	r3, [r7, #4]
 2051 0a3c DA60     		str	r2, [r3, #12]
 2052              	.L121:
2161:FreeRTOS/Source/queue.c **** 		}
2162:FreeRTOS/Source/queue.c **** 		else
2163:FreeRTOS/Source/queue.c **** 		{
2164:FreeRTOS/Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2165:FreeRTOS/Source/queue.c **** 		}
2166:FreeRTOS/Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue
 2053              		.loc 1 2166 0
 2054 0a3e 7B68     		ldr	r3, [r7, #4]
 2055 0a40 D968     		ldr	r1, [r3, #12]
 2056 0a42 7B68     		ldr	r3, [r7, #4]
 2057 0a44 1B6C     		ldr	r3, [r3, #64]
 2058 0a46 1A46     		mov	r2, r3
 2059 0a48 3868     		ldr	r0, [r7]
 2060 0a4a FFF7FEFF 		bl	memcpy
 2061              	.L122:
2167:FreeRTOS/Source/queue.c **** 	}
2168:FreeRTOS/Source/queue.c **** }
 2062              		.loc 1 2168 0
 2063 0a4e 00BF     		nop
 2064 0a50 0837     		adds	r7, r7, #8
 2065              		.cfi_def_cfa_offset 8
 2066 0a52 BD46     		mov	sp, r7
 2067              		.cfi_def_cfa_register 13
 2068              		@ sp needed
 2069 0a54 80BD     		pop	{r7, pc}
 2070              		.cfi_endproc
 2071              	.LFE21:
 2072              		.size	prvCopyDataFromQueue, .-prvCopyDataFromQueue
 2073              		.align	1
 2074              		.syntax unified
 2075              		.thumb
 2076              		.thumb_func
 2077              		.fpu softvfp
 2078              		.type	prvUnlockQueue, %function
 2079              	prvUnlockQueue:
 2080              	.LFB22:
2169:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2170:FreeRTOS/Source/queue.c **** 
2171:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2172:FreeRTOS/Source/queue.c **** {
 2081              		.loc 1 2172 0
 2082              		.cfi_startproc
 2083              		@ args = 0, pretend = 0, frame = 16
 2084              		@ frame_needed = 1, uses_anonymous_args = 0
 2085 0a56 80B5     		push	{r7, lr}
 2086              		.cfi_def_cfa_offset 8
 2087              		.cfi_offset 7, -8
 2088              		.cfi_offset 14, -4
 2089 0a58 84B0     		sub	sp, sp, #16
 2090              		.cfi_def_cfa_offset 24
 2091 0a5a 00AF     		add	r7, sp, #0
 2092              		.cfi_def_cfa_register 7
 2093 0a5c 7860     		str	r0, [r7, #4]
ARM GAS  /tmp/ccdqkONZ.s 			page 80


2173:FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2174:FreeRTOS/Source/queue.c **** 
2175:FreeRTOS/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
2176:FreeRTOS/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
2177:FreeRTOS/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
2178:FreeRTOS/Source/queue.c **** 	updated. */
2179:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 2094              		.loc 1 2179 0
 2095 0a5e FFF7FEFF 		bl	vPortEnterCritical
 2096              	.LBB47:
2180:FreeRTOS/Source/queue.c **** 	{
2181:FreeRTOS/Source/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
 2097              		.loc 1 2181 0
 2098 0a62 7B68     		ldr	r3, [r7, #4]
 2099 0a64 93F84530 		ldrb	r3, [r3, #69]
 2100 0a68 FB73     		strb	r3, [r7, #15]
2182:FreeRTOS/Source/queue.c **** 
2183:FreeRTOS/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
2184:FreeRTOS/Source/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
 2101              		.loc 1 2184 0
 2102 0a6a 11E0     		b	.L124
 2103              	.L128:
2185:FreeRTOS/Source/queue.c **** 		{
2186:FreeRTOS/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
2187:FreeRTOS/Source/queue.c **** 			blocked waiting for data to become available? */
2188:FreeRTOS/Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
2189:FreeRTOS/Source/queue.c **** 			{
2190:FreeRTOS/Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
2191:FreeRTOS/Source/queue.c **** 				{
2192:FreeRTOS/Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
2193:FreeRTOS/Source/queue.c **** 					{
2194:FreeRTOS/Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
2195:FreeRTOS/Source/queue.c **** 						the queue set caused a higher priority task to unblock.
2196:FreeRTOS/Source/queue.c **** 						A context switch is required. */
2197:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
2198:FreeRTOS/Source/queue.c **** 					}
2199:FreeRTOS/Source/queue.c **** 					else
2200:FreeRTOS/Source/queue.c **** 					{
2201:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2202:FreeRTOS/Source/queue.c **** 					}
2203:FreeRTOS/Source/queue.c **** 				}
2204:FreeRTOS/Source/queue.c **** 				else
2205:FreeRTOS/Source/queue.c **** 				{
2206:FreeRTOS/Source/queue.c **** 					/* Tasks that are removed from the event list will get
2207:FreeRTOS/Source/queue.c **** 					added to the pending ready list as the scheduler is still
2208:FreeRTOS/Source/queue.c **** 					suspended. */
2209:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2210:FreeRTOS/Source/queue.c **** 					{
2211:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2212:FreeRTOS/Source/queue.c **** 						{
2213:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority so record that a
2214:FreeRTOS/Source/queue.c **** 							context	switch is required. */
2215:FreeRTOS/Source/queue.c **** 							vTaskMissedYield();
2216:FreeRTOS/Source/queue.c **** 						}
2217:FreeRTOS/Source/queue.c **** 						else
2218:FreeRTOS/Source/queue.c **** 						{
2219:FreeRTOS/Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
ARM GAS  /tmp/ccdqkONZ.s 			page 81


2220:FreeRTOS/Source/queue.c **** 						}
2221:FreeRTOS/Source/queue.c **** 					}
2222:FreeRTOS/Source/queue.c **** 					else
2223:FreeRTOS/Source/queue.c **** 					{
2224:FreeRTOS/Source/queue.c **** 						break;
2225:FreeRTOS/Source/queue.c **** 					}
2226:FreeRTOS/Source/queue.c **** 				}
2227:FreeRTOS/Source/queue.c **** 			}
2228:FreeRTOS/Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
2229:FreeRTOS/Source/queue.c **** 			{
2230:FreeRTOS/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
2231:FreeRTOS/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
2232:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2104              		.loc 1 2232 0
 2105 0a6c 7B68     		ldr	r3, [r7, #4]
 2106 0a6e 5B6A     		ldr	r3, [r3, #36]
 2107 0a70 002B     		cmp	r3, #0
 2108 0a72 12D0     		beq	.L134
2233:FreeRTOS/Source/queue.c **** 				{
2234:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2109              		.loc 1 2234 0
 2110 0a74 7B68     		ldr	r3, [r7, #4]
 2111 0a76 2433     		adds	r3, r3, #36
 2112 0a78 1846     		mov	r0, r3
 2113 0a7a FFF7FEFF 		bl	xTaskRemoveFromEventList
 2114 0a7e 0346     		mov	r3, r0
 2115 0a80 002B     		cmp	r3, #0
 2116 0a82 01D0     		beq	.L126
2235:FreeRTOS/Source/queue.c **** 					{
2236:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority so record that
2237:FreeRTOS/Source/queue.c **** 						a context switch is required. */
2238:FreeRTOS/Source/queue.c **** 						vTaskMissedYield();
 2117              		.loc 1 2238 0
 2118 0a84 FFF7FEFF 		bl	vTaskMissedYield
 2119              	.L126:
2239:FreeRTOS/Source/queue.c **** 					}
2240:FreeRTOS/Source/queue.c **** 					else
2241:FreeRTOS/Source/queue.c **** 					{
2242:FreeRTOS/Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2243:FreeRTOS/Source/queue.c **** 					}
2244:FreeRTOS/Source/queue.c **** 				}
2245:FreeRTOS/Source/queue.c **** 				else
2246:FreeRTOS/Source/queue.c **** 				{
2247:FreeRTOS/Source/queue.c **** 					break;
2248:FreeRTOS/Source/queue.c **** 				}
2249:FreeRTOS/Source/queue.c **** 			}
2250:FreeRTOS/Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
2251:FreeRTOS/Source/queue.c **** 
2252:FreeRTOS/Source/queue.c **** 			--cTxLock;
 2120              		.loc 1 2252 0
 2121 0a88 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 2122 0a8a 013B     		subs	r3, r3, #1
 2123 0a8c DBB2     		uxtb	r3, r3
 2124 0a8e FB73     		strb	r3, [r7, #15]
 2125              	.L124:
2184:FreeRTOS/Source/queue.c **** 		{
 2126              		.loc 1 2184 0
ARM GAS  /tmp/ccdqkONZ.s 			page 82


 2127 0a90 97F90F30 		ldrsb	r3, [r7, #15]
 2128 0a94 002B     		cmp	r3, #0
 2129 0a96 E9DC     		bgt	.L128
 2130 0a98 00E0     		b	.L127
 2131              	.L134:
2247:FreeRTOS/Source/queue.c **** 				}
 2132              		.loc 1 2247 0
 2133 0a9a 00BF     		nop
 2134              	.L127:
2253:FreeRTOS/Source/queue.c **** 		}
2254:FreeRTOS/Source/queue.c **** 
2255:FreeRTOS/Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 2135              		.loc 1 2255 0
 2136 0a9c 7B68     		ldr	r3, [r7, #4]
 2137 0a9e FF22     		movs	r2, #255
 2138 0aa0 83F84520 		strb	r2, [r3, #69]
 2139              	.LBE47:
2256:FreeRTOS/Source/queue.c **** 	}
2257:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 2140              		.loc 1 2257 0
 2141 0aa4 FFF7FEFF 		bl	vPortExitCritical
2258:FreeRTOS/Source/queue.c **** 
2259:FreeRTOS/Source/queue.c **** 	/* Do the same for the Rx lock. */
2260:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 2142              		.loc 1 2260 0
 2143 0aa8 FFF7FEFF 		bl	vPortEnterCritical
 2144              	.LBB48:
2261:FreeRTOS/Source/queue.c **** 	{
2262:FreeRTOS/Source/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
 2145              		.loc 1 2262 0
 2146 0aac 7B68     		ldr	r3, [r7, #4]
 2147 0aae 93F84430 		ldrb	r3, [r3, #68]
 2148 0ab2 BB73     		strb	r3, [r7, #14]
2263:FreeRTOS/Source/queue.c **** 
2264:FreeRTOS/Source/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
 2149              		.loc 1 2264 0
 2150 0ab4 11E0     		b	.L129
 2151              	.L133:
2265:FreeRTOS/Source/queue.c **** 		{
2266:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2152              		.loc 1 2266 0
 2153 0ab6 7B68     		ldr	r3, [r7, #4]
 2154 0ab8 1B69     		ldr	r3, [r3, #16]
 2155 0aba 002B     		cmp	r3, #0
 2156 0abc 12D0     		beq	.L135
2267:FreeRTOS/Source/queue.c **** 			{
2268:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2157              		.loc 1 2268 0
 2158 0abe 7B68     		ldr	r3, [r7, #4]
 2159 0ac0 1033     		adds	r3, r3, #16
 2160 0ac2 1846     		mov	r0, r3
 2161 0ac4 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2162 0ac8 0346     		mov	r3, r0
 2163 0aca 002B     		cmp	r3, #0
 2164 0acc 01D0     		beq	.L131
2269:FreeRTOS/Source/queue.c **** 				{
2270:FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
ARM GAS  /tmp/ccdqkONZ.s 			page 83


 2165              		.loc 1 2270 0
 2166 0ace FFF7FEFF 		bl	vTaskMissedYield
 2167              	.L131:
2271:FreeRTOS/Source/queue.c **** 				}
2272:FreeRTOS/Source/queue.c **** 				else
2273:FreeRTOS/Source/queue.c **** 				{
2274:FreeRTOS/Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2275:FreeRTOS/Source/queue.c **** 				}
2276:FreeRTOS/Source/queue.c **** 
2277:FreeRTOS/Source/queue.c **** 				--cRxLock;
 2168              		.loc 1 2277 0
 2169 0ad2 BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 2170 0ad4 013B     		subs	r3, r3, #1
 2171 0ad6 DBB2     		uxtb	r3, r3
 2172 0ad8 BB73     		strb	r3, [r7, #14]
 2173              	.L129:
2264:FreeRTOS/Source/queue.c **** 		{
 2174              		.loc 1 2264 0
 2175 0ada 97F90E30 		ldrsb	r3, [r7, #14]
 2176 0ade 002B     		cmp	r3, #0
 2177 0ae0 E9DC     		bgt	.L133
 2178 0ae2 00E0     		b	.L132
 2179              	.L135:
2278:FreeRTOS/Source/queue.c **** 			}
2279:FreeRTOS/Source/queue.c **** 			else
2280:FreeRTOS/Source/queue.c **** 			{
2281:FreeRTOS/Source/queue.c **** 				break;
 2180              		.loc 1 2281 0
 2181 0ae4 00BF     		nop
 2182              	.L132:
2282:FreeRTOS/Source/queue.c **** 			}
2283:FreeRTOS/Source/queue.c **** 		}
2284:FreeRTOS/Source/queue.c **** 
2285:FreeRTOS/Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 2183              		.loc 1 2285 0
 2184 0ae6 7B68     		ldr	r3, [r7, #4]
 2185 0ae8 FF22     		movs	r2, #255
 2186 0aea 83F84420 		strb	r2, [r3, #68]
 2187              	.LBE48:
2286:FreeRTOS/Source/queue.c **** 	}
2287:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 2188              		.loc 1 2287 0
 2189 0aee FFF7FEFF 		bl	vPortExitCritical
2288:FreeRTOS/Source/queue.c **** }
 2190              		.loc 1 2288 0
 2191 0af2 00BF     		nop
 2192 0af4 1037     		adds	r7, r7, #16
 2193              		.cfi_def_cfa_offset 8
 2194 0af6 BD46     		mov	sp, r7
 2195              		.cfi_def_cfa_register 13
 2196              		@ sp needed
 2197 0af8 80BD     		pop	{r7, pc}
 2198              		.cfi_endproc
 2199              	.LFE22:
 2200              		.size	prvUnlockQueue, .-prvUnlockQueue
 2201              		.align	1
 2202              		.syntax unified
ARM GAS  /tmp/ccdqkONZ.s 			page 84


 2203              		.thumb
 2204              		.thumb_func
 2205              		.fpu softvfp
 2206              		.type	prvIsQueueEmpty, %function
 2207              	prvIsQueueEmpty:
 2208              	.LFB23:
2289:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2290:FreeRTOS/Source/queue.c **** 
2291:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
2292:FreeRTOS/Source/queue.c **** {
 2209              		.loc 1 2292 0
 2210              		.cfi_startproc
 2211              		@ args = 0, pretend = 0, frame = 16
 2212              		@ frame_needed = 1, uses_anonymous_args = 0
 2213 0afa 80B5     		push	{r7, lr}
 2214              		.cfi_def_cfa_offset 8
 2215              		.cfi_offset 7, -8
 2216              		.cfi_offset 14, -4
 2217 0afc 84B0     		sub	sp, sp, #16
 2218              		.cfi_def_cfa_offset 24
 2219 0afe 00AF     		add	r7, sp, #0
 2220              		.cfi_def_cfa_register 7
 2221 0b00 7860     		str	r0, [r7, #4]
2293:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2294:FreeRTOS/Source/queue.c **** 
2295:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 2222              		.loc 1 2295 0
 2223 0b02 FFF7FEFF 		bl	vPortEnterCritical
2296:FreeRTOS/Source/queue.c **** 	{
2297:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 2224              		.loc 1 2297 0
 2225 0b06 7B68     		ldr	r3, [r7, #4]
 2226 0b08 9B6B     		ldr	r3, [r3, #56]
 2227 0b0a 002B     		cmp	r3, #0
 2228 0b0c 02D1     		bne	.L137
2298:FreeRTOS/Source/queue.c **** 		{
2299:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
 2229              		.loc 1 2299 0
 2230 0b0e 0123     		movs	r3, #1
 2231 0b10 FB60     		str	r3, [r7, #12]
 2232 0b12 01E0     		b	.L138
 2233              	.L137:
2300:FreeRTOS/Source/queue.c **** 		}
2301:FreeRTOS/Source/queue.c **** 		else
2302:FreeRTOS/Source/queue.c **** 		{
2303:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
 2234              		.loc 1 2303 0
 2235 0b14 0023     		movs	r3, #0
 2236 0b16 FB60     		str	r3, [r7, #12]
 2237              	.L138:
2304:FreeRTOS/Source/queue.c **** 		}
2305:FreeRTOS/Source/queue.c **** 	}
2306:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 2238              		.loc 1 2306 0
 2239 0b18 FFF7FEFF 		bl	vPortExitCritical
2307:FreeRTOS/Source/queue.c **** 
2308:FreeRTOS/Source/queue.c **** 	return xReturn;
ARM GAS  /tmp/ccdqkONZ.s 			page 85


 2240              		.loc 1 2308 0
 2241 0b1c FB68     		ldr	r3, [r7, #12]
2309:FreeRTOS/Source/queue.c **** }
 2242              		.loc 1 2309 0
 2243 0b1e 1846     		mov	r0, r3
 2244 0b20 1037     		adds	r7, r7, #16
 2245              		.cfi_def_cfa_offset 8
 2246 0b22 BD46     		mov	sp, r7
 2247              		.cfi_def_cfa_register 13
 2248              		@ sp needed
 2249 0b24 80BD     		pop	{r7, pc}
 2250              		.cfi_endproc
 2251              	.LFE23:
 2252              		.size	prvIsQueueEmpty, .-prvIsQueueEmpty
 2253              		.align	1
 2254              		.global	xQueueIsQueueEmptyFromISR
 2255              		.syntax unified
 2256              		.thumb
 2257              		.thumb_func
 2258              		.fpu softvfp
 2259              		.type	xQueueIsQueueEmptyFromISR, %function
 2260              	xQueueIsQueueEmptyFromISR:
 2261              	.LFB24:
2310:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2311:FreeRTOS/Source/queue.c **** 
2312:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2313:FreeRTOS/Source/queue.c **** {
 2262              		.loc 1 2313 0
 2263              		.cfi_startproc
 2264              		@ args = 0, pretend = 0, frame = 16
 2265              		@ frame_needed = 1, uses_anonymous_args = 0
 2266              		@ link register save eliminated.
 2267 0b26 80B4     		push	{r7}
 2268              		.cfi_def_cfa_offset 4
 2269              		.cfi_offset 7, -4
 2270 0b28 85B0     		sub	sp, sp, #20
 2271              		.cfi_def_cfa_offset 24
 2272 0b2a 00AF     		add	r7, sp, #0
 2273              		.cfi_def_cfa_register 7
 2274 0b2c 7860     		str	r0, [r7, #4]
2314:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2315:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2275              		.loc 1 2315 0
 2276 0b2e 7B68     		ldr	r3, [r7, #4]
 2277 0b30 BB60     		str	r3, [r7, #8]
2316:FreeRTOS/Source/queue.c **** 
2317:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
2318:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2278              		.loc 1 2318 0
 2279 0b32 BB68     		ldr	r3, [r7, #8]
 2280 0b34 9B6B     		ldr	r3, [r3, #56]
 2281 0b36 002B     		cmp	r3, #0
 2282 0b38 02D1     		bne	.L141
2319:FreeRTOS/Source/queue.c **** 	{
2320:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
 2283              		.loc 1 2320 0
 2284 0b3a 0123     		movs	r3, #1
ARM GAS  /tmp/ccdqkONZ.s 			page 86


 2285 0b3c FB60     		str	r3, [r7, #12]
 2286 0b3e 01E0     		b	.L142
 2287              	.L141:
2321:FreeRTOS/Source/queue.c **** 	}
2322:FreeRTOS/Source/queue.c **** 	else
2323:FreeRTOS/Source/queue.c **** 	{
2324:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
 2288              		.loc 1 2324 0
 2289 0b40 0023     		movs	r3, #0
 2290 0b42 FB60     		str	r3, [r7, #12]
 2291              	.L142:
2325:FreeRTOS/Source/queue.c **** 	}
2326:FreeRTOS/Source/queue.c **** 
2327:FreeRTOS/Source/queue.c **** 	return xReturn;
 2292              		.loc 1 2327 0
 2293 0b44 FB68     		ldr	r3, [r7, #12]
2328:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2294              		.loc 1 2328 0
 2295 0b46 1846     		mov	r0, r3
 2296 0b48 1437     		adds	r7, r7, #20
 2297              		.cfi_def_cfa_offset 4
 2298 0b4a BD46     		mov	sp, r7
 2299              		.cfi_def_cfa_register 13
 2300              		@ sp needed
 2301 0b4c 80BC     		pop	{r7}
 2302              		.cfi_restore 7
 2303              		.cfi_def_cfa_offset 0
 2304 0b4e 7047     		bx	lr
 2305              		.cfi_endproc
 2306              	.LFE24:
 2307              		.size	xQueueIsQueueEmptyFromISR, .-xQueueIsQueueEmptyFromISR
 2308              		.align	1
 2309              		.syntax unified
 2310              		.thumb
 2311              		.thumb_func
 2312              		.fpu softvfp
 2313              		.type	prvIsQueueFull, %function
 2314              	prvIsQueueFull:
 2315              	.LFB25:
2329:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2330:FreeRTOS/Source/queue.c **** 
2331:FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
2332:FreeRTOS/Source/queue.c **** {
 2316              		.loc 1 2332 0
 2317              		.cfi_startproc
 2318              		@ args = 0, pretend = 0, frame = 16
 2319              		@ frame_needed = 1, uses_anonymous_args = 0
 2320 0b50 80B5     		push	{r7, lr}
 2321              		.cfi_def_cfa_offset 8
 2322              		.cfi_offset 7, -8
 2323              		.cfi_offset 14, -4
 2324 0b52 84B0     		sub	sp, sp, #16
 2325              		.cfi_def_cfa_offset 24
 2326 0b54 00AF     		add	r7, sp, #0
 2327              		.cfi_def_cfa_register 7
 2328 0b56 7860     		str	r0, [r7, #4]
2333:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
ARM GAS  /tmp/ccdqkONZ.s 			page 87


2334:FreeRTOS/Source/queue.c **** 
2335:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 2329              		.loc 1 2335 0
 2330 0b58 FFF7FEFF 		bl	vPortEnterCritical
2336:FreeRTOS/Source/queue.c **** 	{
2337:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2331              		.loc 1 2337 0
 2332 0b5c 7B68     		ldr	r3, [r7, #4]
 2333 0b5e 9A6B     		ldr	r2, [r3, #56]
 2334 0b60 7B68     		ldr	r3, [r7, #4]
 2335 0b62 DB6B     		ldr	r3, [r3, #60]
 2336 0b64 9A42     		cmp	r2, r3
 2337 0b66 02D1     		bne	.L145
2338:FreeRTOS/Source/queue.c **** 		{
2339:FreeRTOS/Source/queue.c **** 			xReturn = pdTRUE;
 2338              		.loc 1 2339 0
 2339 0b68 0123     		movs	r3, #1
 2340 0b6a FB60     		str	r3, [r7, #12]
 2341 0b6c 01E0     		b	.L146
 2342              	.L145:
2340:FreeRTOS/Source/queue.c **** 		}
2341:FreeRTOS/Source/queue.c **** 		else
2342:FreeRTOS/Source/queue.c **** 		{
2343:FreeRTOS/Source/queue.c **** 			xReturn = pdFALSE;
 2343              		.loc 1 2343 0
 2344 0b6e 0023     		movs	r3, #0
 2345 0b70 FB60     		str	r3, [r7, #12]
 2346              	.L146:
2344:FreeRTOS/Source/queue.c **** 		}
2345:FreeRTOS/Source/queue.c **** 	}
2346:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 2347              		.loc 1 2346 0
 2348 0b72 FFF7FEFF 		bl	vPortExitCritical
2347:FreeRTOS/Source/queue.c **** 
2348:FreeRTOS/Source/queue.c **** 	return xReturn;
 2349              		.loc 1 2348 0
 2350 0b76 FB68     		ldr	r3, [r7, #12]
2349:FreeRTOS/Source/queue.c **** }
 2351              		.loc 1 2349 0
 2352 0b78 1846     		mov	r0, r3
 2353 0b7a 1037     		adds	r7, r7, #16
 2354              		.cfi_def_cfa_offset 8
 2355 0b7c BD46     		mov	sp, r7
 2356              		.cfi_def_cfa_register 13
 2357              		@ sp needed
 2358 0b7e 80BD     		pop	{r7, pc}
 2359              		.cfi_endproc
 2360              	.LFE25:
 2361              		.size	prvIsQueueFull, .-prvIsQueueFull
 2362              		.align	1
 2363              		.global	xQueueIsQueueFullFromISR
 2364              		.syntax unified
 2365              		.thumb
 2366              		.thumb_func
 2367              		.fpu softvfp
 2368              		.type	xQueueIsQueueFullFromISR, %function
 2369              	xQueueIsQueueFullFromISR:
ARM GAS  /tmp/ccdqkONZ.s 			page 88


 2370              	.LFB26:
2350:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2351:FreeRTOS/Source/queue.c **** 
2352:FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2353:FreeRTOS/Source/queue.c **** {
 2371              		.loc 1 2353 0
 2372              		.cfi_startproc
 2373              		@ args = 0, pretend = 0, frame = 16
 2374              		@ frame_needed = 1, uses_anonymous_args = 0
 2375              		@ link register save eliminated.
 2376 0b80 80B4     		push	{r7}
 2377              		.cfi_def_cfa_offset 4
 2378              		.cfi_offset 7, -4
 2379 0b82 85B0     		sub	sp, sp, #20
 2380              		.cfi_def_cfa_offset 24
 2381 0b84 00AF     		add	r7, sp, #0
 2382              		.cfi_def_cfa_register 7
 2383 0b86 7860     		str	r0, [r7, #4]
2354:FreeRTOS/Source/queue.c **** BaseType_t xReturn;
2355:FreeRTOS/Source/queue.c **** Queue_t * const pxQueue = xQueue;
 2384              		.loc 1 2355 0
 2385 0b88 7B68     		ldr	r3, [r7, #4]
 2386 0b8a BB60     		str	r3, [r7, #8]
2356:FreeRTOS/Source/queue.c **** 
2357:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
2358:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2387              		.loc 1 2358 0
 2388 0b8c BB68     		ldr	r3, [r7, #8]
 2389 0b8e 9A6B     		ldr	r2, [r3, #56]
 2390 0b90 BB68     		ldr	r3, [r7, #8]
 2391 0b92 DB6B     		ldr	r3, [r3, #60]
 2392 0b94 9A42     		cmp	r2, r3
 2393 0b96 02D1     		bne	.L149
2359:FreeRTOS/Source/queue.c **** 	{
2360:FreeRTOS/Source/queue.c **** 		xReturn = pdTRUE;
 2394              		.loc 1 2360 0
 2395 0b98 0123     		movs	r3, #1
 2396 0b9a FB60     		str	r3, [r7, #12]
 2397 0b9c 01E0     		b	.L150
 2398              	.L149:
2361:FreeRTOS/Source/queue.c **** 	}
2362:FreeRTOS/Source/queue.c **** 	else
2363:FreeRTOS/Source/queue.c **** 	{
2364:FreeRTOS/Source/queue.c **** 		xReturn = pdFALSE;
 2399              		.loc 1 2364 0
 2400 0b9e 0023     		movs	r3, #0
 2401 0ba0 FB60     		str	r3, [r7, #12]
 2402              	.L150:
2365:FreeRTOS/Source/queue.c **** 	}
2366:FreeRTOS/Source/queue.c **** 
2367:FreeRTOS/Source/queue.c **** 	return xReturn;
 2403              		.loc 1 2367 0
 2404 0ba2 FB68     		ldr	r3, [r7, #12]
2368:FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2405              		.loc 1 2368 0
 2406 0ba4 1846     		mov	r0, r3
 2407 0ba6 1437     		adds	r7, r7, #20
ARM GAS  /tmp/ccdqkONZ.s 			page 89


 2408              		.cfi_def_cfa_offset 4
 2409 0ba8 BD46     		mov	sp, r7
 2410              		.cfi_def_cfa_register 13
 2411              		@ sp needed
 2412 0baa 80BC     		pop	{r7}
 2413              		.cfi_restore 7
 2414              		.cfi_def_cfa_offset 0
 2415 0bac 7047     		bx	lr
 2416              		.cfi_endproc
 2417              	.LFE26:
 2418              		.size	xQueueIsQueueFullFromISR, .-xQueueIsQueueFullFromISR
 2419              	.Letext0:
 2420              		.file 3 "/usr/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 2421              		.file 4 "/usr/include/newlib/machine/_default_types.h"
 2422              		.file 5 "/usr/include/newlib/sys/lock.h"
 2423              		.file 6 "/usr/include/newlib/sys/_types.h"
 2424              		.file 7 "/usr/include/newlib/sys/reent.h"
 2425              		.file 8 "/usr/include/newlib/sys/_stdint.h"
 2426              		.file 9 "include/FreeRTOSConfig.h"
 2427              		.file 10 "FreeRTOS/Source/include/list.h"
 2428              		.file 11 "FreeRTOS/Source/include/task.h"
 2429              		.file 12 "FreeRTOS/Source/include/queue.h"
 2430 0bae 00BF     		.section	.debug_info,"",%progbits
 2431              	.Ldebug_info0:
 2432 0000 B9150000 		.4byte	0x15b9
 2433 0004 0400     		.2byte	0x4
 2434 0006 00000000 		.4byte	.Ldebug_abbrev0
 2435 000a 04       		.byte	0x4
 2436 000b 01       		.uleb128 0x1
 2437 000c 10000000 		.4byte	.LASF219
 2438 0010 0C       		.byte	0xc
 2439 0011 19030000 		.4byte	.LASF220
 2440 0015 C3050000 		.4byte	.LASF221
 2441 0019 00000000 		.4byte	.Ltext0
 2442 001d AE0B0000 		.4byte	.Letext0-.Ltext0
 2443 0021 00000000 		.4byte	.Ldebug_line0
 2444 0025 02       		.uleb128 0x2
 2445 0026 BC030000 		.4byte	.LASF1
 2446 002a 03       		.byte	0x3
 2447 002b D8       		.byte	0xd8
 2448 002c 30000000 		.4byte	0x30
 2449 0030 03       		.uleb128 0x3
 2450 0031 04       		.byte	0x4
 2451 0032 07       		.byte	0x7
 2452 0033 0A010000 		.4byte	.LASF0
 2453 0037 04       		.uleb128 0x4
 2454 0038 04       		.byte	0x4
 2455 0039 05       		.byte	0x5
 2456 003a 696E7400 		.ascii	"int\000"
 2457 003e 02       		.uleb128 0x2
 2458 003f 3F070000 		.4byte	.LASF2
 2459 0043 04       		.byte	0x4
 2460 0044 1B       		.byte	0x1b
 2461 0045 49000000 		.4byte	0x49
 2462 0049 03       		.uleb128 0x3
 2463 004a 01       		.byte	0x1
 2464 004b 06       		.byte	0x6
ARM GAS  /tmp/ccdqkONZ.s 			page 90


 2465 004c 060A0000 		.4byte	.LASF3
 2466 0050 02       		.uleb128 0x2
 2467 0051 77080000 		.4byte	.LASF4
 2468 0055 04       		.byte	0x4
 2469 0056 1D       		.byte	0x1d
 2470 0057 5B000000 		.4byte	0x5b
 2471 005b 03       		.uleb128 0x3
 2472 005c 01       		.byte	0x1
 2473 005d 08       		.byte	0x8
 2474 005e 45090000 		.4byte	.LASF5
 2475 0062 03       		.uleb128 0x3
 2476 0063 02       		.byte	0x2
 2477 0064 05       		.byte	0x5
 2478 0065 AC070000 		.4byte	.LASF6
 2479 0069 03       		.uleb128 0x3
 2480 006a 02       		.byte	0x2
 2481 006b 07       		.byte	0x7
 2482 006c 190A0000 		.4byte	.LASF7
 2483 0070 03       		.uleb128 0x3
 2484 0071 04       		.byte	0x4
 2485 0072 05       		.byte	0x5
 2486 0073 C1070000 		.4byte	.LASF8
 2487 0077 02       		.uleb128 0x2
 2488 0078 53090000 		.4byte	.LASF9
 2489 007c 04       		.byte	0x4
 2490 007d 41       		.byte	0x41
 2491 007e 82000000 		.4byte	0x82
 2492 0082 03       		.uleb128 0x3
 2493 0083 04       		.byte	0x4
 2494 0084 07       		.byte	0x7
 2495 0085 D7080000 		.4byte	.LASF10
 2496 0089 03       		.uleb128 0x3
 2497 008a 08       		.byte	0x8
 2498 008b 05       		.byte	0x5
 2499 008c 02060000 		.4byte	.LASF11
 2500 0090 03       		.uleb128 0x3
 2501 0091 08       		.byte	0x8
 2502 0092 07       		.byte	0x7
 2503 0093 02030000 		.4byte	.LASF12
 2504 0097 02       		.uleb128 0x2
 2505 0098 85010000 		.4byte	.LASF13
 2506 009c 05       		.byte	0x5
 2507 009d 07       		.byte	0x7
 2508 009e 37000000 		.4byte	0x37
 2509 00a2 02       		.uleb128 0x2
 2510 00a3 420A0000 		.4byte	.LASF14
 2511 00a7 06       		.byte	0x6
 2512 00a8 2C       		.byte	0x2c
 2513 00a9 70000000 		.4byte	0x70
 2514 00ad 02       		.uleb128 0x2
 2515 00ae E1010000 		.4byte	.LASF15
 2516 00b2 06       		.byte	0x6
 2517 00b3 72       		.byte	0x72
 2518 00b4 70000000 		.4byte	0x70
 2519 00b8 05       		.uleb128 0x5
 2520 00b9 F0080000 		.4byte	.LASF16
 2521 00bd 03       		.byte	0x3
ARM GAS  /tmp/ccdqkONZ.s 			page 91


 2522 00be 6501     		.2byte	0x165
 2523 00c0 30000000 		.4byte	0x30
 2524 00c4 06       		.uleb128 0x6
 2525 00c5 04       		.byte	0x4
 2526 00c6 06       		.byte	0x6
 2527 00c7 A6       		.byte	0xa6
 2528 00c8 E3000000 		.4byte	0xe3
 2529 00cc 07       		.uleb128 0x7
 2530 00cd 79050000 		.4byte	.LASF17
 2531 00d1 06       		.byte	0x6
 2532 00d2 A8       		.byte	0xa8
 2533 00d3 B8000000 		.4byte	0xb8
 2534 00d7 07       		.uleb128 0x7
 2535 00d8 FD070000 		.4byte	.LASF18
 2536 00dc 06       		.byte	0x6
 2537 00dd A9       		.byte	0xa9
 2538 00de E3000000 		.4byte	0xe3
 2539 00e2 00       		.byte	0
 2540 00e3 08       		.uleb128 0x8
 2541 00e4 5B000000 		.4byte	0x5b
 2542 00e8 F3000000 		.4byte	0xf3
 2543 00ec 09       		.uleb128 0x9
 2544 00ed F3000000 		.4byte	0xf3
 2545 00f1 03       		.byte	0x3
 2546 00f2 00       		.byte	0
 2547 00f3 03       		.uleb128 0x3
 2548 00f4 04       		.byte	0x4
 2549 00f5 07       		.byte	0x7
 2550 00f6 CE080000 		.4byte	.LASF19
 2551 00fa 0A       		.uleb128 0xa
 2552 00fb 08       		.byte	0x8
 2553 00fc 06       		.byte	0x6
 2554 00fd A3       		.byte	0xa3
 2555 00fe 1B010000 		.4byte	0x11b
 2556 0102 0B       		.uleb128 0xb
 2557 0103 9B020000 		.4byte	.LASF20
 2558 0107 06       		.byte	0x6
 2559 0108 A5       		.byte	0xa5
 2560 0109 37000000 		.4byte	0x37
 2561 010d 00       		.byte	0
 2562 010e 0B       		.uleb128 0xb
 2563 010f 67040000 		.4byte	.LASF21
 2564 0113 06       		.byte	0x6
 2565 0114 AA       		.byte	0xaa
 2566 0115 C4000000 		.4byte	0xc4
 2567 0119 04       		.byte	0x4
 2568 011a 00       		.byte	0
 2569 011b 02       		.uleb128 0x2
 2570 011c 9C060000 		.4byte	.LASF22
 2571 0120 06       		.byte	0x6
 2572 0121 AB       		.byte	0xab
 2573 0122 FA000000 		.4byte	0xfa
 2574 0126 02       		.uleb128 0x2
 2575 0127 43050000 		.4byte	.LASF23
 2576 012b 06       		.byte	0x6
 2577 012c AF       		.byte	0xaf
 2578 012d 97000000 		.4byte	0x97
ARM GAS  /tmp/ccdqkONZ.s 			page 92


 2579 0131 0C       		.uleb128 0xc
 2580 0132 04       		.byte	0x4
 2581 0133 0D       		.uleb128 0xd
 2582 0134 31010000 		.4byte	0x131
 2583 0138 0E       		.uleb128 0xe
 2584 0139 04       		.byte	0x4
 2585 013a 3E010000 		.4byte	0x13e
 2586 013e 03       		.uleb128 0x3
 2587 013f 01       		.byte	0x1
 2588 0140 08       		.byte	0x8
 2589 0141 B7040000 		.4byte	.LASF24
 2590 0145 0D       		.uleb128 0xd
 2591 0146 3E010000 		.4byte	0x13e
 2592 014a 02       		.uleb128 0x2
 2593 014b 35060000 		.4byte	.LASF25
 2594 014f 07       		.byte	0x7
 2595 0150 16       		.byte	0x16
 2596 0151 82000000 		.4byte	0x82
 2597 0155 0F       		.uleb128 0xf
 2598 0156 07020000 		.4byte	.LASF30
 2599 015a 18       		.byte	0x18
 2600 015b 07       		.byte	0x7
 2601 015c 2D       		.byte	0x2d
 2602 015d A8010000 		.4byte	0x1a8
 2603 0161 0B       		.uleb128 0xb
 2604 0162 12040000 		.4byte	.LASF26
 2605 0166 07       		.byte	0x7
 2606 0167 2F       		.byte	0x2f
 2607 0168 A8010000 		.4byte	0x1a8
 2608 016c 00       		.byte	0
 2609 016d 10       		.uleb128 0x10
 2610 016e 5F6B00   		.ascii	"_k\000"
 2611 0171 07       		.byte	0x7
 2612 0172 30       		.byte	0x30
 2613 0173 37000000 		.4byte	0x37
 2614 0177 04       		.byte	0x4
 2615 0178 0B       		.uleb128 0xb
 2616 0179 8E080000 		.4byte	.LASF27
 2617 017d 07       		.byte	0x7
 2618 017e 30       		.byte	0x30
 2619 017f 37000000 		.4byte	0x37
 2620 0183 08       		.byte	0x8
 2621 0184 0B       		.uleb128 0xb
 2622 0185 E1070000 		.4byte	.LASF28
 2623 0189 07       		.byte	0x7
 2624 018a 30       		.byte	0x30
 2625 018b 37000000 		.4byte	0x37
 2626 018f 0C       		.byte	0xc
 2627 0190 0B       		.uleb128 0xb
 2628 0191 46030000 		.4byte	.LASF29
 2629 0195 07       		.byte	0x7
 2630 0196 30       		.byte	0x30
 2631 0197 37000000 		.4byte	0x37
 2632 019b 10       		.byte	0x10
 2633 019c 10       		.uleb128 0x10
 2634 019d 5F7800   		.ascii	"_x\000"
 2635 01a0 07       		.byte	0x7
ARM GAS  /tmp/ccdqkONZ.s 			page 93


 2636 01a1 31       		.byte	0x31
 2637 01a2 AE010000 		.4byte	0x1ae
 2638 01a6 14       		.byte	0x14
 2639 01a7 00       		.byte	0
 2640 01a8 0E       		.uleb128 0xe
 2641 01a9 04       		.byte	0x4
 2642 01aa 55010000 		.4byte	0x155
 2643 01ae 08       		.uleb128 0x8
 2644 01af 4A010000 		.4byte	0x14a
 2645 01b3 BE010000 		.4byte	0x1be
 2646 01b7 09       		.uleb128 0x9
 2647 01b8 F3000000 		.4byte	0xf3
 2648 01bc 00       		.byte	0
 2649 01bd 00       		.byte	0
 2650 01be 0F       		.uleb128 0xf
 2651 01bf C3080000 		.4byte	.LASF31
 2652 01c3 24       		.byte	0x24
 2653 01c4 07       		.byte	0x7
 2654 01c5 35       		.byte	0x35
 2655 01c6 37020000 		.4byte	0x237
 2656 01ca 0B       		.uleb128 0xb
 2657 01cb DF030000 		.4byte	.LASF32
 2658 01cf 07       		.byte	0x7
 2659 01d0 37       		.byte	0x37
 2660 01d1 37000000 		.4byte	0x37
 2661 01d5 00       		.byte	0
 2662 01d6 0B       		.uleb128 0xb
 2663 01d7 C4020000 		.4byte	.LASF33
 2664 01db 07       		.byte	0x7
 2665 01dc 38       		.byte	0x38
 2666 01dd 37000000 		.4byte	0x37
 2667 01e1 04       		.byte	0x4
 2668 01e2 0B       		.uleb128 0xb
 2669 01e3 69020000 		.4byte	.LASF34
 2670 01e7 07       		.byte	0x7
 2671 01e8 39       		.byte	0x39
 2672 01e9 37000000 		.4byte	0x37
 2673 01ed 08       		.byte	0x8
 2674 01ee 0B       		.uleb128 0xb
 2675 01ef BC040000 		.4byte	.LASF35
 2676 01f3 07       		.byte	0x7
 2677 01f4 3A       		.byte	0x3a
 2678 01f5 37000000 		.4byte	0x37
 2679 01f9 0C       		.byte	0xc
 2680 01fa 0B       		.uleb128 0xb
 2681 01fb 56070000 		.4byte	.LASF36
 2682 01ff 07       		.byte	0x7
 2683 0200 3B       		.byte	0x3b
 2684 0201 37000000 		.4byte	0x37
 2685 0205 10       		.byte	0x10
 2686 0206 0B       		.uleb128 0xb
 2687 0207 17080000 		.4byte	.LASF37
 2688 020b 07       		.byte	0x7
 2689 020c 3C       		.byte	0x3c
 2690 020d 37000000 		.4byte	0x37
 2691 0211 14       		.byte	0x14
 2692 0212 0B       		.uleb128 0xb
ARM GAS  /tmp/ccdqkONZ.s 			page 94


 2693 0213 0F020000 		.4byte	.LASF38
 2694 0217 07       		.byte	0x7
 2695 0218 3D       		.byte	0x3d
 2696 0219 37000000 		.4byte	0x37
 2697 021d 18       		.byte	0x18
 2698 021e 0B       		.uleb128 0xb
 2699 021f E8030000 		.4byte	.LASF39
 2700 0223 07       		.byte	0x7
 2701 0224 3E       		.byte	0x3e
 2702 0225 37000000 		.4byte	0x37
 2703 0229 1C       		.byte	0x1c
 2704 022a 0B       		.uleb128 0xb
 2705 022b B1060000 		.4byte	.LASF40
 2706 022f 07       		.byte	0x7
 2707 0230 3F       		.byte	0x3f
 2708 0231 37000000 		.4byte	0x37
 2709 0235 20       		.byte	0x20
 2710 0236 00       		.byte	0
 2711 0237 11       		.uleb128 0x11
 2712 0238 57000000 		.4byte	.LASF41
 2713 023c 0801     		.2byte	0x108
 2714 023e 07       		.byte	0x7
 2715 023f 48       		.byte	0x48
 2716 0240 77020000 		.4byte	0x277
 2717 0244 0B       		.uleb128 0xb
 2718 0245 E4090000 		.4byte	.LASF42
 2719 0249 07       		.byte	0x7
 2720 024a 49       		.byte	0x49
 2721 024b 77020000 		.4byte	0x277
 2722 024f 00       		.byte	0
 2723 0250 0B       		.uleb128 0xb
 2724 0251 1E090000 		.4byte	.LASF43
 2725 0255 07       		.byte	0x7
 2726 0256 4A       		.byte	0x4a
 2727 0257 77020000 		.4byte	0x277
 2728 025b 80       		.byte	0x80
 2729 025c 12       		.uleb128 0x12
 2730 025d 330A0000 		.4byte	.LASF44
 2731 0261 07       		.byte	0x7
 2732 0262 4C       		.byte	0x4c
 2733 0263 4A010000 		.4byte	0x14a
 2734 0267 0001     		.2byte	0x100
 2735 0269 12       		.uleb128 0x12
 2736 026a 640A0000 		.4byte	.LASF45
 2737 026e 07       		.byte	0x7
 2738 026f 4F       		.byte	0x4f
 2739 0270 4A010000 		.4byte	0x14a
 2740 0274 0401     		.2byte	0x104
 2741 0276 00       		.byte	0
 2742 0277 08       		.uleb128 0x8
 2743 0278 31010000 		.4byte	0x131
 2744 027c 87020000 		.4byte	0x287
 2745 0280 09       		.uleb128 0x9
 2746 0281 F3000000 		.4byte	0xf3
 2747 0285 1F       		.byte	0x1f
 2748 0286 00       		.byte	0
 2749 0287 11       		.uleb128 0x11
ARM GAS  /tmp/ccdqkONZ.s 			page 95


 2750 0288 82070000 		.4byte	.LASF46
 2751 028c 9001     		.2byte	0x190
 2752 028e 07       		.byte	0x7
 2753 028f 5B       		.byte	0x5b
 2754 0290 C5020000 		.4byte	0x2c5
 2755 0294 0B       		.uleb128 0xb
 2756 0295 12040000 		.4byte	.LASF26
 2757 0299 07       		.byte	0x7
 2758 029a 5C       		.byte	0x5c
 2759 029b C5020000 		.4byte	0x2c5
 2760 029f 00       		.byte	0
 2761 02a0 0B       		.uleb128 0xb
 2762 02a1 F7030000 		.4byte	.LASF47
 2763 02a5 07       		.byte	0x7
 2764 02a6 5D       		.byte	0x5d
 2765 02a7 37000000 		.4byte	0x37
 2766 02ab 04       		.byte	0x4
 2767 02ac 0B       		.uleb128 0xb
 2768 02ad F1010000 		.4byte	.LASF48
 2769 02b1 07       		.byte	0x7
 2770 02b2 5F       		.byte	0x5f
 2771 02b3 CB020000 		.4byte	0x2cb
 2772 02b7 08       		.byte	0x8
 2773 02b8 0B       		.uleb128 0xb
 2774 02b9 57000000 		.4byte	.LASF41
 2775 02bd 07       		.byte	0x7
 2776 02be 60       		.byte	0x60
 2777 02bf 37020000 		.4byte	0x237
 2778 02c3 88       		.byte	0x88
 2779 02c4 00       		.byte	0
 2780 02c5 0E       		.uleb128 0xe
 2781 02c6 04       		.byte	0x4
 2782 02c7 87020000 		.4byte	0x287
 2783 02cb 08       		.uleb128 0x8
 2784 02cc DB020000 		.4byte	0x2db
 2785 02d0 DB020000 		.4byte	0x2db
 2786 02d4 09       		.uleb128 0x9
 2787 02d5 F3000000 		.4byte	0xf3
 2788 02d9 1F       		.byte	0x1f
 2789 02da 00       		.byte	0
 2790 02db 0E       		.uleb128 0xe
 2791 02dc 04       		.byte	0x4
 2792 02dd E1020000 		.4byte	0x2e1
 2793 02e1 13       		.uleb128 0x13
 2794 02e2 0F       		.uleb128 0xf
 2795 02e3 9A090000 		.4byte	.LASF49
 2796 02e7 08       		.byte	0x8
 2797 02e8 07       		.byte	0x7
 2798 02e9 73       		.byte	0x73
 2799 02ea 07030000 		.4byte	0x307
 2800 02ee 0B       		.uleb128 0xb
 2801 02ef 1F060000 		.4byte	.LASF50
 2802 02f3 07       		.byte	0x7
 2803 02f4 74       		.byte	0x74
 2804 02f5 07030000 		.4byte	0x307
 2805 02f9 00       		.byte	0
 2806 02fa 0B       		.uleb128 0xb
ARM GAS  /tmp/ccdqkONZ.s 			page 96


 2807 02fb 3C0A0000 		.4byte	.LASF51
 2808 02ff 07       		.byte	0x7
 2809 0300 75       		.byte	0x75
 2810 0301 37000000 		.4byte	0x37
 2811 0305 04       		.byte	0x4
 2812 0306 00       		.byte	0
 2813 0307 0E       		.uleb128 0xe
 2814 0308 04       		.byte	0x4
 2815 0309 5B000000 		.4byte	0x5b
 2816 030d 0F       		.uleb128 0xf
 2817 030e 3E030000 		.4byte	.LASF52
 2818 0312 68       		.byte	0x68
 2819 0313 07       		.byte	0x7
 2820 0314 B3       		.byte	0xb3
 2821 0315 37040000 		.4byte	0x437
 2822 0319 10       		.uleb128 0x10
 2823 031a 5F7000   		.ascii	"_p\000"
 2824 031d 07       		.byte	0x7
 2825 031e B4       		.byte	0xb4
 2826 031f 07030000 		.4byte	0x307
 2827 0323 00       		.byte	0
 2828 0324 10       		.uleb128 0x10
 2829 0325 5F7200   		.ascii	"_r\000"
 2830 0328 07       		.byte	0x7
 2831 0329 B5       		.byte	0xb5
 2832 032a 37000000 		.4byte	0x37
 2833 032e 04       		.byte	0x4
 2834 032f 10       		.uleb128 0x10
 2835 0330 5F7700   		.ascii	"_w\000"
 2836 0333 07       		.byte	0x7
 2837 0334 B6       		.byte	0xb6
 2838 0335 37000000 		.4byte	0x37
 2839 0339 08       		.byte	0x8
 2840 033a 0B       		.uleb128 0xb
 2841 033b 32010000 		.4byte	.LASF53
 2842 033f 07       		.byte	0x7
 2843 0340 B7       		.byte	0xb7
 2844 0341 62000000 		.4byte	0x62
 2845 0345 0C       		.byte	0xc
 2846 0346 0B       		.uleb128 0xb
 2847 0347 67060000 		.4byte	.LASF54
 2848 034b 07       		.byte	0x7
 2849 034c B8       		.byte	0xb8
 2850 034d 62000000 		.4byte	0x62
 2851 0351 0E       		.byte	0xe
 2852 0352 10       		.uleb128 0x10
 2853 0353 5F626600 		.ascii	"_bf\000"
 2854 0357 07       		.byte	0x7
 2855 0358 B9       		.byte	0xb9
 2856 0359 E2020000 		.4byte	0x2e2
 2857 035d 10       		.byte	0x10
 2858 035e 0B       		.uleb128 0xb
 2859 035f 29010000 		.4byte	.LASF55
 2860 0363 07       		.byte	0x7
 2861 0364 BA       		.byte	0xba
 2862 0365 37000000 		.4byte	0x37
 2863 0369 18       		.byte	0x18
ARM GAS  /tmp/ccdqkONZ.s 			page 97


 2864 036a 0B       		.uleb128 0xb
 2865 036b F6010000 		.4byte	.LASF56
 2866 036f 07       		.byte	0x7
 2867 0370 C1       		.byte	0xc1
 2868 0371 31010000 		.4byte	0x131
 2869 0375 1C       		.byte	0x1c
 2870 0376 0B       		.uleb128 0xb
 2871 0377 AE010000 		.4byte	.LASF57
 2872 037b 07       		.byte	0x7
 2873 037c C3       		.byte	0xc3
 2874 037d 92050000 		.4byte	0x592
 2875 0381 20       		.byte	0x20
 2876 0382 0B       		.uleb128 0xb
 2877 0383 6F070000 		.4byte	.LASF58
 2878 0387 07       		.byte	0x7
 2879 0388 C5       		.byte	0xc5
 2880 0389 BC050000 		.4byte	0x5bc
 2881 038d 24       		.byte	0x24
 2882 038e 0B       		.uleb128 0xb
 2883 038f 7D0A0000 		.4byte	.LASF59
 2884 0393 07       		.byte	0x7
 2885 0394 C8       		.byte	0xc8
 2886 0395 E0050000 		.4byte	0x5e0
 2887 0399 28       		.byte	0x28
 2888 039a 0B       		.uleb128 0xb
 2889 039b 8D050000 		.4byte	.LASF60
 2890 039f 07       		.byte	0x7
 2891 03a0 C9       		.byte	0xc9
 2892 03a1 FA050000 		.4byte	0x5fa
 2893 03a5 2C       		.byte	0x2c
 2894 03a6 10       		.uleb128 0x10
 2895 03a7 5F756200 		.ascii	"_ub\000"
 2896 03ab 07       		.byte	0x7
 2897 03ac CC       		.byte	0xcc
 2898 03ad E2020000 		.4byte	0x2e2
 2899 03b1 30       		.byte	0x30
 2900 03b2 10       		.uleb128 0x10
 2901 03b3 5F757000 		.ascii	"_up\000"
 2902 03b7 07       		.byte	0x7
 2903 03b8 CD       		.byte	0xcd
 2904 03b9 07030000 		.4byte	0x307
 2905 03bd 38       		.byte	0x38
 2906 03be 10       		.uleb128 0x10
 2907 03bf 5F757200 		.ascii	"_ur\000"
 2908 03c3 07       		.byte	0x7
 2909 03c4 CE       		.byte	0xce
 2910 03c5 37000000 		.4byte	0x37
 2911 03c9 3C       		.byte	0x3c
 2912 03ca 0B       		.uleb128 0xb
 2913 03cb 940A0000 		.4byte	.LASF61
 2914 03cf 07       		.byte	0x7
 2915 03d0 D1       		.byte	0xd1
 2916 03d1 00060000 		.4byte	0x600
 2917 03d5 40       		.byte	0x40
 2918 03d6 0B       		.uleb128 0xb
 2919 03d7 490A0000 		.4byte	.LASF62
 2920 03db 07       		.byte	0x7
ARM GAS  /tmp/ccdqkONZ.s 			page 98


 2921 03dc D2       		.byte	0xd2
 2922 03dd 10060000 		.4byte	0x610
 2923 03e1 43       		.byte	0x43
 2924 03e2 10       		.uleb128 0x10
 2925 03e3 5F6C6200 		.ascii	"_lb\000"
 2926 03e7 07       		.byte	0x7
 2927 03e8 D5       		.byte	0xd5
 2928 03e9 E2020000 		.4byte	0x2e2
 2929 03ed 44       		.byte	0x44
 2930 03ee 0B       		.uleb128 0xb
 2931 03ef BA080000 		.4byte	.LASF63
 2932 03f3 07       		.byte	0x7
 2933 03f4 D8       		.byte	0xd8
 2934 03f5 37000000 		.4byte	0x37
 2935 03f9 4C       		.byte	0x4c
 2936 03fa 0B       		.uleb128 0xb
 2937 03fb 83030000 		.4byte	.LASF64
 2938 03ff 07       		.byte	0x7
 2939 0400 D9       		.byte	0xd9
 2940 0401 A2000000 		.4byte	0xa2
 2941 0405 50       		.byte	0x50
 2942 0406 0B       		.uleb128 0xb
 2943 0407 F7070000 		.4byte	.LASF65
 2944 040b 07       		.byte	0x7
 2945 040c DC       		.byte	0xdc
 2946 040d 55040000 		.4byte	0x455
 2947 0411 54       		.byte	0x54
 2948 0412 0B       		.uleb128 0xb
 2949 0413 C8080000 		.4byte	.LASF66
 2950 0417 07       		.byte	0x7
 2951 0418 E0       		.byte	0xe0
 2952 0419 26010000 		.4byte	0x126
 2953 041d 58       		.byte	0x58
 2954 041e 0B       		.uleb128 0xb
 2955 041f 8A070000 		.4byte	.LASF67
 2956 0423 07       		.byte	0x7
 2957 0424 E2       		.byte	0xe2
 2958 0425 1B010000 		.4byte	0x11b
 2959 0429 5C       		.byte	0x5c
 2960 042a 0B       		.uleb128 0xb
 2961 042b 5C0A0000 		.4byte	.LASF68
 2962 042f 07       		.byte	0x7
 2963 0430 E3       		.byte	0xe3
 2964 0431 37000000 		.4byte	0x37
 2965 0435 64       		.byte	0x64
 2966 0436 00       		.byte	0
 2967 0437 14       		.uleb128 0x14
 2968 0438 37000000 		.4byte	0x37
 2969 043c 55040000 		.4byte	0x455
 2970 0440 15       		.uleb128 0x15
 2971 0441 55040000 		.4byte	0x455
 2972 0445 15       		.uleb128 0x15
 2973 0446 31010000 		.4byte	0x131
 2974 044a 15       		.uleb128 0x15
 2975 044b 38010000 		.4byte	0x138
 2976 044f 15       		.uleb128 0x15
 2977 0450 37000000 		.4byte	0x37
ARM GAS  /tmp/ccdqkONZ.s 			page 99


 2978 0454 00       		.byte	0
 2979 0455 0E       		.uleb128 0xe
 2980 0456 04       		.byte	0x4
 2981 0457 60040000 		.4byte	0x460
 2982 045b 0D       		.uleb128 0xd
 2983 045c 55040000 		.4byte	0x455
 2984 0460 16       		.uleb128 0x16
 2985 0461 120A0000 		.4byte	.LASF69
 2986 0465 2804     		.2byte	0x428
 2987 0467 07       		.byte	0x7
 2988 0468 3802     		.2byte	0x238
 2989 046a 92050000 		.4byte	0x592
 2990 046e 17       		.uleb128 0x17
 2991 046f 51010000 		.4byte	.LASF70
 2992 0473 07       		.byte	0x7
 2993 0474 3A02     		.2byte	0x23a
 2994 0476 37000000 		.4byte	0x37
 2995 047a 00       		.byte	0
 2996 047b 17       		.uleb128 0x17
 2997 047c 82020000 		.4byte	.LASF71
 2998 0480 07       		.byte	0x7
 2999 0481 3F02     		.2byte	0x23f
 3000 0483 67060000 		.4byte	0x667
 3001 0487 04       		.byte	0x4
 3002 0488 17       		.uleb128 0x17
 3003 0489 D9010000 		.4byte	.LASF72
 3004 048d 07       		.byte	0x7
 3005 048e 3F02     		.2byte	0x23f
 3006 0490 67060000 		.4byte	0x667
 3007 0494 08       		.byte	0x8
 3008 0495 17       		.uleb128 0x17
 3009 0496 830A0000 		.4byte	.LASF73
 3010 049a 07       		.byte	0x7
 3011 049b 3F02     		.2byte	0x23f
 3012 049d 67060000 		.4byte	0x667
 3013 04a1 0C       		.byte	0xc
 3014 04a2 17       		.uleb128 0x17
 3015 04a3 F2030000 		.4byte	.LASF74
 3016 04a7 07       		.byte	0x7
 3017 04a8 4102     		.2byte	0x241
 3018 04aa 37000000 		.4byte	0x37
 3019 04ae 10       		.byte	0x10
 3020 04af 17       		.uleb128 0x17
 3021 04b0 A3030000 		.4byte	.LASF75
 3022 04b4 07       		.byte	0x7
 3023 04b5 4202     		.2byte	0x242
 3024 04b7 49080000 		.4byte	0x849
 3025 04bb 14       		.byte	0x14
 3026 04bc 17       		.uleb128 0x17
 3027 04bd A8080000 		.4byte	.LASF76
 3028 04c1 07       		.byte	0x7
 3029 04c2 4402     		.2byte	0x244
 3030 04c4 37000000 		.4byte	0x37
 3031 04c8 30       		.byte	0x30
 3032 04c9 17       		.uleb128 0x17
 3033 04ca E7070000 		.4byte	.LASF77
 3034 04ce 07       		.byte	0x7
ARM GAS  /tmp/ccdqkONZ.s 			page 100


 3035 04cf 4502     		.2byte	0x245
 3036 04d1 B6050000 		.4byte	0x5b6
 3037 04d5 34       		.byte	0x34
 3038 04d6 17       		.uleb128 0x17
 3039 04d7 94050000 		.4byte	.LASF78
 3040 04db 07       		.byte	0x7
 3041 04dc 4702     		.2byte	0x247
 3042 04de 37000000 		.4byte	0x37
 3043 04e2 38       		.byte	0x38
 3044 04e3 17       		.uleb128 0x17
 3045 04e4 84060000 		.4byte	.LASF79
 3046 04e8 07       		.byte	0x7
 3047 04e9 4902     		.2byte	0x249
 3048 04eb 64080000 		.4byte	0x864
 3049 04ef 3C       		.byte	0x3c
 3050 04f0 17       		.uleb128 0x17
 3051 04f1 24020000 		.4byte	.LASF80
 3052 04f5 07       		.byte	0x7
 3053 04f6 4C02     		.2byte	0x24c
 3054 04f8 A8010000 		.4byte	0x1a8
 3055 04fc 40       		.byte	0x40
 3056 04fd 17       		.uleb128 0x17
 3057 04fe F8020000 		.4byte	.LASF81
 3058 0502 07       		.byte	0x7
 3059 0503 4D02     		.2byte	0x24d
 3060 0505 37000000 		.4byte	0x37
 3061 0509 44       		.byte	0x44
 3062 050a 17       		.uleb128 0x17
 3063 050b 7A040000 		.4byte	.LASF82
 3064 050f 07       		.byte	0x7
 3065 0510 4E02     		.2byte	0x24e
 3066 0512 A8010000 		.4byte	0x1a8
 3067 0516 48       		.byte	0x48
 3068 0517 17       		.uleb128 0x17
 3069 0518 25060000 		.4byte	.LASF83
 3070 051c 07       		.byte	0x7
 3071 051d 4F02     		.2byte	0x24f
 3072 051f 6A080000 		.4byte	0x86a
 3073 0523 4C       		.byte	0x4c
 3074 0524 17       		.uleb128 0x17
 3075 0525 86080000 		.4byte	.LASF84
 3076 0529 07       		.byte	0x7
 3077 052a 5202     		.2byte	0x252
 3078 052c 37000000 		.4byte	0x37
 3079 0530 50       		.byte	0x50
 3080 0531 17       		.uleb128 0x17
 3081 0532 3D090000 		.4byte	.LASF85
 3082 0536 07       		.byte	0x7
 3083 0537 5302     		.2byte	0x253
 3084 0539 38010000 		.4byte	0x138
 3085 053d 54       		.byte	0x54
 3086 053e 17       		.uleb128 0x17
 3087 053f 81080000 		.4byte	.LASF86
 3088 0543 07       		.byte	0x7
 3089 0544 7602     		.2byte	0x276
 3090 0546 27080000 		.4byte	0x827
 3091 054a 58       		.byte	0x58
ARM GAS  /tmp/ccdqkONZ.s 			page 101


 3092 054b 18       		.uleb128 0x18
 3093 054c 82070000 		.4byte	.LASF46
 3094 0550 07       		.byte	0x7
 3095 0551 7A02     		.2byte	0x27a
 3096 0553 C5020000 		.4byte	0x2c5
 3097 0557 4801     		.2byte	0x148
 3098 0559 18       		.uleb128 0x18
 3099 055a EA040000 		.4byte	.LASF87
 3100 055e 07       		.byte	0x7
 3101 055f 7B02     		.2byte	0x27b
 3102 0561 87020000 		.4byte	0x287
 3103 0565 4C01     		.2byte	0x14c
 3104 0567 18       		.uleb128 0x18
 3105 0568 D1040000 		.4byte	.LASF88
 3106 056c 07       		.byte	0x7
 3107 056d 7F02     		.2byte	0x27f
 3108 056f 7B080000 		.4byte	0x87b
 3109 0573 DC02     		.2byte	0x2dc
 3110 0575 18       		.uleb128 0x18
 3111 0576 AE090000 		.4byte	.LASF89
 3112 057a 07       		.byte	0x7
 3113 057b 8402     		.2byte	0x284
 3114 057d 2C060000 		.4byte	0x62c
 3115 0581 E002     		.2byte	0x2e0
 3116 0583 18       		.uleb128 0x18
 3117 0584 DC070000 		.4byte	.LASF90
 3118 0588 07       		.byte	0x7
 3119 0589 8502     		.2byte	0x285
 3120 058b 87080000 		.4byte	0x887
 3121 058f EC02     		.2byte	0x2ec
 3122 0591 00       		.byte	0
 3123 0592 0E       		.uleb128 0xe
 3124 0593 04       		.byte	0x4
 3125 0594 37040000 		.4byte	0x437
 3126 0598 14       		.uleb128 0x14
 3127 0599 37000000 		.4byte	0x37
 3128 059d B6050000 		.4byte	0x5b6
 3129 05a1 15       		.uleb128 0x15
 3130 05a2 55040000 		.4byte	0x455
 3131 05a6 15       		.uleb128 0x15
 3132 05a7 31010000 		.4byte	0x131
 3133 05ab 15       		.uleb128 0x15
 3134 05ac B6050000 		.4byte	0x5b6
 3135 05b0 15       		.uleb128 0x15
 3136 05b1 37000000 		.4byte	0x37
 3137 05b5 00       		.byte	0
 3138 05b6 0E       		.uleb128 0xe
 3139 05b7 04       		.byte	0x4
 3140 05b8 45010000 		.4byte	0x145
 3141 05bc 0E       		.uleb128 0xe
 3142 05bd 04       		.byte	0x4
 3143 05be 98050000 		.4byte	0x598
 3144 05c2 14       		.uleb128 0x14
 3145 05c3 AD000000 		.4byte	0xad
 3146 05c7 E0050000 		.4byte	0x5e0
 3147 05cb 15       		.uleb128 0x15
 3148 05cc 55040000 		.4byte	0x455
ARM GAS  /tmp/ccdqkONZ.s 			page 102


 3149 05d0 15       		.uleb128 0x15
 3150 05d1 31010000 		.4byte	0x131
 3151 05d5 15       		.uleb128 0x15
 3152 05d6 AD000000 		.4byte	0xad
 3153 05da 15       		.uleb128 0x15
 3154 05db 37000000 		.4byte	0x37
 3155 05df 00       		.byte	0
 3156 05e0 0E       		.uleb128 0xe
 3157 05e1 04       		.byte	0x4
 3158 05e2 C2050000 		.4byte	0x5c2
 3159 05e6 14       		.uleb128 0x14
 3160 05e7 37000000 		.4byte	0x37
 3161 05eb FA050000 		.4byte	0x5fa
 3162 05ef 15       		.uleb128 0x15
 3163 05f0 55040000 		.4byte	0x455
 3164 05f4 15       		.uleb128 0x15
 3165 05f5 31010000 		.4byte	0x131
 3166 05f9 00       		.byte	0
 3167 05fa 0E       		.uleb128 0xe
 3168 05fb 04       		.byte	0x4
 3169 05fc E6050000 		.4byte	0x5e6
 3170 0600 08       		.uleb128 0x8
 3171 0601 5B000000 		.4byte	0x5b
 3172 0605 10060000 		.4byte	0x610
 3173 0609 09       		.uleb128 0x9
 3174 060a F3000000 		.4byte	0xf3
 3175 060e 02       		.byte	0x2
 3176 060f 00       		.byte	0
 3177 0610 08       		.uleb128 0x8
 3178 0611 5B000000 		.4byte	0x5b
 3179 0615 20060000 		.4byte	0x620
 3180 0619 09       		.uleb128 0x9
 3181 061a F3000000 		.4byte	0xf3
 3182 061e 00       		.byte	0
 3183 061f 00       		.byte	0
 3184 0620 05       		.uleb128 0x5
 3185 0621 7C030000 		.4byte	.LASF91
 3186 0625 07       		.byte	0x7
 3187 0626 1D01     		.2byte	0x11d
 3188 0628 0D030000 		.4byte	0x30d
 3189 062c 19       		.uleb128 0x19
 3190 062d A8090000 		.4byte	.LASF92
 3191 0631 0C       		.byte	0xc
 3192 0632 07       		.byte	0x7
 3193 0633 2101     		.2byte	0x121
 3194 0635 61060000 		.4byte	0x661
 3195 0639 17       		.uleb128 0x17
 3196 063a 12040000 		.4byte	.LASF26
 3197 063e 07       		.byte	0x7
 3198 063f 2301     		.2byte	0x123
 3199 0641 61060000 		.4byte	0x661
 3200 0645 00       		.byte	0
 3201 0646 17       		.uleb128 0x17
 3202 0647 E9080000 		.4byte	.LASF93
 3203 064b 07       		.byte	0x7
 3204 064c 2401     		.2byte	0x124
 3205 064e 37000000 		.4byte	0x37
ARM GAS  /tmp/ccdqkONZ.s 			page 103


 3206 0652 04       		.byte	0x4
 3207 0653 17       		.uleb128 0x17
 3208 0654 7F050000 		.4byte	.LASF94
 3209 0658 07       		.byte	0x7
 3210 0659 2501     		.2byte	0x125
 3211 065b 67060000 		.4byte	0x667
 3212 065f 08       		.byte	0x8
 3213 0660 00       		.byte	0
 3214 0661 0E       		.uleb128 0xe
 3215 0662 04       		.byte	0x4
 3216 0663 2C060000 		.4byte	0x62c
 3217 0667 0E       		.uleb128 0xe
 3218 0668 04       		.byte	0x4
 3219 0669 20060000 		.4byte	0x620
 3220 066d 19       		.uleb128 0x19
 3221 066e F0020000 		.4byte	.LASF95
 3222 0672 0E       		.byte	0xe
 3223 0673 07       		.byte	0x7
 3224 0674 3D01     		.2byte	0x13d
 3225 0676 A2060000 		.4byte	0x6a2
 3226 067a 17       		.uleb128 0x17
 3227 067b 6C0A0000 		.4byte	.LASF96
 3228 067f 07       		.byte	0x7
 3229 0680 3E01     		.2byte	0x13e
 3230 0682 A2060000 		.4byte	0x6a2
 3231 0686 00       		.byte	0
 3232 0687 17       		.uleb128 0x17
 3233 0688 2F060000 		.4byte	.LASF97
 3234 068c 07       		.byte	0x7
 3235 068d 3F01     		.2byte	0x13f
 3236 068f A2060000 		.4byte	0x6a2
 3237 0693 06       		.byte	0x6
 3238 0694 17       		.uleb128 0x17
 3239 0695 80090000 		.4byte	.LASF98
 3240 0699 07       		.byte	0x7
 3241 069a 4001     		.2byte	0x140
 3242 069c 69000000 		.4byte	0x69
 3243 06a0 0C       		.byte	0xc
 3244 06a1 00       		.byte	0
 3245 06a2 08       		.uleb128 0x8
 3246 06a3 69000000 		.4byte	0x69
 3247 06a7 B2060000 		.4byte	0x6b2
 3248 06ab 09       		.uleb128 0x9
 3249 06ac F3000000 		.4byte	0xf3
 3250 06b0 02       		.byte	0x2
 3251 06b1 00       		.byte	0
 3252 06b2 1A       		.uleb128 0x1a
 3253 06b3 D0       		.byte	0xd0
 3254 06b4 07       		.byte	0x7
 3255 06b5 5702     		.2byte	0x257
 3256 06b7 B3070000 		.4byte	0x7b3
 3257 06bb 17       		.uleb128 0x17
 3258 06bc 4F0A0000 		.4byte	.LASF99
 3259 06c0 07       		.byte	0x7
 3260 06c1 5902     		.2byte	0x259
 3261 06c3 30000000 		.4byte	0x30
 3262 06c7 00       		.byte	0
ARM GAS  /tmp/ccdqkONZ.s 			page 104


 3263 06c8 17       		.uleb128 0x17
 3264 06c9 B6090000 		.4byte	.LASF100
 3265 06cd 07       		.byte	0x7
 3266 06ce 5A02     		.2byte	0x25a
 3267 06d0 38010000 		.4byte	0x138
 3268 06d4 04       		.byte	0x4
 3269 06d5 17       		.uleb128 0x17
 3270 06d6 31030000 		.4byte	.LASF101
 3271 06da 07       		.byte	0x7
 3272 06db 5B02     		.2byte	0x25b
 3273 06dd B3070000 		.4byte	0x7b3
 3274 06e1 08       		.byte	0x8
 3275 06e2 17       		.uleb128 0x17
 3276 06e3 60080000 		.4byte	.LASF102
 3277 06e7 07       		.byte	0x7
 3278 06e8 5C02     		.2byte	0x25c
 3279 06ea BE010000 		.4byte	0x1be
 3280 06ee 24       		.byte	0x24
 3281 06ef 17       		.uleb128 0x17
 3282 06f0 E9050000 		.4byte	.LASF103
 3283 06f4 07       		.byte	0x7
 3284 06f5 5D02     		.2byte	0x25d
 3285 06f7 37000000 		.4byte	0x37
 3286 06fb 48       		.byte	0x48
 3287 06fc 17       		.uleb128 0x17
 3288 06fd 720A0000 		.4byte	.LASF104
 3289 0701 07       		.byte	0x7
 3290 0702 5E02     		.2byte	0x25e
 3291 0704 90000000 		.4byte	0x90
 3292 0708 50       		.byte	0x50
 3293 0709 17       		.uleb128 0x17
 3294 070a A5000000 		.4byte	.LASF105
 3295 070e 07       		.byte	0x7
 3296 070f 5F02     		.2byte	0x25f
 3297 0711 6D060000 		.4byte	0x66d
 3298 0715 58       		.byte	0x58
 3299 0716 17       		.uleb128 0x17
 3300 0717 AA040000 		.4byte	.LASF106
 3301 071b 07       		.byte	0x7
 3302 071c 6002     		.2byte	0x260
 3303 071e 1B010000 		.4byte	0x11b
 3304 0722 68       		.byte	0x68
 3305 0723 17       		.uleb128 0x17
 3306 0724 C3090000 		.4byte	.LASF107
 3307 0728 07       		.byte	0x7
 3308 0729 6102     		.2byte	0x261
 3309 072b 1B010000 		.4byte	0x11b
 3310 072f 70       		.byte	0x70
 3311 0730 17       		.uleb128 0x17
 3312 0731 73000000 		.4byte	.LASF108
 3313 0735 07       		.byte	0x7
 3314 0736 6202     		.2byte	0x262
 3315 0738 1B010000 		.4byte	0x11b
 3316 073c 78       		.byte	0x78
 3317 073d 17       		.uleb128 0x17
 3318 073e 96080000 		.4byte	.LASF109
 3319 0742 07       		.byte	0x7
ARM GAS  /tmp/ccdqkONZ.s 			page 105


 3320 0743 6302     		.2byte	0x263
 3321 0745 C3070000 		.4byte	0x7c3
 3322 0749 80       		.byte	0x80
 3323 074a 17       		.uleb128 0x17
 3324 074b FE000000 		.4byte	.LASF110
 3325 074f 07       		.byte	0x7
 3326 0750 6402     		.2byte	0x264
 3327 0752 D3070000 		.4byte	0x7d3
 3328 0756 88       		.byte	0x88
 3329 0757 17       		.uleb128 0x17
 3330 0758 73090000 		.4byte	.LASF111
 3331 075c 07       		.byte	0x7
 3332 075d 6502     		.2byte	0x265
 3333 075f 37000000 		.4byte	0x37
 3334 0763 A0       		.byte	0xa0
 3335 0764 17       		.uleb128 0x17
 3336 0765 BC010000 		.4byte	.LASF112
 3337 0769 07       		.byte	0x7
 3338 076a 6602     		.2byte	0x266
 3339 076c 1B010000 		.4byte	0x11b
 3340 0770 A4       		.byte	0xa4
 3341 0771 17       		.uleb128 0x17
 3342 0772 DB040000 		.4byte	.LASF113
 3343 0776 07       		.byte	0x7
 3344 0777 6702     		.2byte	0x267
 3345 0779 1B010000 		.4byte	0x11b
 3346 077d AC       		.byte	0xac
 3347 077e 17       		.uleb128 0x17
 3348 077f 18040000 		.4byte	.LASF114
 3349 0783 07       		.byte	0x7
 3350 0784 6802     		.2byte	0x268
 3351 0786 1B010000 		.4byte	0x11b
 3352 078a B4       		.byte	0xb4
 3353 078b 17       		.uleb128 0x17
 3354 078c 3D060000 		.4byte	.LASF115
 3355 0790 07       		.byte	0x7
 3356 0791 6902     		.2byte	0x269
 3357 0793 1B010000 		.4byte	0x11b
 3358 0797 BC       		.byte	0xbc
 3359 0798 17       		.uleb128 0x17
 3360 0799 99040000 		.4byte	.LASF116
 3361 079d 07       		.byte	0x7
 3362 079e 6A02     		.2byte	0x26a
 3363 07a0 1B010000 		.4byte	0x11b
 3364 07a4 C4       		.byte	0xc4
 3365 07a5 17       		.uleb128 0x17
 3366 07a6 EF060000 		.4byte	.LASF117
 3367 07aa 07       		.byte	0x7
 3368 07ab 6B02     		.2byte	0x26b
 3369 07ad 37000000 		.4byte	0x37
 3370 07b1 CC       		.byte	0xcc
 3371 07b2 00       		.byte	0
 3372 07b3 08       		.uleb128 0x8
 3373 07b4 3E010000 		.4byte	0x13e
 3374 07b8 C3070000 		.4byte	0x7c3
 3375 07bc 09       		.uleb128 0x9
 3376 07bd F3000000 		.4byte	0xf3
ARM GAS  /tmp/ccdqkONZ.s 			page 106


 3377 07c1 19       		.byte	0x19
 3378 07c2 00       		.byte	0
 3379 07c3 08       		.uleb128 0x8
 3380 07c4 3E010000 		.4byte	0x13e
 3381 07c8 D3070000 		.4byte	0x7d3
 3382 07cc 09       		.uleb128 0x9
 3383 07cd F3000000 		.4byte	0xf3
 3384 07d1 07       		.byte	0x7
 3385 07d2 00       		.byte	0
 3386 07d3 08       		.uleb128 0x8
 3387 07d4 3E010000 		.4byte	0x13e
 3388 07d8 E3070000 		.4byte	0x7e3
 3389 07dc 09       		.uleb128 0x9
 3390 07dd F3000000 		.4byte	0xf3
 3391 07e1 17       		.byte	0x17
 3392 07e2 00       		.byte	0
 3393 07e3 1A       		.uleb128 0x1a
 3394 07e4 F0       		.byte	0xf0
 3395 07e5 07       		.byte	0x7
 3396 07e6 7002     		.2byte	0x270
 3397 07e8 07080000 		.4byte	0x807
 3398 07ec 17       		.uleb128 0x17
 3399 07ed E9020000 		.4byte	.LASF118
 3400 07f1 07       		.byte	0x7
 3401 07f2 7302     		.2byte	0x273
 3402 07f4 07080000 		.4byte	0x807
 3403 07f8 00       		.byte	0
 3404 07f9 17       		.uleb128 0x17
 3405 07fa 8B0A0000 		.4byte	.LASF119
 3406 07fe 07       		.byte	0x7
 3407 07ff 7402     		.2byte	0x274
 3408 0801 17080000 		.4byte	0x817
 3409 0805 78       		.byte	0x78
 3410 0806 00       		.byte	0
 3411 0807 08       		.uleb128 0x8
 3412 0808 07030000 		.4byte	0x307
 3413 080c 17080000 		.4byte	0x817
 3414 0810 09       		.uleb128 0x9
 3415 0811 F3000000 		.4byte	0xf3
 3416 0815 1D       		.byte	0x1d
 3417 0816 00       		.byte	0
 3418 0817 08       		.uleb128 0x8
 3419 0818 30000000 		.4byte	0x30
 3420 081c 27080000 		.4byte	0x827
 3421 0820 09       		.uleb128 0x9
 3422 0821 F3000000 		.4byte	0xf3
 3423 0825 1D       		.byte	0x1d
 3424 0826 00       		.byte	0
 3425 0827 1B       		.uleb128 0x1b
 3426 0828 F0       		.byte	0xf0
 3427 0829 07       		.byte	0x7
 3428 082a 5502     		.2byte	0x255
 3429 082c 49080000 		.4byte	0x849
 3430 0830 1C       		.uleb128 0x1c
 3431 0831 120A0000 		.4byte	.LASF69
 3432 0835 07       		.byte	0x7
 3433 0836 6C02     		.2byte	0x26c
ARM GAS  /tmp/ccdqkONZ.s 			page 107


 3434 0838 B2060000 		.4byte	0x6b2
 3435 083c 1C       		.uleb128 0x1c
 3436 083d 6F080000 		.4byte	.LASF120
 3437 0841 07       		.byte	0x7
 3438 0842 7502     		.2byte	0x275
 3439 0844 E3070000 		.4byte	0x7e3
 3440 0848 00       		.byte	0
 3441 0849 08       		.uleb128 0x8
 3442 084a 3E010000 		.4byte	0x13e
 3443 084e 59080000 		.4byte	0x859
 3444 0852 09       		.uleb128 0x9
 3445 0853 F3000000 		.4byte	0xf3
 3446 0857 18       		.byte	0x18
 3447 0858 00       		.byte	0
 3448 0859 1D       		.uleb128 0x1d
 3449 085a 64080000 		.4byte	0x864
 3450 085e 15       		.uleb128 0x15
 3451 085f 55040000 		.4byte	0x455
 3452 0863 00       		.byte	0
 3453 0864 0E       		.uleb128 0xe
 3454 0865 04       		.byte	0x4
 3455 0866 59080000 		.4byte	0x859
 3456 086a 0E       		.uleb128 0xe
 3457 086b 04       		.byte	0x4
 3458 086c A8010000 		.4byte	0x1a8
 3459 0870 1D       		.uleb128 0x1d
 3460 0871 7B080000 		.4byte	0x87b
 3461 0875 15       		.uleb128 0x15
 3462 0876 37000000 		.4byte	0x37
 3463 087a 00       		.byte	0
 3464 087b 0E       		.uleb128 0xe
 3465 087c 04       		.byte	0x4
 3466 087d 81080000 		.4byte	0x881
 3467 0881 0E       		.uleb128 0xe
 3468 0882 04       		.byte	0x4
 3469 0883 70080000 		.4byte	0x870
 3470 0887 08       		.uleb128 0x8
 3471 0888 20060000 		.4byte	0x620
 3472 088c 97080000 		.4byte	0x897
 3473 0890 09       		.uleb128 0x9
 3474 0891 F3000000 		.4byte	0xf3
 3475 0895 02       		.byte	0x2
 3476 0896 00       		.byte	0
 3477 0897 1E       		.uleb128 0x1e
 3478 0898 CD020000 		.4byte	.LASF121
 3479 089c 07       		.byte	0x7
 3480 089d FD02     		.2byte	0x2fd
 3481 089f 55040000 		.4byte	0x455
 3482 08a3 1E       		.uleb128 0x1e
 3483 08a4 04080000 		.4byte	.LASF122
 3484 08a8 07       		.byte	0x7
 3485 08a9 FE02     		.2byte	0x2fe
 3486 08ab 5B040000 		.4byte	0x45b
 3487 08af 0E       		.uleb128 0xe
 3488 08b0 04       		.byte	0x4
 3489 08b1 BA080000 		.4byte	0x8ba
 3490 08b5 0D       		.uleb128 0xd
ARM GAS  /tmp/ccdqkONZ.s 			page 108


 3491 08b6 AF080000 		.4byte	0x8af
 3492 08ba 1F       		.uleb128 0x1f
 3493 08bb 02       		.uleb128 0x2
 3494 08bc 62020000 		.4byte	.LASF123
 3495 08c0 08       		.byte	0x8
 3496 08c1 14       		.byte	0x14
 3497 08c2 3E000000 		.4byte	0x3e
 3498 08c6 20       		.uleb128 0x20
 3499 08c7 BB080000 		.4byte	0x8bb
 3500 08cb 0D       		.uleb128 0xd
 3501 08cc BB080000 		.4byte	0x8bb
 3502 08d0 02       		.uleb128 0x2
 3503 08d1 85050000 		.4byte	.LASF124
 3504 08d5 08       		.byte	0x8
 3505 08d6 18       		.byte	0x18
 3506 08d7 50000000 		.4byte	0x50
 3507 08db 0D       		.uleb128 0xd
 3508 08dc D0080000 		.4byte	0x8d0
 3509 08e0 02       		.uleb128 0x2
 3510 08e1 59020000 		.4byte	.LASF125
 3511 08e5 08       		.byte	0x8
 3512 08e6 30       		.byte	0x30
 3513 08e7 77000000 		.4byte	0x77
 3514 08eb 21       		.uleb128 0x21
 3515 08ec 5F070000 		.4byte	.LASF126
 3516 08f0 09       		.byte	0x9
 3517 08f1 2B       		.byte	0x2b
 3518 08f2 E0080000 		.4byte	0x8e0
 3519 08f6 02       		.uleb128 0x2
 3520 08f7 4C060000 		.4byte	.LASF127
 3521 08fb 02       		.byte	0x2
 3522 08fc 38       		.byte	0x38
 3523 08fd 70000000 		.4byte	0x70
 3524 0901 0D       		.uleb128 0xd
 3525 0902 F6080000 		.4byte	0x8f6
 3526 0906 02       		.uleb128 0x2
 3527 0907 0E050000 		.4byte	.LASF128
 3528 090b 02       		.byte	0x2
 3529 090c 39       		.byte	0x39
 3530 090d 82000000 		.4byte	0x82
 3531 0911 20       		.uleb128 0x20
 3532 0912 06090000 		.4byte	0x906
 3533 0916 0D       		.uleb128 0xd
 3534 0917 06090000 		.4byte	0x906
 3535 091b 02       		.uleb128 0x2
 3536 091c 34070000 		.4byte	.LASF129
 3537 0920 02       		.byte	0x2
 3538 0921 3F       		.byte	0x3f
 3539 0922 E0080000 		.4byte	0x8e0
 3540 0926 0E       		.uleb128 0xe
 3541 0927 04       		.byte	0x4
 3542 0928 D0080000 		.4byte	0x8d0
 3543 092c 0F       		.uleb128 0xf
 3544 092d 46010000 		.4byte	.LASF130
 3545 0931 14       		.byte	0x14
 3546 0932 0A       		.byte	0xa
 3547 0933 8C       		.byte	0x8c
ARM GAS  /tmp/ccdqkONZ.s 			page 109


 3548 0934 75090000 		.4byte	0x975
 3549 0938 0B       		.uleb128 0xb
 3550 0939 B6070000 		.4byte	.LASF131
 3551 093d 0A       		.byte	0xa
 3552 093e 8F       		.byte	0x8f
 3553 093f 1B090000 		.4byte	0x91b
 3554 0943 00       		.byte	0
 3555 0944 0B       		.uleb128 0xb
 3556 0945 7D060000 		.4byte	.LASF132
 3557 0949 0A       		.byte	0xa
 3558 094a 90       		.byte	0x90
 3559 094b 75090000 		.4byte	0x975
 3560 094f 04       		.byte	0x4
 3561 0950 0B       		.uleb128 0xb
 3562 0951 54030000 		.4byte	.LASF133
 3563 0955 0A       		.byte	0xa
 3564 0956 91       		.byte	0x91
 3565 0957 75090000 		.4byte	0x975
 3566 095b 08       		.byte	0x8
 3567 095c 0B       		.uleb128 0xb
 3568 095d 92090000 		.4byte	.LASF134
 3569 0961 0A       		.byte	0xa
 3570 0962 92       		.byte	0x92
 3571 0963 31010000 		.4byte	0x131
 3572 0967 0C       		.byte	0xc
 3573 0968 0B       		.uleb128 0xb
 3574 0969 76070000 		.4byte	.LASF135
 3575 096d 0A       		.byte	0xa
 3576 096e 93       		.byte	0x93
 3577 096f AC090000 		.4byte	0x9ac
 3578 0973 10       		.byte	0x10
 3579 0974 00       		.byte	0
 3580 0975 0E       		.uleb128 0xe
 3581 0976 04       		.byte	0x4
 3582 0977 2C090000 		.4byte	0x92c
 3583 097b 0F       		.uleb128 0xf
 3584 097c FC030000 		.4byte	.LASF136
 3585 0980 14       		.byte	0x14
 3586 0981 0A       		.byte	0xa
 3587 0982 A4       		.byte	0xa4
 3588 0983 AC090000 		.4byte	0x9ac
 3589 0987 0B       		.uleb128 0xb
 3590 0988 00000000 		.4byte	.LASF137
 3591 098c 0A       		.byte	0xa
 3592 098d A7       		.byte	0xa7
 3593 098e 11090000 		.4byte	0x911
 3594 0992 00       		.byte	0
 3595 0993 0B       		.uleb128 0xb
 3596 0994 17010000 		.4byte	.LASF138
 3597 0998 0A       		.byte	0xa
 3598 0999 A8       		.byte	0xa8
 3599 099a F9090000 		.4byte	0x9f9
 3600 099e 04       		.byte	0x4
 3601 099f 0B       		.uleb128 0xb
 3602 09a0 3A050000 		.4byte	.LASF139
 3603 09a4 0A       		.byte	0xa
 3604 09a5 A9       		.byte	0xa9
ARM GAS  /tmp/ccdqkONZ.s 			page 110


 3605 09a6 EE090000 		.4byte	0x9ee
 3606 09aa 08       		.byte	0x8
 3607 09ab 00       		.byte	0
 3608 09ac 0E       		.uleb128 0xe
 3609 09ad 04       		.byte	0x4
 3610 09ae 7B090000 		.4byte	0x97b
 3611 09b2 02       		.uleb128 0x2
 3612 09b3 C6040000 		.4byte	.LASF140
 3613 09b7 0A       		.byte	0xa
 3614 09b8 96       		.byte	0x96
 3615 09b9 2C090000 		.4byte	0x92c
 3616 09bd 0F       		.uleb128 0xf
 3617 09be 02040000 		.4byte	.LASF141
 3618 09c2 0C       		.byte	0xc
 3619 09c3 0A       		.byte	0xa
 3620 09c4 98       		.byte	0x98
 3621 09c5 EE090000 		.4byte	0x9ee
 3622 09c9 0B       		.uleb128 0xb
 3623 09ca B6070000 		.4byte	.LASF131
 3624 09ce 0A       		.byte	0xa
 3625 09cf 9B       		.byte	0x9b
 3626 09d0 1B090000 		.4byte	0x91b
 3627 09d4 00       		.byte	0
 3628 09d5 0B       		.uleb128 0xb
 3629 09d6 7D060000 		.4byte	.LASF132
 3630 09da 0A       		.byte	0xa
 3631 09db 9C       		.byte	0x9c
 3632 09dc 75090000 		.4byte	0x975
 3633 09e0 04       		.byte	0x4
 3634 09e1 0B       		.uleb128 0xb
 3635 09e2 54030000 		.4byte	.LASF133
 3636 09e6 0A       		.byte	0xa
 3637 09e7 9D       		.byte	0x9d
 3638 09e8 75090000 		.4byte	0x975
 3639 09ec 08       		.byte	0x8
 3640 09ed 00       		.byte	0
 3641 09ee 02       		.uleb128 0x2
 3642 09ef 6A050000 		.4byte	.LASF142
 3643 09f3 0A       		.byte	0xa
 3644 09f4 9F       		.byte	0x9f
 3645 09f5 BD090000 		.4byte	0x9bd
 3646 09f9 0E       		.uleb128 0xe
 3647 09fa 04       		.byte	0x4
 3648 09fb B2090000 		.4byte	0x9b2
 3649 09ff 02       		.uleb128 0x2
 3650 0a00 12070000 		.4byte	.LASF143
 3651 0a04 0A       		.byte	0xa
 3652 0a05 AB       		.byte	0xab
 3653 0a06 7B090000 		.4byte	0x97b
 3654 0a0a 02       		.uleb128 0x2
 3655 0a0b D3060000 		.4byte	.LASF144
 3656 0a0f 0B       		.byte	0xb
 3657 0a10 46       		.byte	0x46
 3658 0a11 150A0000 		.4byte	0xa15
 3659 0a15 0E       		.uleb128 0xe
 3660 0a16 04       		.byte	0x4
 3661 0a17 1B0A0000 		.4byte	0xa1b
ARM GAS  /tmp/ccdqkONZ.s 			page 111


 3662 0a1b 22       		.uleb128 0x22
 3663 0a1c 81000000 		.4byte	.LASF222
 3664 0a20 0F       		.uleb128 0xf
 3665 0a21 1F010000 		.4byte	.LASF145
 3666 0a25 08       		.byte	0x8
 3667 0a26 0B       		.byte	0xb
 3668 0a27 66       		.byte	0x66
 3669 0a28 450A0000 		.4byte	0xa45
 3670 0a2c 0B       		.uleb128 0xb
 3671 0a2d CA010000 		.4byte	.LASF146
 3672 0a31 0B       		.byte	0xb
 3673 0a32 68       		.byte	0x68
 3674 0a33 F6080000 		.4byte	0x8f6
 3675 0a37 00       		.byte	0
 3676 0a38 0B       		.uleb128 0xb
 3677 0a39 6D060000 		.4byte	.LASF147
 3678 0a3d 0B       		.byte	0xb
 3679 0a3e 69       		.byte	0x69
 3680 0a3f 1B090000 		.4byte	0x91b
 3681 0a43 04       		.byte	0x4
 3682 0a44 00       		.byte	0
 3683 0a45 02       		.uleb128 0x2
 3684 0a46 A7060000 		.4byte	.LASF148
 3685 0a4a 0B       		.byte	0xb
 3686 0a4b 6A       		.byte	0x6a
 3687 0a4c 200A0000 		.4byte	0xa20
 3688 0a50 02       		.uleb128 0x2
 3689 0a51 2C050000 		.4byte	.LASF149
 3690 0a55 0C       		.byte	0xc
 3691 0a56 30       		.byte	0x30
 3692 0a57 600A0000 		.4byte	0xa60
 3693 0a5b 0D       		.uleb128 0xd
 3694 0a5c 500A0000 		.4byte	0xa50
 3695 0a60 0E       		.uleb128 0xe
 3696 0a61 04       		.byte	0x4
 3697 0a62 660A0000 		.4byte	0xa66
 3698 0a66 0F       		.uleb128 0xf
 3699 0a67 D9020000 		.4byte	.LASF150
 3700 0a6b 48       		.byte	0x48
 3701 0a6c 01       		.byte	0x1
 3702 0a6d 61       		.byte	0x61
 3703 0a6e E90A0000 		.4byte	0xae9
 3704 0a72 0B       		.uleb128 0xb
 3705 0a73 A1090000 		.4byte	.LASF151
 3706 0a77 01       		.byte	0x1
 3707 0a78 63       		.byte	0x63
 3708 0a79 0E0B0000 		.4byte	0xb0e
 3709 0a7d 00       		.byte	0
 3710 0a7e 0B       		.uleb128 0xb
 3711 0a7f 2A070000 		.4byte	.LASF152
 3712 0a83 01       		.byte	0x1
 3713 0a84 64       		.byte	0x64
 3714 0a85 0E0B0000 		.4byte	0xb0e
 3715 0a89 04       		.byte	0x4
 3716 0a8a 10       		.uleb128 0x10
 3717 0a8b 7500     		.ascii	"u\000"
 3718 0a8d 01       		.byte	0x1
ARM GAS  /tmp/ccdqkONZ.s 			page 112


 3719 0a8e 6A       		.byte	0x6a
 3720 0a8f 4F0B0000 		.4byte	0xb4f
 3721 0a93 08       		.byte	0x8
 3722 0a94 0B       		.uleb128 0xb
 3723 0a95 71010000 		.4byte	.LASF153
 3724 0a99 01       		.byte	0x1
 3725 0a9a 6C       		.byte	0x6c
 3726 0a9b FF090000 		.4byte	0x9ff
 3727 0a9f 10       		.byte	0x10
 3728 0aa0 0B       		.uleb128 0xb
 3729 0aa1 CD000000 		.4byte	.LASF154
 3730 0aa5 01       		.byte	0x1
 3731 0aa6 6D       		.byte	0x6d
 3732 0aa7 FF090000 		.4byte	0x9ff
 3733 0aab 24       		.byte	0x24
 3734 0aac 0B       		.uleb128 0xb
 3735 0aad 5F030000 		.4byte	.LASF155
 3736 0ab1 01       		.byte	0x1
 3737 0ab2 6F       		.byte	0x6f
 3738 0ab3 11090000 		.4byte	0x911
 3739 0ab7 38       		.byte	0x38
 3740 0ab8 0B       		.uleb128 0xb
 3741 0ab9 A3070000 		.4byte	.LASF156
 3742 0abd 01       		.byte	0x1
 3743 0abe 70       		.byte	0x70
 3744 0abf 06090000 		.4byte	0x906
 3745 0ac3 3C       		.byte	0x3c
 3746 0ac4 0B       		.uleb128 0xb
 3747 0ac5 6F040000 		.4byte	.LASF157
 3748 0ac9 01       		.byte	0x1
 3749 0aca 71       		.byte	0x71
 3750 0acb 06090000 		.4byte	0x906
 3751 0acf 40       		.byte	0x40
 3752 0ad0 0B       		.uleb128 0xb
 3753 0ad1 21080000 		.4byte	.LASF158
 3754 0ad5 01       		.byte	0x1
 3755 0ad6 73       		.byte	0x73
 3756 0ad7 C6080000 		.4byte	0x8c6
 3757 0adb 44       		.byte	0x44
 3758 0adc 0B       		.uleb128 0xb
 3759 0add B4010000 		.4byte	.LASF159
 3760 0ae1 01       		.byte	0x1
 3761 0ae2 74       		.byte	0x74
 3762 0ae3 C6080000 		.4byte	0x8c6
 3763 0ae7 45       		.byte	0x45
 3764 0ae8 00       		.byte	0
 3765 0ae9 0F       		.uleb128 0xf
 3766 0aea F3040000 		.4byte	.LASF160
 3767 0aee 08       		.byte	0x8
 3768 0aef 01       		.byte	0x1
 3769 0af0 43       		.byte	0x43
 3770 0af1 0E0B0000 		.4byte	0xb0e
 3771 0af5 0B       		.uleb128 0xb
 3772 0af6 59080000 		.4byte	.LASF161
 3773 0afa 01       		.byte	0x1
 3774 0afb 45       		.byte	0x45
 3775 0afc 0E0B0000 		.4byte	0xb0e
ARM GAS  /tmp/ccdqkONZ.s 			page 113


 3776 0b00 00       		.byte	0
 3777 0b01 0B       		.uleb128 0xb
 3778 0b02 19020000 		.4byte	.LASF162
 3779 0b06 01       		.byte	0x1
 3780 0b07 46       		.byte	0x46
 3781 0b08 0E0B0000 		.4byte	0xb0e
 3782 0b0c 04       		.byte	0x4
 3783 0b0d 00       		.byte	0
 3784 0b0e 0E       		.uleb128 0xe
 3785 0b0f 04       		.byte	0x4
 3786 0b10 BB080000 		.4byte	0x8bb
 3787 0b14 02       		.uleb128 0x2
 3788 0b15 93070000 		.4byte	.LASF163
 3789 0b19 01       		.byte	0x1
 3790 0b1a 47       		.byte	0x47
 3791 0b1b E90A0000 		.4byte	0xae9
 3792 0b1f 0F       		.uleb128 0xf
 3793 0b20 65000000 		.4byte	.LASF164
 3794 0b24 08       		.byte	0x8
 3795 0b25 01       		.byte	0x1
 3796 0b26 49       		.byte	0x49
 3797 0b27 440B0000 		.4byte	0xb44
 3798 0b2b 0B       		.uleb128 0xb
 3799 0b2c 96030000 		.4byte	.LASF165
 3800 0b30 01       		.byte	0x1
 3801 0b31 4B       		.byte	0x4b
 3802 0b32 0A0A0000 		.4byte	0xa0a
 3803 0b36 00       		.byte	0
 3804 0b37 0B       		.uleb128 0xb
 3805 0b38 F7080000 		.4byte	.LASF166
 3806 0b3c 01       		.byte	0x1
 3807 0b3d 4C       		.byte	0x4c
 3808 0b3e 06090000 		.4byte	0x906
 3809 0b42 04       		.byte	0x4
 3810 0b43 00       		.byte	0
 3811 0b44 02       		.uleb128 0x2
 3812 0b45 95000000 		.4byte	.LASF167
 3813 0b49 01       		.byte	0x1
 3814 0b4a 4D       		.byte	0x4d
 3815 0b4b 1F0B0000 		.4byte	0xb1f
 3816 0b4f 06       		.uleb128 0x6
 3817 0b50 08       		.byte	0x8
 3818 0b51 01       		.byte	0x1
 3819 0b52 66       		.byte	0x66
 3820 0b53 6E0B0000 		.4byte	0xb6e
 3821 0b57 07       		.uleb128 0x7
 3822 0b58 A3020000 		.4byte	.LASF168
 3823 0b5c 01       		.byte	0x1
 3824 0b5d 68       		.byte	0x68
 3825 0b5e 140B0000 		.4byte	0xb14
 3826 0b62 07       		.uleb128 0x7
 3827 0b63 71030000 		.4byte	.LASF169
 3828 0b67 01       		.byte	0x1
 3829 0b68 69       		.byte	0x69
 3830 0b69 440B0000 		.4byte	0xb44
 3831 0b6d 00       		.byte	0
 3832 0b6e 02       		.uleb128 0x2
ARM GAS  /tmp/ccdqkONZ.s 			page 114


 3833 0b6f 2C0A0000 		.4byte	.LASF170
 3834 0b73 01       		.byte	0x1
 3835 0b74 83       		.byte	0x83
 3836 0b75 660A0000 		.4byte	0xa66
 3837 0b79 02       		.uleb128 0x2
 3838 0b7a E9010000 		.4byte	.LASF171
 3839 0b7e 01       		.byte	0x1
 3840 0b7f 87       		.byte	0x87
 3841 0b80 6E0B0000 		.4byte	0xb6e
 3842 0b84 0D       		.uleb128 0xd
 3843 0b85 790B0000 		.4byte	0xb79
 3844 0b89 23       		.uleb128 0x23
 3845 0b8a 29080000 		.4byte	.LASF174
 3846 0b8e 01       		.byte	0x1
 3847 0b8f 3009     		.2byte	0x930
 3848 0b91 F6080000 		.4byte	0x8f6
 3849 0b95 800B0000 		.4byte	.LFB26
 3850 0b99 2E000000 		.4byte	.LFE26-.LFB26
 3851 0b9d 01       		.uleb128 0x1
 3852 0b9e 9C       		.byte	0x9c
 3853 0b9f D10B0000 		.4byte	0xbd1
 3854 0ba3 24       		.uleb128 0x24
 3855 0ba4 A3020000 		.4byte	.LASF168
 3856 0ba8 01       		.byte	0x1
 3857 0ba9 3009     		.2byte	0x930
 3858 0bab 5B0A0000 		.4byte	0xa5b
 3859 0baf 02       		.uleb128 0x2
 3860 0bb0 91       		.byte	0x91
 3861 0bb1 6C       		.sleb128 -20
 3862 0bb2 25       		.uleb128 0x25
 3863 0bb3 4D040000 		.4byte	.LASF172
 3864 0bb7 01       		.byte	0x1
 3865 0bb8 3209     		.2byte	0x932
 3866 0bba F6080000 		.4byte	0x8f6
 3867 0bbe 02       		.uleb128 0x2
 3868 0bbf 91       		.byte	0x91
 3869 0bc0 74       		.sleb128 -12
 3870 0bc1 25       		.uleb128 0x25
 3871 0bc2 A0080000 		.4byte	.LASF173
 3872 0bc6 01       		.byte	0x1
 3873 0bc7 3309     		.2byte	0x933
 3874 0bc9 D70B0000 		.4byte	0xbd7
 3875 0bcd 02       		.uleb128 0x2
 3876 0bce 91       		.byte	0x91
 3877 0bcf 70       		.sleb128 -16
 3878 0bd0 00       		.byte	0
 3879 0bd1 0E       		.uleb128 0xe
 3880 0bd2 04       		.byte	0x4
 3881 0bd3 790B0000 		.4byte	0xb79
 3882 0bd7 0D       		.uleb128 0xd
 3883 0bd8 D10B0000 		.4byte	0xbd1
 3884 0bdc 26       		.uleb128 0x26
 3885 0bdd 10060000 		.4byte	.LASF176
 3886 0be1 01       		.byte	0x1
 3887 0be2 1B09     		.2byte	0x91b
 3888 0be4 F6080000 		.4byte	0x8f6
 3889 0be8 500B0000 		.4byte	.LFB25
ARM GAS  /tmp/ccdqkONZ.s 			page 115


 3890 0bec 30000000 		.4byte	.LFE25-.LFB25
 3891 0bf0 01       		.uleb128 0x1
 3892 0bf1 9C       		.byte	0x9c
 3893 0bf2 150C0000 		.4byte	0xc15
 3894 0bf6 24       		.uleb128 0x24
 3895 0bf7 A0080000 		.4byte	.LASF173
 3896 0bfb 01       		.byte	0x1
 3897 0bfc 1B09     		.2byte	0x91b
 3898 0bfe 150C0000 		.4byte	0xc15
 3899 0c02 02       		.uleb128 0x2
 3900 0c03 91       		.byte	0x91
 3901 0c04 6C       		.sleb128 -20
 3902 0c05 25       		.uleb128 0x25
 3903 0c06 4D040000 		.4byte	.LASF172
 3904 0c0a 01       		.byte	0x1
 3905 0c0b 1D09     		.2byte	0x91d
 3906 0c0d F6080000 		.4byte	0x8f6
 3907 0c11 02       		.uleb128 0x2
 3908 0c12 91       		.byte	0x91
 3909 0c13 74       		.sleb128 -12
 3910 0c14 00       		.byte	0
 3911 0c15 0E       		.uleb128 0xe
 3912 0c16 04       		.byte	0x4
 3913 0c17 840B0000 		.4byte	0xb84
 3914 0c1b 23       		.uleb128 0x23
 3915 0c1c EC090000 		.4byte	.LASF175
 3916 0c20 01       		.byte	0x1
 3917 0c21 0809     		.2byte	0x908
 3918 0c23 F6080000 		.4byte	0x8f6
 3919 0c27 260B0000 		.4byte	.LFB24
 3920 0c2b 2A000000 		.4byte	.LFE24-.LFB24
 3921 0c2f 01       		.uleb128 0x1
 3922 0c30 9C       		.byte	0x9c
 3923 0c31 630C0000 		.4byte	0xc63
 3924 0c35 24       		.uleb128 0x24
 3925 0c36 A3020000 		.4byte	.LASF168
 3926 0c3a 01       		.byte	0x1
 3927 0c3b 0809     		.2byte	0x908
 3928 0c3d 5B0A0000 		.4byte	0xa5b
 3929 0c41 02       		.uleb128 0x2
 3930 0c42 91       		.byte	0x91
 3931 0c43 6C       		.sleb128 -20
 3932 0c44 25       		.uleb128 0x25
 3933 0c45 4D040000 		.4byte	.LASF172
 3934 0c49 01       		.byte	0x1
 3935 0c4a 0A09     		.2byte	0x90a
 3936 0c4c F6080000 		.4byte	0x8f6
 3937 0c50 02       		.uleb128 0x2
 3938 0c51 91       		.byte	0x91
 3939 0c52 74       		.sleb128 -12
 3940 0c53 25       		.uleb128 0x25
 3941 0c54 A0080000 		.4byte	.LASF173
 3942 0c58 01       		.byte	0x1
 3943 0c59 0B09     		.2byte	0x90b
 3944 0c5b D70B0000 		.4byte	0xbd7
 3945 0c5f 02       		.uleb128 0x2
 3946 0c60 91       		.byte	0x91
ARM GAS  /tmp/ccdqkONZ.s 			page 116


 3947 0c61 70       		.sleb128 -16
 3948 0c62 00       		.byte	0
 3949 0c63 26       		.uleb128 0x26
 3950 0c64 9F050000 		.4byte	.LASF177
 3951 0c68 01       		.byte	0x1
 3952 0c69 F308     		.2byte	0x8f3
 3953 0c6b F6080000 		.4byte	0x8f6
 3954 0c6f FA0A0000 		.4byte	.LFB23
 3955 0c73 2C000000 		.4byte	.LFE23-.LFB23
 3956 0c77 01       		.uleb128 0x1
 3957 0c78 9C       		.byte	0x9c
 3958 0c79 9C0C0000 		.4byte	0xc9c
 3959 0c7d 24       		.uleb128 0x24
 3960 0c7e A0080000 		.4byte	.LASF173
 3961 0c82 01       		.byte	0x1
 3962 0c83 F308     		.2byte	0x8f3
 3963 0c85 150C0000 		.4byte	0xc15
 3964 0c89 02       		.uleb128 0x2
 3965 0c8a 91       		.byte	0x91
 3966 0c8b 6C       		.sleb128 -20
 3967 0c8c 25       		.uleb128 0x25
 3968 0c8d 4D040000 		.4byte	.LASF172
 3969 0c91 01       		.byte	0x1
 3970 0c92 F508     		.2byte	0x8f5
 3971 0c94 F6080000 		.4byte	0x8f6
 3972 0c98 02       		.uleb128 0x2
 3973 0c99 91       		.byte	0x91
 3974 0c9a 74       		.sleb128 -12
 3975 0c9b 00       		.byte	0
 3976 0c9c 27       		.uleb128 0x27
 3977 0c9d AA020000 		.4byte	.LASF178
 3978 0ca1 01       		.byte	0x1
 3979 0ca2 7B08     		.2byte	0x87b
 3980 0ca4 560A0000 		.4byte	.LFB22
 3981 0ca8 A4000000 		.4byte	.LFE22-.LFB22
 3982 0cac 01       		.uleb128 0x1
 3983 0cad 9C       		.byte	0x9c
 3984 0cae F80C0000 		.4byte	0xcf8
 3985 0cb2 24       		.uleb128 0x24
 3986 0cb3 A0080000 		.4byte	.LASF173
 3987 0cb7 01       		.byte	0x1
 3988 0cb8 7B08     		.2byte	0x87b
 3989 0cba D70B0000 		.4byte	0xbd7
 3990 0cbe 02       		.uleb128 0x2
 3991 0cbf 91       		.byte	0x91
 3992 0cc0 6C       		.sleb128 -20
 3993 0cc1 28       		.uleb128 0x28
 3994 0cc2 620A0000 		.4byte	.LBB47
 3995 0cc6 42000000 		.4byte	.LBE47-.LBB47
 3996 0cca DE0C0000 		.4byte	0xcde
 3997 0cce 25       		.uleb128 0x25
 3998 0ccf B4010000 		.4byte	.LASF159
 3999 0cd3 01       		.byte	0x1
 4000 0cd4 8508     		.2byte	0x885
 4001 0cd6 BB080000 		.4byte	0x8bb
 4002 0cda 02       		.uleb128 0x2
 4003 0cdb 91       		.byte	0x91
ARM GAS  /tmp/ccdqkONZ.s 			page 117


 4004 0cdc 77       		.sleb128 -9
 4005 0cdd 00       		.byte	0
 4006 0cde 29       		.uleb128 0x29
 4007 0cdf AC0A0000 		.4byte	.LBB48
 4008 0ce3 42000000 		.4byte	.LBE48-.LBB48
 4009 0ce7 25       		.uleb128 0x25
 4010 0ce8 21080000 		.4byte	.LASF158
 4011 0cec 01       		.byte	0x1
 4012 0ced D608     		.2byte	0x8d6
 4013 0cef BB080000 		.4byte	0x8bb
 4014 0cf3 02       		.uleb128 0x2
 4015 0cf4 91       		.byte	0x91
 4016 0cf5 76       		.sleb128 -10
 4017 0cf6 00       		.byte	0
 4018 0cf7 00       		.byte	0
 4019 0cf8 27       		.uleb128 0x27
 4020 0cf9 5E090000 		.4byte	.LASF179
 4021 0cfd 01       		.byte	0x1
 4022 0cfe 6908     		.2byte	0x869
 4023 0d00 0A0A0000 		.4byte	.LFB21
 4024 0d04 4C000000 		.4byte	.LFE21-.LFB21
 4025 0d08 01       		.uleb128 0x1
 4026 0d09 9C       		.byte	0x9c
 4027 0d0a 2D0D0000 		.4byte	0xd2d
 4028 0d0e 24       		.uleb128 0x24
 4029 0d0f A0080000 		.4byte	.LASF173
 4030 0d13 01       		.byte	0x1
 4031 0d14 6908     		.2byte	0x869
 4032 0d16 D70B0000 		.4byte	0xbd7
 4033 0d1a 02       		.uleb128 0x2
 4034 0d1b 91       		.byte	0x91
 4035 0d1c 74       		.sleb128 -12
 4036 0d1d 24       		.uleb128 0x24
 4037 0d1e 4B030000 		.4byte	.LASF180
 4038 0d22 01       		.byte	0x1
 4039 0d23 6908     		.2byte	0x869
 4040 0d25 33010000 		.4byte	0x133
 4041 0d29 02       		.uleb128 0x2
 4042 0d2a 91       		.byte	0x91
 4043 0d2b 70       		.sleb128 -16
 4044 0d2c 00       		.byte	0
 4045 0d2d 26       		.uleb128 0x26
 4046 0d2e 2A090000 		.4byte	.LASF181
 4047 0d32 01       		.byte	0x1
 4048 0d33 1A08     		.2byte	0x81a
 4049 0d35 F6080000 		.4byte	0x8f6
 4050 0d39 52090000 		.4byte	.LFB20
 4051 0d3d B8000000 		.4byte	.LFE20-.LFB20
 4052 0d41 01       		.uleb128 0x1
 4053 0d42 9C       		.byte	0x9c
 4054 0d43 930D0000 		.4byte	0xd93
 4055 0d47 24       		.uleb128 0x24
 4056 0d48 A0080000 		.4byte	.LASF173
 4057 0d4c 01       		.byte	0x1
 4058 0d4d 1A08     		.2byte	0x81a
 4059 0d4f D70B0000 		.4byte	0xbd7
 4060 0d53 02       		.uleb128 0x2
ARM GAS  /tmp/ccdqkONZ.s 			page 118


 4061 0d54 91       		.byte	0x91
 4062 0d55 6C       		.sleb128 -20
 4063 0d56 24       		.uleb128 0x24
 4064 0d57 04070000 		.4byte	.LASF182
 4065 0d5b 01       		.byte	0x1
 4066 0d5c 1A08     		.2byte	0x81a
 4067 0d5e AF080000 		.4byte	0x8af
 4068 0d62 02       		.uleb128 0x2
 4069 0d63 91       		.byte	0x91
 4070 0d64 68       		.sleb128 -24
 4071 0d65 24       		.uleb128 0x24
 4072 0d66 F8050000 		.4byte	.LASF183
 4073 0d6a 01       		.byte	0x1
 4074 0d6b 1A08     		.2byte	0x81a
 4075 0d6d 01090000 		.4byte	0x901
 4076 0d71 02       		.uleb128 0x2
 4077 0d72 91       		.byte	0x91
 4078 0d73 64       		.sleb128 -28
 4079 0d74 25       		.uleb128 0x25
 4080 0d75 4D040000 		.4byte	.LASF172
 4081 0d79 01       		.byte	0x1
 4082 0d7a 1C08     		.2byte	0x81c
 4083 0d7c F6080000 		.4byte	0x8f6
 4084 0d80 02       		.uleb128 0x2
 4085 0d81 91       		.byte	0x91
 4086 0d82 70       		.sleb128 -16
 4087 0d83 25       		.uleb128 0x25
 4088 0d84 5F030000 		.4byte	.LASF155
 4089 0d88 01       		.byte	0x1
 4090 0d89 1D08     		.2byte	0x81d
 4091 0d8b 06090000 		.4byte	0x906
 4092 0d8f 02       		.uleb128 0x2
 4093 0d90 91       		.byte	0x91
 4094 0d91 74       		.sleb128 -12
 4095 0d92 00       		.byte	0
 4096 0d93 2A       		.uleb128 0x2a
 4097 0d94 39010000 		.4byte	.LASF223
 4098 0d98 01       		.byte	0x1
 4099 0d99 B707     		.2byte	0x7b7
 4100 0d9b 38090000 		.4byte	.LFB19
 4101 0d9f 1A000000 		.4byte	.LFE19-.LFB19
 4102 0da3 01       		.uleb128 0x1
 4103 0da4 9C       		.byte	0x9c
 4104 0da5 C80D0000 		.4byte	0xdc8
 4105 0da9 24       		.uleb128 0x24
 4106 0daa A3020000 		.4byte	.LASF168
 4107 0dae 01       		.byte	0x1
 4108 0daf B707     		.2byte	0x7b7
 4109 0db1 500A0000 		.4byte	0xa50
 4110 0db5 02       		.uleb128 0x2
 4111 0db6 91       		.byte	0x91
 4112 0db7 6C       		.sleb128 -20
 4113 0db8 25       		.uleb128 0x25
 4114 0db9 A0080000 		.4byte	.LASF173
 4115 0dbd 01       		.byte	0x1
 4116 0dbe B907     		.2byte	0x7b9
 4117 0dc0 D70B0000 		.4byte	0xbd7
ARM GAS  /tmp/ccdqkONZ.s 			page 119


 4118 0dc4 02       		.uleb128 0x2
 4119 0dc5 91       		.byte	0x91
 4120 0dc6 74       		.sleb128 -12
 4121 0dc7 00       		.byte	0
 4122 0dc8 23       		.uleb128 0x23
 4123 0dc9 4C050000 		.4byte	.LASF184
 4124 0dcd 01       		.byte	0x1
 4125 0dce AB07     		.2byte	0x7ab
 4126 0dd0 06090000 		.4byte	0x906
 4127 0dd4 1A090000 		.4byte	.LFB18
 4128 0dd8 1E000000 		.4byte	.LFE18-.LFB18
 4129 0ddc 01       		.uleb128 0x1
 4130 0ddd 9C       		.byte	0x9c
 4131 0dde 100E0000 		.4byte	0xe10
 4132 0de2 24       		.uleb128 0x24
 4133 0de3 A3020000 		.4byte	.LASF168
 4134 0de7 01       		.byte	0x1
 4135 0de8 AB07     		.2byte	0x7ab
 4136 0dea 5B0A0000 		.4byte	0xa5b
 4137 0dee 02       		.uleb128 0x2
 4138 0def 91       		.byte	0x91
 4139 0df0 6C       		.sleb128 -20
 4140 0df1 25       		.uleb128 0x25
 4141 0df2 FE010000 		.4byte	.LASF185
 4142 0df6 01       		.byte	0x1
 4143 0df7 AD07     		.2byte	0x7ad
 4144 0df9 06090000 		.4byte	0x906
 4145 0dfd 02       		.uleb128 0x2
 4146 0dfe 91       		.byte	0x91
 4147 0dff 70       		.sleb128 -16
 4148 0e00 25       		.uleb128 0x25
 4149 0e01 A0080000 		.4byte	.LASF173
 4150 0e05 01       		.byte	0x1
 4151 0e06 AE07     		.2byte	0x7ae
 4152 0e08 D70B0000 		.4byte	0xbd7
 4153 0e0c 02       		.uleb128 0x2
 4154 0e0d 91       		.byte	0x91
 4155 0e0e 74       		.sleb128 -12
 4156 0e0f 00       		.byte	0
 4157 0e10 2B       		.uleb128 0x2b
 4158 0e11 97010000 		.4byte	.LASF186
 4159 0e15 01       		.byte	0x1
 4160 0e16 9A07     		.2byte	0x79a
 4161 0e18 06090000 		.4byte	0x906
 4162 0e1c F0080000 		.4byte	.LFB17
 4163 0e20 2A000000 		.4byte	.LFE17-.LFB17
 4164 0e24 01       		.uleb128 0x1
 4165 0e25 9C       		.byte	0x9c
 4166 0e26 580E0000 		.4byte	0xe58
 4167 0e2a 24       		.uleb128 0x24
 4168 0e2b A3020000 		.4byte	.LASF168
 4169 0e2f 01       		.byte	0x1
 4170 0e30 9A07     		.2byte	0x79a
 4171 0e32 5B0A0000 		.4byte	0xa5b
 4172 0e36 02       		.uleb128 0x2
 4173 0e37 91       		.byte	0x91
 4174 0e38 6C       		.sleb128 -20
ARM GAS  /tmp/ccdqkONZ.s 			page 120


 4175 0e39 25       		.uleb128 0x25
 4176 0e3a FE010000 		.4byte	.LASF185
 4177 0e3e 01       		.byte	0x1
 4178 0e3f 9C07     		.2byte	0x79c
 4179 0e41 06090000 		.4byte	0x906
 4180 0e45 02       		.uleb128 0x2
 4181 0e46 91       		.byte	0x91
 4182 0e47 70       		.sleb128 -16
 4183 0e48 25       		.uleb128 0x25
 4184 0e49 A0080000 		.4byte	.LASF173
 4185 0e4d 01       		.byte	0x1
 4186 0e4e 9D07     		.2byte	0x79d
 4187 0e50 D70B0000 		.4byte	0xbd7
 4188 0e54 02       		.uleb128 0x2
 4189 0e55 91       		.byte	0x91
 4190 0e56 74       		.sleb128 -12
 4191 0e57 00       		.byte	0
 4192 0e58 2B       		.uleb128 0x2b
 4193 0e59 42080000 		.4byte	.LASF187
 4194 0e5d 01       		.byte	0x1
 4195 0e5e 8A07     		.2byte	0x78a
 4196 0e60 06090000 		.4byte	0x906
 4197 0e64 D0080000 		.4byte	.LFB16
 4198 0e68 20000000 		.4byte	.LFE16-.LFB16
 4199 0e6c 01       		.uleb128 0x1
 4200 0e6d 9C       		.byte	0x9c
 4201 0e6e 910E0000 		.4byte	0xe91
 4202 0e72 24       		.uleb128 0x24
 4203 0e73 A3020000 		.4byte	.LASF168
 4204 0e77 01       		.byte	0x1
 4205 0e78 8A07     		.2byte	0x78a
 4206 0e7a 5B0A0000 		.4byte	0xa5b
 4207 0e7e 02       		.uleb128 0x2
 4208 0e7f 91       		.byte	0x91
 4209 0e80 6C       		.sleb128 -20
 4210 0e81 25       		.uleb128 0x25
 4211 0e82 FE010000 		.4byte	.LASF185
 4212 0e86 01       		.byte	0x1
 4213 0e87 8C07     		.2byte	0x78c
 4214 0e89 06090000 		.4byte	0x906
 4215 0e8d 02       		.uleb128 0x2
 4216 0e8e 91       		.byte	0x91
 4217 0e8f 74       		.sleb128 -12
 4218 0e90 00       		.byte	0
 4219 0e91 2B       		.uleb128 0x2b
 4220 0e92 0C090000 		.4byte	.LASF188
 4221 0e96 01       		.byte	0x1
 4222 0e97 5407     		.2byte	0x754
 4223 0e99 F6080000 		.4byte	0x8f6
 4224 0e9d 6C080000 		.4byte	.LFB15
 4225 0ea1 64000000 		.4byte	.LFE15-.LFB15
 4226 0ea5 01       		.uleb128 0x1
 4227 0ea6 9C       		.byte	0x9c
 4228 0ea7 4E0F0000 		.4byte	0xf4e
 4229 0eab 24       		.uleb128 0x24
 4230 0eac A3020000 		.4byte	.LASF168
 4231 0eb0 01       		.byte	0x1
ARM GAS  /tmp/ccdqkONZ.s 			page 121


 4232 0eb1 5407     		.2byte	0x754
 4233 0eb3 500A0000 		.4byte	0xa50
 4234 0eb7 02       		.uleb128 0x2
 4235 0eb8 91       		.byte	0x91
 4236 0eb9 54       		.sleb128 -44
 4237 0eba 24       		.uleb128 0x24
 4238 0ebb 4B030000 		.4byte	.LASF180
 4239 0ebf 01       		.byte	0x1
 4240 0ec0 5407     		.2byte	0x754
 4241 0ec2 33010000 		.4byte	0x133
 4242 0ec6 02       		.uleb128 0x2
 4243 0ec7 91       		.byte	0x91
 4244 0ec8 50       		.sleb128 -48
 4245 0ec9 25       		.uleb128 0x25
 4246 0eca 4D040000 		.4byte	.LASF172
 4247 0ece 01       		.byte	0x1
 4248 0ecf 5607     		.2byte	0x756
 4249 0ed1 F6080000 		.4byte	0x8f6
 4250 0ed5 02       		.uleb128 0x2
 4251 0ed6 91       		.byte	0x91
 4252 0ed7 74       		.sleb128 -12
 4253 0ed8 25       		.uleb128 0x25
 4254 0ed9 2C020000 		.4byte	.LASF189
 4255 0edd 01       		.byte	0x1
 4256 0ede 5707     		.2byte	0x757
 4257 0ee0 06090000 		.4byte	0x906
 4258 0ee4 02       		.uleb128 0x2
 4259 0ee5 91       		.byte	0x91
 4260 0ee6 6C       		.sleb128 -20
 4261 0ee7 25       		.uleb128 0x25
 4262 0ee8 BC060000 		.4byte	.LASF190
 4263 0eec 01       		.byte	0x1
 4264 0eed 5807     		.2byte	0x758
 4265 0eef 0E0B0000 		.4byte	0xb0e
 4266 0ef3 02       		.uleb128 0x2
 4267 0ef4 91       		.byte	0x91
 4268 0ef5 68       		.sleb128 -24
 4269 0ef6 25       		.uleb128 0x25
 4270 0ef7 A0080000 		.4byte	.LASF173
 4271 0efb 01       		.byte	0x1
 4272 0efc 5907     		.2byte	0x759
 4273 0efe D70B0000 		.4byte	0xbd7
 4274 0f02 02       		.uleb128 0x2
 4275 0f03 91       		.byte	0x91
 4276 0f04 70       		.sleb128 -16
 4277 0f05 2C       		.uleb128 0x2c
 4278 0f06 99150000 		.4byte	0x1599
 4279 0f0a 7A080000 		.4byte	.LBB43
 4280 0f0e 1A000000 		.4byte	.LBE43-.LBB43
 4281 0f12 01       		.byte	0x1
 4282 0f13 6F07     		.2byte	0x76f
 4283 0f15 340F0000 		.4byte	0xf34
 4284 0f19 29       		.uleb128 0x29
 4285 0f1a 7A080000 		.4byte	.LBB44
 4286 0f1e 1A000000 		.4byte	.LBE44-.LBB44
 4287 0f22 2D       		.uleb128 0x2d
 4288 0f23 A5150000 		.4byte	0x15a5
ARM GAS  /tmp/ccdqkONZ.s 			page 122


 4289 0f27 02       		.uleb128 0x2
 4290 0f28 91       		.byte	0x91
 4291 0f29 64       		.sleb128 -28
 4292 0f2a 2D       		.uleb128 0x2d
 4293 0f2b B0150000 		.4byte	0x15b0
 4294 0f2f 02       		.uleb128 0x2
 4295 0f30 91       		.byte	0x91
 4296 0f31 60       		.sleb128 -32
 4297 0f32 00       		.byte	0
 4298 0f33 00       		.byte	0
 4299 0f34 2E       		.uleb128 0x2e
 4300 0f35 81150000 		.4byte	0x1581
 4301 0f39 C0080000 		.4byte	.LBB45
 4302 0f3d 06000000 		.4byte	.LBE45-.LBB45
 4303 0f41 01       		.byte	0x1
 4304 0f42 8407     		.2byte	0x784
 4305 0f44 2F       		.uleb128 0x2f
 4306 0f45 8D150000 		.4byte	0x158d
 4307 0f49 02       		.uleb128 0x2
 4308 0f4a 91       		.byte	0x91
 4309 0f4b 5C       		.sleb128 -36
 4310 0f4c 00       		.byte	0
 4311 0f4d 00       		.byte	0
 4312 0f4e 2B       		.uleb128 0x2b
 4313 0f4f B8000000 		.4byte	.LASF191
 4314 0f53 01       		.byte	0x1
 4315 0f54 F906     		.2byte	0x6f9
 4316 0f56 F6080000 		.4byte	0x8f6
 4317 0f5a C0070000 		.4byte	.LFB14
 4318 0f5e AC000000 		.4byte	.LFE14-.LFB14
 4319 0f62 01       		.uleb128 0x1
 4320 0f63 9C       		.byte	0x9c
 4321 0f64 41100000 		.4byte	0x1041
 4322 0f68 24       		.uleb128 0x24
 4323 0f69 A3020000 		.4byte	.LASF168
 4324 0f6d 01       		.byte	0x1
 4325 0f6e F906     		.2byte	0x6f9
 4326 0f70 500A0000 		.4byte	0xa50
 4327 0f74 02       		.uleb128 0x2
 4328 0f75 91       		.byte	0x91
 4329 0f76 54       		.sleb128 -44
 4330 0f77 24       		.uleb128 0x24
 4331 0f78 4B030000 		.4byte	.LASF180
 4332 0f7c 01       		.byte	0x1
 4333 0f7d F906     		.2byte	0x6f9
 4334 0f7f 33010000 		.4byte	0x133
 4335 0f83 02       		.uleb128 0x2
 4336 0f84 91       		.byte	0x91
 4337 0f85 50       		.sleb128 -48
 4338 0f86 24       		.uleb128 0x24
 4339 0f87 E4000000 		.4byte	.LASF192
 4340 0f8b 01       		.byte	0x1
 4341 0f8c F906     		.2byte	0x6f9
 4342 0f8e 47100000 		.4byte	0x1047
 4343 0f92 02       		.uleb128 0x2
 4344 0f93 91       		.byte	0x91
 4345 0f94 4C       		.sleb128 -52
ARM GAS  /tmp/ccdqkONZ.s 			page 123


 4346 0f95 25       		.uleb128 0x25
 4347 0f96 4D040000 		.4byte	.LASF172
 4348 0f9a 01       		.byte	0x1
 4349 0f9b FB06     		.2byte	0x6fb
 4350 0f9d F6080000 		.4byte	0x8f6
 4351 0fa1 02       		.uleb128 0x2
 4352 0fa2 91       		.byte	0x91
 4353 0fa3 74       		.sleb128 -12
 4354 0fa4 25       		.uleb128 0x25
 4355 0fa5 2C020000 		.4byte	.LASF189
 4356 0fa9 01       		.byte	0x1
 4357 0faa FC06     		.2byte	0x6fc
 4358 0fac 06090000 		.4byte	0x906
 4359 0fb0 02       		.uleb128 0x2
 4360 0fb1 91       		.byte	0x91
 4361 0fb2 6C       		.sleb128 -20
 4362 0fb3 25       		.uleb128 0x25
 4363 0fb4 A0080000 		.4byte	.LASF173
 4364 0fb8 01       		.byte	0x1
 4365 0fb9 FD06     		.2byte	0x6fd
 4366 0fbb D70B0000 		.4byte	0xbd7
 4367 0fbf 02       		.uleb128 0x2
 4368 0fc0 91       		.byte	0x91
 4369 0fc1 70       		.sleb128 -16
 4370 0fc2 28       		.uleb128 0x28
 4371 0fc3 EC070000 		.4byte	.LBB39
 4372 0fc7 70000000 		.4byte	.LBE39-.LBB39
 4373 0fcb F80F0000 		.4byte	0xff8
 4374 0fcf 25       		.uleb128 0x25
 4375 0fd0 5F030000 		.4byte	.LASF155
 4376 0fd4 01       		.byte	0x1
 4377 0fd5 1407     		.2byte	0x714
 4378 0fd7 16090000 		.4byte	0x916
 4379 0fdb 02       		.uleb128 0x2
 4380 0fdc 91       		.byte	0x91
 4381 0fdd 68       		.sleb128 -24
 4382 0fde 29       		.uleb128 0x29
 4383 0fdf F8070000 		.4byte	.LBB40
 4384 0fe3 5A000000 		.4byte	.LBE40-.LBB40
 4385 0fe7 25       		.uleb128 0x25
 4386 0fe8 21080000 		.4byte	.LASF158
 4387 0fec 01       		.byte	0x1
 4388 0fed 1907     		.2byte	0x719
 4389 0fef CB080000 		.4byte	0x8cb
 4390 0ff3 02       		.uleb128 0x2
 4391 0ff4 91       		.byte	0x91
 4392 0ff5 67       		.sleb128 -25
 4393 0ff6 00       		.byte	0
 4394 0ff7 00       		.byte	0
 4395 0ff8 2C       		.uleb128 0x2c
 4396 0ff9 99150000 		.4byte	0x1599
 4397 0ffd D0070000 		.4byte	.LBB37
 4398 1001 1A000000 		.4byte	.LBE37-.LBB37
 4399 1005 01       		.byte	0x1
 4400 1006 1207     		.2byte	0x712
 4401 1008 27100000 		.4byte	0x1027
 4402 100c 29       		.uleb128 0x29
ARM GAS  /tmp/ccdqkONZ.s 			page 124


 4403 100d D0070000 		.4byte	.LBB38
 4404 1011 1A000000 		.4byte	.LBE38-.LBB38
 4405 1015 2D       		.uleb128 0x2d
 4406 1016 A5150000 		.4byte	0x15a5
 4407 101a 02       		.uleb128 0x2
 4408 101b 91       		.byte	0x91
 4409 101c 60       		.sleb128 -32
 4410 101d 2D       		.uleb128 0x2d
 4411 101e B0150000 		.4byte	0x15b0
 4412 1022 02       		.uleb128 0x2
 4413 1023 91       		.byte	0x91
 4414 1024 5C       		.sleb128 -36
 4415 1025 00       		.byte	0
 4416 1026 00       		.byte	0
 4417 1027 2E       		.uleb128 0x2e
 4418 1028 81150000 		.4byte	0x1581
 4419 102c 5C080000 		.4byte	.LBB41
 4420 1030 06000000 		.4byte	.LBE41-.LBB41
 4421 1034 01       		.byte	0x1
 4422 1035 4E07     		.2byte	0x74e
 4423 1037 2F       		.uleb128 0x2f
 4424 1038 8D150000 		.4byte	0x158d
 4425 103c 02       		.uleb128 0x2
 4426 103d 91       		.byte	0x91
 4427 103e 58       		.sleb128 -40
 4428 103f 00       		.byte	0
 4429 1040 00       		.byte	0
 4430 1041 0E       		.uleb128 0xe
 4431 1042 04       		.byte	0x4
 4432 1043 F6080000 		.4byte	0x8f6
 4433 1047 0D       		.uleb128 0xd
 4434 1048 41100000 		.4byte	0x1041
 4435 104c 2B       		.uleb128 0x2b
 4436 104d 8B030000 		.4byte	.LASF193
 4437 1051 01       		.byte	0x1
 4438 1052 6406     		.2byte	0x664
 4439 1054 F6080000 		.4byte	0x8f6
 4440 1058 78060000 		.4byte	.LFB13
 4441 105c 48010000 		.4byte	.LFE13-.LFB13
 4442 1060 01       		.uleb128 0x1
 4443 1061 9C       		.byte	0x9c
 4444 1062 E9100000 		.4byte	0x10e9
 4445 1066 24       		.uleb128 0x24
 4446 1067 A3020000 		.4byte	.LASF168
 4447 106b 01       		.byte	0x1
 4448 106c 6406     		.2byte	0x664
 4449 106e 500A0000 		.4byte	0xa50
 4450 1072 02       		.uleb128 0x2
 4451 1073 91       		.byte	0x91
 4452 1074 5C       		.sleb128 -36
 4453 1075 24       		.uleb128 0x24
 4454 1076 4B030000 		.4byte	.LASF180
 4455 107a 01       		.byte	0x1
 4456 107b 6406     		.2byte	0x664
 4457 107d 33010000 		.4byte	0x133
 4458 1081 02       		.uleb128 0x2
 4459 1082 91       		.byte	0x91
ARM GAS  /tmp/ccdqkONZ.s 			page 125


 4460 1083 58       		.sleb128 -40
 4461 1084 24       		.uleb128 0x24
 4462 1085 85090000 		.4byte	.LASF194
 4463 1089 01       		.byte	0x1
 4464 108a 6406     		.2byte	0x664
 4465 108c 1B090000 		.4byte	0x91b
 4466 1090 02       		.uleb128 0x2
 4467 1091 91       		.byte	0x91
 4468 1092 54       		.sleb128 -44
 4469 1093 25       		.uleb128 0x25
 4470 1094 AE030000 		.4byte	.LASF195
 4471 1098 01       		.byte	0x1
 4472 1099 6606     		.2byte	0x666
 4473 109b F6080000 		.4byte	0x8f6
 4474 109f 02       		.uleb128 0x2
 4475 10a0 91       		.byte	0x91
 4476 10a1 74       		.sleb128 -12
 4477 10a2 25       		.uleb128 0x25
 4478 10a3 C3030000 		.4byte	.LASF196
 4479 10a7 01       		.byte	0x1
 4480 10a8 6706     		.2byte	0x667
 4481 10aa 450A0000 		.4byte	0xa45
 4482 10ae 02       		.uleb128 0x2
 4483 10af 91       		.byte	0x91
 4484 10b0 60       		.sleb128 -32
 4485 10b1 25       		.uleb128 0x25
 4486 10b2 BC060000 		.4byte	.LASF190
 4487 10b6 01       		.byte	0x1
 4488 10b7 6806     		.2byte	0x668
 4489 10b9 0E0B0000 		.4byte	0xb0e
 4490 10bd 02       		.uleb128 0x2
 4491 10be 91       		.byte	0x91
 4492 10bf 68       		.sleb128 -24
 4493 10c0 25       		.uleb128 0x25
 4494 10c1 A0080000 		.4byte	.LASF173
 4495 10c5 01       		.byte	0x1
 4496 10c6 6906     		.2byte	0x669
 4497 10c8 D70B0000 		.4byte	0xbd7
 4498 10cc 02       		.uleb128 0x2
 4499 10cd 91       		.byte	0x91
 4500 10ce 70       		.sleb128 -16
 4501 10cf 29       		.uleb128 0x29
 4502 10d0 90060000 		.4byte	.LBB36
 4503 10d4 72000000 		.4byte	.LBE36-.LBB36
 4504 10d8 25       		.uleb128 0x25
 4505 10d9 5F030000 		.4byte	.LASF155
 4506 10dd 01       		.byte	0x1
 4507 10de 8106     		.2byte	0x681
 4508 10e0 16090000 		.4byte	0x916
 4509 10e4 02       		.uleb128 0x2
 4510 10e5 91       		.byte	0x91
 4511 10e6 6C       		.sleb128 -20
 4512 10e7 00       		.byte	0
 4513 10e8 00       		.byte	0
 4514 10e9 2B       		.uleb128 0x2b
 4515 10ea 29040000 		.4byte	.LASF197
 4516 10ee 01       		.byte	0x1
ARM GAS  /tmp/ccdqkONZ.s 			page 126


 4517 10ef 8A05     		.2byte	0x58a
 4518 10f1 F6080000 		.4byte	0x8f6
 4519 10f5 3C050000 		.4byte	.LFB12
 4520 10f9 3C010000 		.4byte	.LFE12-.LFB12
 4521 10fd 01       		.uleb128 0x1
 4522 10fe 9C       		.byte	0x9c
 4523 10ff 68110000 		.4byte	0x1168
 4524 1103 24       		.uleb128 0x24
 4525 1104 A3020000 		.4byte	.LASF168
 4526 1108 01       		.byte	0x1
 4527 1109 8A05     		.2byte	0x58a
 4528 110b 500A0000 		.4byte	0xa50
 4529 110f 02       		.uleb128 0x2
 4530 1110 91       		.byte	0x91
 4531 1111 5C       		.sleb128 -36
 4532 1112 24       		.uleb128 0x24
 4533 1113 85090000 		.4byte	.LASF194
 4534 1117 01       		.byte	0x1
 4535 1118 8A05     		.2byte	0x58a
 4536 111a 1B090000 		.4byte	0x91b
 4537 111e 02       		.uleb128 0x2
 4538 111f 91       		.byte	0x91
 4539 1120 58       		.sleb128 -40
 4540 1121 25       		.uleb128 0x25
 4541 1122 AE030000 		.4byte	.LASF195
 4542 1126 01       		.byte	0x1
 4543 1127 8C05     		.2byte	0x58c
 4544 1129 F6080000 		.4byte	0x8f6
 4545 112d 02       		.uleb128 0x2
 4546 112e 91       		.byte	0x91
 4547 112f 74       		.sleb128 -12
 4548 1130 25       		.uleb128 0x25
 4549 1131 C3030000 		.4byte	.LASF196
 4550 1135 01       		.byte	0x1
 4551 1136 8D05     		.2byte	0x58d
 4552 1138 450A0000 		.4byte	0xa45
 4553 113c 02       		.uleb128 0x2
 4554 113d 91       		.byte	0x91
 4555 113e 64       		.sleb128 -28
 4556 113f 25       		.uleb128 0x25
 4557 1140 A0080000 		.4byte	.LASF173
 4558 1144 01       		.byte	0x1
 4559 1145 8E05     		.2byte	0x58e
 4560 1147 D70B0000 		.4byte	0xbd7
 4561 114b 02       		.uleb128 0x2
 4562 114c 91       		.byte	0x91
 4563 114d 70       		.sleb128 -16
 4564 114e 29       		.uleb128 0x29
 4565 114f 52050000 		.4byte	.LBB35
 4566 1153 66000000 		.4byte	.LBE35-.LBB35
 4567 1157 25       		.uleb128 0x25
 4568 1158 19070000 		.4byte	.LASF198
 4569 115c 01       		.byte	0x1
 4570 115d AC05     		.2byte	0x5ac
 4571 115f 16090000 		.4byte	0x916
 4572 1163 02       		.uleb128 0x2
 4573 1164 91       		.byte	0x91
ARM GAS  /tmp/ccdqkONZ.s 			page 127


 4574 1165 6C       		.sleb128 -20
 4575 1166 00       		.byte	0
 4576 1167 00       		.byte	0
 4577 1168 2B       		.uleb128 0x2b
 4578 1169 AA000000 		.4byte	.LASF199
 4579 116d 01       		.byte	0x1
 4580 116e FD04     		.2byte	0x4fd
 4581 1170 F6080000 		.4byte	0x8f6
 4582 1174 F6030000 		.4byte	.LFB11
 4583 1178 46010000 		.4byte	.LFE11-.LFB11
 4584 117c 01       		.uleb128 0x1
 4585 117d 9C       		.byte	0x9c
 4586 117e F6110000 		.4byte	0x11f6
 4587 1182 24       		.uleb128 0x24
 4588 1183 A3020000 		.4byte	.LASF168
 4589 1187 01       		.byte	0x1
 4590 1188 FD04     		.2byte	0x4fd
 4591 118a 500A0000 		.4byte	0xa50
 4592 118e 02       		.uleb128 0x2
 4593 118f 91       		.byte	0x91
 4594 1190 5C       		.sleb128 -36
 4595 1191 24       		.uleb128 0x24
 4596 1192 4B030000 		.4byte	.LASF180
 4597 1196 01       		.byte	0x1
 4598 1197 FD04     		.2byte	0x4fd
 4599 1199 33010000 		.4byte	0x133
 4600 119d 02       		.uleb128 0x2
 4601 119e 91       		.byte	0x91
 4602 119f 58       		.sleb128 -40
 4603 11a0 24       		.uleb128 0x24
 4604 11a1 85090000 		.4byte	.LASF194
 4605 11a5 01       		.byte	0x1
 4606 11a6 FD04     		.2byte	0x4fd
 4607 11a8 1B090000 		.4byte	0x91b
 4608 11ac 02       		.uleb128 0x2
 4609 11ad 91       		.byte	0x91
 4610 11ae 54       		.sleb128 -44
 4611 11af 25       		.uleb128 0x25
 4612 11b0 AE030000 		.4byte	.LASF195
 4613 11b4 01       		.byte	0x1
 4614 11b5 FF04     		.2byte	0x4ff
 4615 11b7 F6080000 		.4byte	0x8f6
 4616 11bb 02       		.uleb128 0x2
 4617 11bc 91       		.byte	0x91
 4618 11bd 74       		.sleb128 -12
 4619 11be 25       		.uleb128 0x25
 4620 11bf C3030000 		.4byte	.LASF196
 4621 11c3 01       		.byte	0x1
 4622 11c4 0005     		.2byte	0x500
 4623 11c6 450A0000 		.4byte	0xa45
 4624 11ca 02       		.uleb128 0x2
 4625 11cb 91       		.byte	0x91
 4626 11cc 64       		.sleb128 -28
 4627 11cd 25       		.uleb128 0x25
 4628 11ce A0080000 		.4byte	.LASF173
 4629 11d2 01       		.byte	0x1
 4630 11d3 0105     		.2byte	0x501
ARM GAS  /tmp/ccdqkONZ.s 			page 128


 4631 11d5 D70B0000 		.4byte	0xbd7
 4632 11d9 02       		.uleb128 0x2
 4633 11da 91       		.byte	0x91
 4634 11db 70       		.sleb128 -16
 4635 11dc 29       		.uleb128 0x29
 4636 11dd 0E040000 		.4byte	.LBB34
 4637 11e1 6E000000 		.4byte	.LBE34-.LBB34
 4638 11e5 25       		.uleb128 0x25
 4639 11e6 5F030000 		.4byte	.LASF155
 4640 11ea 01       		.byte	0x1
 4641 11eb 1905     		.2byte	0x519
 4642 11ed 16090000 		.4byte	0x916
 4643 11f1 02       		.uleb128 0x2
 4644 11f2 91       		.byte	0x91
 4645 11f3 6C       		.sleb128 -20
 4646 11f4 00       		.byte	0
 4647 11f5 00       		.byte	0
 4648 11f6 2B       		.uleb128 0x2b
 4649 11f7 1A050000 		.4byte	.LASF200
 4650 11fb 01       		.byte	0x1
 4651 11fc 5804     		.2byte	0x458
 4652 11fe F6080000 		.4byte	0x8f6
 4653 1202 50030000 		.4byte	.LFB10
 4654 1206 A6000000 		.4byte	.LFE10-.LFB10
 4655 120a 01       		.uleb128 0x1
 4656 120b 9C       		.byte	0x9c
 4657 120c DA120000 		.4byte	0x12da
 4658 1210 24       		.uleb128 0x24
 4659 1211 A3020000 		.4byte	.LASF168
 4660 1215 01       		.byte	0x1
 4661 1216 5804     		.2byte	0x458
 4662 1218 500A0000 		.4byte	0xa50
 4663 121c 02       		.uleb128 0x2
 4664 121d 91       		.byte	0x91
 4665 121e 54       		.sleb128 -44
 4666 121f 24       		.uleb128 0x24
 4667 1220 E4000000 		.4byte	.LASF192
 4668 1224 01       		.byte	0x1
 4669 1225 5804     		.2byte	0x458
 4670 1227 47100000 		.4byte	0x1047
 4671 122b 02       		.uleb128 0x2
 4672 122c 91       		.byte	0x91
 4673 122d 50       		.sleb128 -48
 4674 122e 25       		.uleb128 0x25
 4675 122f 4D040000 		.4byte	.LASF172
 4676 1233 01       		.byte	0x1
 4677 1234 5A04     		.2byte	0x45a
 4678 1236 F6080000 		.4byte	0x8f6
 4679 123a 02       		.uleb128 0x2
 4680 123b 91       		.byte	0x91
 4681 123c 74       		.sleb128 -12
 4682 123d 25       		.uleb128 0x25
 4683 123e 2C020000 		.4byte	.LASF189
 4684 1242 01       		.byte	0x1
 4685 1243 5B04     		.2byte	0x45b
 4686 1245 06090000 		.4byte	0x906
 4687 1249 02       		.uleb128 0x2
ARM GAS  /tmp/ccdqkONZ.s 			page 129


 4688 124a 91       		.byte	0x91
 4689 124b 6C       		.sleb128 -20
 4690 124c 25       		.uleb128 0x25
 4691 124d A0080000 		.4byte	.LASF173
 4692 1251 01       		.byte	0x1
 4693 1252 5C04     		.2byte	0x45c
 4694 1254 D70B0000 		.4byte	0xbd7
 4695 1258 02       		.uleb128 0x2
 4696 1259 91       		.byte	0x91
 4697 125a 70       		.sleb128 -16
 4698 125b 28       		.uleb128 0x28
 4699 125c 7A030000 		.4byte	.LBB30
 4700 1260 6C000000 		.4byte	.LBE30-.LBB30
 4701 1264 91120000 		.4byte	0x1291
 4702 1268 25       		.uleb128 0x25
 4703 1269 5F030000 		.4byte	.LASF155
 4704 126d 01       		.byte	0x1
 4705 126e 8104     		.2byte	0x481
 4706 1270 16090000 		.4byte	0x916
 4707 1274 02       		.uleb128 0x2
 4708 1275 91       		.byte	0x91
 4709 1276 68       		.sleb128 -24
 4710 1277 29       		.uleb128 0x29
 4711 1278 8A030000 		.4byte	.LBB31
 4712 127c 52000000 		.4byte	.LBE31-.LBB31
 4713 1280 25       		.uleb128 0x25
 4714 1281 B4010000 		.4byte	.LASF159
 4715 1285 01       		.byte	0x1
 4716 1286 8804     		.2byte	0x488
 4717 1288 CB080000 		.4byte	0x8cb
 4718 128c 02       		.uleb128 0x2
 4719 128d 91       		.byte	0x91
 4720 128e 67       		.sleb128 -25
 4721 128f 00       		.byte	0
 4722 1290 00       		.byte	0
 4723 1291 2C       		.uleb128 0x2c
 4724 1292 99150000 		.4byte	0x1599
 4725 1296 5E030000 		.4byte	.LBB28
 4726 129a 1A000000 		.4byte	.LBE28-.LBB28
 4727 129e 01       		.byte	0x1
 4728 129f 7F04     		.2byte	0x47f
 4729 12a1 C0120000 		.4byte	0x12c0
 4730 12a5 29       		.uleb128 0x29
 4731 12a6 5E030000 		.4byte	.LBB29
 4732 12aa 1A000000 		.4byte	.LBE29-.LBB29
 4733 12ae 2D       		.uleb128 0x2d
 4734 12af A5150000 		.4byte	0x15a5
 4735 12b3 02       		.uleb128 0x2
 4736 12b4 91       		.byte	0x91
 4737 12b5 60       		.sleb128 -32
 4738 12b6 2D       		.uleb128 0x2d
 4739 12b7 B0150000 		.4byte	0x15b0
 4740 12bb 02       		.uleb128 0x2
 4741 12bc 91       		.byte	0x91
 4742 12bd 5C       		.sleb128 -36
 4743 12be 00       		.byte	0
 4744 12bf 00       		.byte	0
ARM GAS  /tmp/ccdqkONZ.s 			page 130


 4745 12c0 2E       		.uleb128 0x2e
 4746 12c1 81150000 		.4byte	0x1581
 4747 12c5 E6030000 		.4byte	.LBB32
 4748 12c9 06000000 		.4byte	.LBE32-.LBB32
 4749 12cd 01       		.byte	0x1
 4750 12ce F704     		.2byte	0x4f7
 4751 12d0 2F       		.uleb128 0x2f
 4752 12d1 8D150000 		.4byte	0x158d
 4753 12d5 02       		.uleb128 0x2
 4754 12d6 91       		.byte	0x91
 4755 12d7 58       		.sleb128 -40
 4756 12d8 00       		.byte	0
 4757 12d9 00       		.byte	0
 4758 12da 2B       		.uleb128 0x2b
 4759 12db 58010000 		.4byte	.LASF201
 4760 12df 01       		.byte	0x1
 4761 12e0 B603     		.2byte	0x3b6
 4762 12e2 F6080000 		.4byte	0x8f6
 4763 12e6 98020000 		.4byte	.LFB9
 4764 12ea B8000000 		.4byte	.LFE9-.LFB9
 4765 12ee 01       		.uleb128 0x1
 4766 12ef 9C       		.byte	0x9c
 4767 12f0 D2130000 		.4byte	0x13d2
 4768 12f4 24       		.uleb128 0x24
 4769 12f5 A3020000 		.4byte	.LASF168
 4770 12f9 01       		.byte	0x1
 4771 12fa B603     		.2byte	0x3b6
 4772 12fc 500A0000 		.4byte	0xa50
 4773 1300 02       		.uleb128 0x2
 4774 1301 91       		.byte	0x91
 4775 1302 54       		.sleb128 -44
 4776 1303 24       		.uleb128 0x24
 4777 1304 04070000 		.4byte	.LASF182
 4778 1308 01       		.byte	0x1
 4779 1309 B603     		.2byte	0x3b6
 4780 130b B5080000 		.4byte	0x8b5
 4781 130f 02       		.uleb128 0x2
 4782 1310 91       		.byte	0x91
 4783 1311 50       		.sleb128 -48
 4784 1312 24       		.uleb128 0x24
 4785 1313 E4000000 		.4byte	.LASF192
 4786 1317 01       		.byte	0x1
 4787 1318 B603     		.2byte	0x3b6
 4788 131a 47100000 		.4byte	0x1047
 4789 131e 02       		.uleb128 0x2
 4790 131f 91       		.byte	0x91
 4791 1320 4C       		.sleb128 -52
 4792 1321 24       		.uleb128 0x24
 4793 1322 8E060000 		.4byte	.LASF202
 4794 1326 01       		.byte	0x1
 4795 1327 B603     		.2byte	0x3b6
 4796 1329 01090000 		.4byte	0x901
 4797 132d 02       		.uleb128 0x2
 4798 132e 91       		.byte	0x91
 4799 132f 48       		.sleb128 -56
 4800 1330 25       		.uleb128 0x25
 4801 1331 4D040000 		.4byte	.LASF172
ARM GAS  /tmp/ccdqkONZ.s 			page 131


 4802 1335 01       		.byte	0x1
 4803 1336 B803     		.2byte	0x3b8
 4804 1338 F6080000 		.4byte	0x8f6
 4805 133c 02       		.uleb128 0x2
 4806 133d 91       		.byte	0x91
 4807 133e 74       		.sleb128 -12
 4808 133f 25       		.uleb128 0x25
 4809 1340 2C020000 		.4byte	.LASF189
 4810 1344 01       		.byte	0x1
 4811 1345 B903     		.2byte	0x3b9
 4812 1347 06090000 		.4byte	0x906
 4813 134b 02       		.uleb128 0x2
 4814 134c 91       		.byte	0x91
 4815 134d 6C       		.sleb128 -20
 4816 134e 25       		.uleb128 0x25
 4817 134f A0080000 		.4byte	.LASF173
 4818 1353 01       		.byte	0x1
 4819 1354 BA03     		.2byte	0x3ba
 4820 1356 D70B0000 		.4byte	0xbd7
 4821 135a 02       		.uleb128 0x2
 4822 135b 91       		.byte	0x91
 4823 135c 70       		.sleb128 -16
 4824 135d 28       		.uleb128 0x28
 4825 135e D8020000 		.4byte	.LBB25
 4826 1362 5E000000 		.4byte	.LBE25-.LBB25
 4827 1366 89130000 		.4byte	0x1389
 4828 136a 25       		.uleb128 0x25
 4829 136b B4010000 		.4byte	.LASF159
 4830 136f 01       		.byte	0x1
 4831 1370 D903     		.2byte	0x3d9
 4832 1372 CB080000 		.4byte	0x8cb
 4833 1376 02       		.uleb128 0x2
 4834 1377 91       		.byte	0x91
 4835 1378 6B       		.sleb128 -21
 4836 1379 25       		.uleb128 0x25
 4837 137a 7F040000 		.4byte	.LASF203
 4838 137e 01       		.byte	0x1
 4839 137f DA03     		.2byte	0x3da
 4840 1381 16090000 		.4byte	0x916
 4841 1385 02       		.uleb128 0x2
 4842 1386 91       		.byte	0x91
 4843 1387 64       		.sleb128 -28
 4844 1388 00       		.byte	0
 4845 1389 2C       		.uleb128 0x2c
 4846 138a 99150000 		.4byte	0x1599
 4847 138e AA020000 		.4byte	.LBB23
 4848 1392 1A000000 		.4byte	.LBE23-.LBB23
 4849 1396 01       		.byte	0x1
 4850 1397 D503     		.2byte	0x3d5
 4851 1399 B8130000 		.4byte	0x13b8
 4852 139d 29       		.uleb128 0x29
 4853 139e AA020000 		.4byte	.LBB24
 4854 13a2 1A000000 		.4byte	.LBE24-.LBB24
 4855 13a6 2D       		.uleb128 0x2d
 4856 13a7 A5150000 		.4byte	0x15a5
 4857 13ab 02       		.uleb128 0x2
 4858 13ac 91       		.byte	0x91
ARM GAS  /tmp/ccdqkONZ.s 			page 132


 4859 13ad 60       		.sleb128 -32
 4860 13ae 2D       		.uleb128 0x2d
 4861 13af B0150000 		.4byte	0x15b0
 4862 13b3 02       		.uleb128 0x2
 4863 13b4 91       		.byte	0x91
 4864 13b5 5C       		.sleb128 -36
 4865 13b6 00       		.byte	0
 4866 13b7 00       		.byte	0
 4867 13b8 2E       		.uleb128 0x2e
 4868 13b9 81150000 		.4byte	0x1581
 4869 13bd 40030000 		.4byte	.LBB26
 4870 13c1 06000000 		.4byte	.LBE26-.LBB26
 4871 13c5 01       		.byte	0x1
 4872 13c6 5204     		.2byte	0x452
 4873 13c8 2F       		.uleb128 0x2f
 4874 13c9 8D150000 		.4byte	0x158d
 4875 13cd 02       		.uleb128 0x2
 4876 13ce 91       		.byte	0x91
 4877 13cf 58       		.sleb128 -40
 4878 13d0 00       		.byte	0
 4879 13d1 00       		.byte	0
 4880 13d2 2B       		.uleb128 0x2b
 4881 13d3 55040000 		.4byte	.LASF204
 4882 13d7 01       		.byte	0x1
 4883 13d8 E402     		.2byte	0x2e4
 4884 13da F6080000 		.4byte	0x8f6
 4885 13de 42010000 		.4byte	.LFB8
 4886 13e2 56010000 		.4byte	.LFE8-.LFB8
 4887 13e6 01       		.uleb128 0x1
 4888 13e7 9C       		.byte	0x9c
 4889 13e8 65140000 		.4byte	0x1465
 4890 13ec 24       		.uleb128 0x24
 4891 13ed A3020000 		.4byte	.LASF168
 4892 13f1 01       		.byte	0x1
 4893 13f2 E402     		.2byte	0x2e4
 4894 13f4 500A0000 		.4byte	0xa50
 4895 13f8 02       		.uleb128 0x2
 4896 13f9 91       		.byte	0x91
 4897 13fa 5C       		.sleb128 -36
 4898 13fb 24       		.uleb128 0x24
 4899 13fc 04070000 		.4byte	.LASF182
 4900 1400 01       		.byte	0x1
 4901 1401 E402     		.2byte	0x2e4
 4902 1403 B5080000 		.4byte	0x8b5
 4903 1407 02       		.uleb128 0x2
 4904 1408 91       		.byte	0x91
 4905 1409 58       		.sleb128 -40
 4906 140a 24       		.uleb128 0x24
 4907 140b 85090000 		.4byte	.LASF194
 4908 140f 01       		.byte	0x1
 4909 1410 E402     		.2byte	0x2e4
 4910 1412 1B090000 		.4byte	0x91b
 4911 1416 02       		.uleb128 0x2
 4912 1417 91       		.byte	0x91
 4913 1418 54       		.sleb128 -44
 4914 1419 24       		.uleb128 0x24
 4915 141a 8E060000 		.4byte	.LASF202
ARM GAS  /tmp/ccdqkONZ.s 			page 133


 4916 141e 01       		.byte	0x1
 4917 141f E402     		.2byte	0x2e4
 4918 1421 01090000 		.4byte	0x901
 4919 1425 02       		.uleb128 0x2
 4920 1426 91       		.byte	0x91
 4921 1427 50       		.sleb128 -48
 4922 1428 25       		.uleb128 0x25
 4923 1429 AE030000 		.4byte	.LASF195
 4924 142d 01       		.byte	0x1
 4925 142e E602     		.2byte	0x2e6
 4926 1430 F6080000 		.4byte	0x8f6
 4927 1434 02       		.uleb128 0x2
 4928 1435 91       		.byte	0x91
 4929 1436 74       		.sleb128 -12
 4930 1437 25       		.uleb128 0x25
 4931 1438 73020000 		.4byte	.LASF205
 4932 143c 01       		.byte	0x1
 4933 143d E602     		.2byte	0x2e6
 4934 143f F6080000 		.4byte	0x8f6
 4935 1443 02       		.uleb128 0x2
 4936 1444 91       		.byte	0x91
 4937 1445 6C       		.sleb128 -20
 4938 1446 25       		.uleb128 0x25
 4939 1447 C3030000 		.4byte	.LASF196
 4940 144b 01       		.byte	0x1
 4941 144c E702     		.2byte	0x2e7
 4942 144e 450A0000 		.4byte	0xa45
 4943 1452 02       		.uleb128 0x2
 4944 1453 91       		.byte	0x91
 4945 1454 64       		.sleb128 -28
 4946 1455 25       		.uleb128 0x25
 4947 1456 A0080000 		.4byte	.LASF173
 4948 145a 01       		.byte	0x1
 4949 145b E802     		.2byte	0x2e8
 4950 145d D70B0000 		.4byte	0xbd7
 4951 1461 02       		.uleb128 0x2
 4952 1462 91       		.byte	0x91
 4953 1463 70       		.sleb128 -16
 4954 1464 00       		.byte	0
 4955 1465 27       		.uleb128 0x27
 4956 1466 43020000 		.4byte	.LASF206
 4957 146a 01       		.byte	0x1
 4958 146b A601     		.2byte	0x1a6
 4959 146d 04010000 		.4byte	.LFB7
 4960 1471 3E000000 		.4byte	.LFE7-.LFB7
 4961 1475 01       		.uleb128 0x1
 4962 1476 9C       		.byte	0x9c
 4963 1477 C7140000 		.4byte	0x14c7
 4964 147b 24       		.uleb128 0x24
 4965 147c 48070000 		.4byte	.LASF207
 4966 1480 01       		.byte	0x1
 4967 1481 A601     		.2byte	0x1a6
 4968 1483 16090000 		.4byte	0x916
 4969 1487 02       		.uleb128 0x2
 4970 1488 91       		.byte	0x91
 4971 1489 74       		.sleb128 -12
 4972 148a 24       		.uleb128 0x24
ARM GAS  /tmp/ccdqkONZ.s 			page 134


 4973 148b 6F040000 		.4byte	.LASF157
 4974 148f 01       		.byte	0x1
 4975 1490 A601     		.2byte	0x1a6
 4976 1492 16090000 		.4byte	0x916
 4977 1496 02       		.uleb128 0x2
 4978 1497 91       		.byte	0x91
 4979 1498 70       		.sleb128 -16
 4980 1499 24       		.uleb128 0x24
 4981 149a 57060000 		.4byte	.LASF208
 4982 149e 01       		.byte	0x1
 4983 149f A601     		.2byte	0x1a6
 4984 14a1 26090000 		.4byte	0x926
 4985 14a5 02       		.uleb128 0x2
 4986 14a6 91       		.byte	0x91
 4987 14a7 6C       		.sleb128 -20
 4988 14a8 24       		.uleb128 0x24
 4989 14a9 F8060000 		.4byte	.LASF209
 4990 14ad 01       		.byte	0x1
 4991 14ae A601     		.2byte	0x1a6
 4992 14b0 DB080000 		.4byte	0x8db
 4993 14b4 02       		.uleb128 0x2
 4994 14b5 91       		.byte	0x91
 4995 14b6 6B       		.sleb128 -21
 4996 14b7 24       		.uleb128 0x24
 4997 14b8 B9020000 		.4byte	.LASF210
 4998 14bc 01       		.byte	0x1
 4999 14bd A601     		.2byte	0x1a6
 5000 14bf D10B0000 		.4byte	0xbd1
 5001 14c3 02       		.uleb128 0x2
 5002 14c4 91       		.byte	0x91
 5003 14c5 00       		.sleb128 0
 5004 14c6 00       		.byte	0
 5005 14c7 2B       		.uleb128 0x2b
 5006 14c8 AF050000 		.4byte	.LASF211
 5007 14cc 01       		.byte	0x1
 5008 14cd 7001     		.2byte	0x170
 5009 14cf 500A0000 		.4byte	0xa50
 5010 14d3 B4000000 		.4byte	.LFB6
 5011 14d7 50000000 		.4byte	.LFE6-.LFB6
 5012 14db 01       		.uleb128 0x1
 5013 14dc 9C       		.byte	0x9c
 5014 14dd 3C150000 		.4byte	0x153c
 5015 14e1 24       		.uleb128 0x24
 5016 14e2 48070000 		.4byte	.LASF207
 5017 14e6 01       		.byte	0x1
 5018 14e7 7001     		.2byte	0x170
 5019 14e9 16090000 		.4byte	0x916
 5020 14ed 02       		.uleb128 0x2
 5021 14ee 91       		.byte	0x91
 5022 14ef 64       		.sleb128 -28
 5023 14f0 24       		.uleb128 0x24
 5024 14f1 6F040000 		.4byte	.LASF157
 5025 14f5 01       		.byte	0x1
 5026 14f6 7001     		.2byte	0x170
 5027 14f8 16090000 		.4byte	0x916
 5028 14fc 02       		.uleb128 0x2
 5029 14fd 91       		.byte	0x91
ARM GAS  /tmp/ccdqkONZ.s 			page 135


 5030 14fe 60       		.sleb128 -32
 5031 14ff 24       		.uleb128 0x24
 5032 1500 F8060000 		.4byte	.LASF209
 5033 1504 01       		.byte	0x1
 5034 1505 7001     		.2byte	0x170
 5035 1507 DB080000 		.4byte	0x8db
 5036 150b 02       		.uleb128 0x2
 5037 150c 91       		.byte	0x91
 5038 150d 5F       		.sleb128 -33
 5039 150e 25       		.uleb128 0x25
 5040 150f B9020000 		.4byte	.LASF210
 5041 1513 01       		.byte	0x1
 5042 1514 7201     		.2byte	0x172
 5043 1516 D10B0000 		.4byte	0xbd1
 5044 151a 02       		.uleb128 0x2
 5045 151b 91       		.byte	0x91
 5046 151c 70       		.sleb128 -16
 5047 151d 25       		.uleb128 0x25
 5048 151e CA070000 		.4byte	.LASF212
 5049 1522 01       		.byte	0x1
 5050 1523 7301     		.2byte	0x173
 5051 1525 25000000 		.4byte	0x25
 5052 1529 02       		.uleb128 0x2
 5053 152a 91       		.byte	0x91
 5054 152b 74       		.sleb128 -12
 5055 152c 25       		.uleb128 0x25
 5056 152d 57060000 		.4byte	.LASF208
 5057 1531 01       		.byte	0x1
 5058 1532 7401     		.2byte	0x174
 5059 1534 26090000 		.4byte	0x926
 5060 1538 02       		.uleb128 0x2
 5061 1539 91       		.byte	0x91
 5062 153a 6C       		.sleb128 -20
 5063 153b 00       		.byte	0
 5064 153c 30       		.uleb128 0x30
 5065 153d D1090000 		.4byte	.LASF213
 5066 1541 01       		.byte	0x1
 5067 1542 FF       		.byte	0xff
 5068 1543 F6080000 		.4byte	0x8f6
 5069 1547 00000000 		.4byte	.LFB5
 5070 154b B4000000 		.4byte	.LFE5-.LFB5
 5071 154f 01       		.uleb128 0x1
 5072 1550 9C       		.byte	0x9c
 5073 1551 81150000 		.4byte	0x1581
 5074 1555 31       		.uleb128 0x31
 5075 1556 A3020000 		.4byte	.LASF168
 5076 155a 01       		.byte	0x1
 5077 155b FF       		.byte	0xff
 5078 155c 500A0000 		.4byte	0xa50
 5079 1560 02       		.uleb128 0x2
 5080 1561 91       		.byte	0x91
 5081 1562 6C       		.sleb128 -20
 5082 1563 31       		.uleb128 0x31
 5083 1564 9A0A0000 		.4byte	.LASF214
 5084 1568 01       		.byte	0x1
 5085 1569 FF       		.byte	0xff
 5086 156a F6080000 		.4byte	0x8f6
ARM GAS  /tmp/ccdqkONZ.s 			page 136


 5087 156e 02       		.uleb128 0x2
 5088 156f 91       		.byte	0x91
 5089 1570 68       		.sleb128 -24
 5090 1571 25       		.uleb128 0x25
 5091 1572 A0080000 		.4byte	.LASF173
 5092 1576 01       		.byte	0x1
 5093 1577 0101     		.2byte	0x101
 5094 1579 D70B0000 		.4byte	0xbd7
 5095 157d 02       		.uleb128 0x2
 5096 157e 91       		.byte	0x91
 5097 157f 74       		.sleb128 -12
 5098 1580 00       		.byte	0
 5099 1581 32       		.uleb128 0x32
 5100 1582 3D040000 		.4byte	.LASF215
 5101 1586 02       		.byte	0x2
 5102 1587 E5       		.byte	0xe5
 5103 1588 03       		.byte	0x3
 5104 1589 99150000 		.4byte	0x1599
 5105 158d 33       		.uleb128 0x33
 5106 158e E0060000 		.4byte	.LASF224
 5107 1592 02       		.byte	0x2
 5108 1593 E5       		.byte	0xe5
 5109 1594 E0080000 		.4byte	0x8e0
 5110 1598 00       		.byte	0
 5111 1599 34       		.uleb128 0x34
 5112 159a CC030000 		.4byte	.LASF216
 5113 159e 02       		.byte	0x2
 5114 159f D1       		.byte	0xd1
 5115 15a0 E0080000 		.4byte	0x8e0
 5116 15a4 03       		.byte	0x3
 5117 15a5 35       		.uleb128 0x35
 5118 15a6 89020000 		.4byte	.LASF217
 5119 15aa 02       		.byte	0x2
 5120 15ab D3       		.byte	0xd3
 5121 15ac E0080000 		.4byte	0x8e0
 5122 15b0 35       		.uleb128 0x35
 5123 15b1 01050000 		.4byte	.LASF218
 5124 15b5 02       		.byte	0x2
 5125 15b6 D3       		.byte	0xd3
 5126 15b7 E0080000 		.4byte	0x8e0
 5127 15bb 00       		.byte	0
 5128 15bc 00       		.byte	0
 5129              		.section	.debug_abbrev,"",%progbits
 5130              	.Ldebug_abbrev0:
 5131 0000 01       		.uleb128 0x1
 5132 0001 11       		.uleb128 0x11
 5133 0002 01       		.byte	0x1
 5134 0003 25       		.uleb128 0x25
 5135 0004 0E       		.uleb128 0xe
 5136 0005 13       		.uleb128 0x13
 5137 0006 0B       		.uleb128 0xb
 5138 0007 03       		.uleb128 0x3
 5139 0008 0E       		.uleb128 0xe
 5140 0009 1B       		.uleb128 0x1b
 5141 000a 0E       		.uleb128 0xe
 5142 000b 11       		.uleb128 0x11
 5143 000c 01       		.uleb128 0x1
ARM GAS  /tmp/ccdqkONZ.s 			page 137


 5144 000d 12       		.uleb128 0x12
 5145 000e 06       		.uleb128 0x6
 5146 000f 10       		.uleb128 0x10
 5147 0010 17       		.uleb128 0x17
 5148 0011 00       		.byte	0
 5149 0012 00       		.byte	0
 5150 0013 02       		.uleb128 0x2
 5151 0014 16       		.uleb128 0x16
 5152 0015 00       		.byte	0
 5153 0016 03       		.uleb128 0x3
 5154 0017 0E       		.uleb128 0xe
 5155 0018 3A       		.uleb128 0x3a
 5156 0019 0B       		.uleb128 0xb
 5157 001a 3B       		.uleb128 0x3b
 5158 001b 0B       		.uleb128 0xb
 5159 001c 49       		.uleb128 0x49
 5160 001d 13       		.uleb128 0x13
 5161 001e 00       		.byte	0
 5162 001f 00       		.byte	0
 5163 0020 03       		.uleb128 0x3
 5164 0021 24       		.uleb128 0x24
 5165 0022 00       		.byte	0
 5166 0023 0B       		.uleb128 0xb
 5167 0024 0B       		.uleb128 0xb
 5168 0025 3E       		.uleb128 0x3e
 5169 0026 0B       		.uleb128 0xb
 5170 0027 03       		.uleb128 0x3
 5171 0028 0E       		.uleb128 0xe
 5172 0029 00       		.byte	0
 5173 002a 00       		.byte	0
 5174 002b 04       		.uleb128 0x4
 5175 002c 24       		.uleb128 0x24
 5176 002d 00       		.byte	0
 5177 002e 0B       		.uleb128 0xb
 5178 002f 0B       		.uleb128 0xb
 5179 0030 3E       		.uleb128 0x3e
 5180 0031 0B       		.uleb128 0xb
 5181 0032 03       		.uleb128 0x3
 5182 0033 08       		.uleb128 0x8
 5183 0034 00       		.byte	0
 5184 0035 00       		.byte	0
 5185 0036 05       		.uleb128 0x5
 5186 0037 16       		.uleb128 0x16
 5187 0038 00       		.byte	0
 5188 0039 03       		.uleb128 0x3
 5189 003a 0E       		.uleb128 0xe
 5190 003b 3A       		.uleb128 0x3a
 5191 003c 0B       		.uleb128 0xb
 5192 003d 3B       		.uleb128 0x3b
 5193 003e 05       		.uleb128 0x5
 5194 003f 49       		.uleb128 0x49
 5195 0040 13       		.uleb128 0x13
 5196 0041 00       		.byte	0
 5197 0042 00       		.byte	0
 5198 0043 06       		.uleb128 0x6
 5199 0044 17       		.uleb128 0x17
 5200 0045 01       		.byte	0x1
ARM GAS  /tmp/ccdqkONZ.s 			page 138


 5201 0046 0B       		.uleb128 0xb
 5202 0047 0B       		.uleb128 0xb
 5203 0048 3A       		.uleb128 0x3a
 5204 0049 0B       		.uleb128 0xb
 5205 004a 3B       		.uleb128 0x3b
 5206 004b 0B       		.uleb128 0xb
 5207 004c 01       		.uleb128 0x1
 5208 004d 13       		.uleb128 0x13
 5209 004e 00       		.byte	0
 5210 004f 00       		.byte	0
 5211 0050 07       		.uleb128 0x7
 5212 0051 0D       		.uleb128 0xd
 5213 0052 00       		.byte	0
 5214 0053 03       		.uleb128 0x3
 5215 0054 0E       		.uleb128 0xe
 5216 0055 3A       		.uleb128 0x3a
 5217 0056 0B       		.uleb128 0xb
 5218 0057 3B       		.uleb128 0x3b
 5219 0058 0B       		.uleb128 0xb
 5220 0059 49       		.uleb128 0x49
 5221 005a 13       		.uleb128 0x13
 5222 005b 00       		.byte	0
 5223 005c 00       		.byte	0
 5224 005d 08       		.uleb128 0x8
 5225 005e 01       		.uleb128 0x1
 5226 005f 01       		.byte	0x1
 5227 0060 49       		.uleb128 0x49
 5228 0061 13       		.uleb128 0x13
 5229 0062 01       		.uleb128 0x1
 5230 0063 13       		.uleb128 0x13
 5231 0064 00       		.byte	0
 5232 0065 00       		.byte	0
 5233 0066 09       		.uleb128 0x9
 5234 0067 21       		.uleb128 0x21
 5235 0068 00       		.byte	0
 5236 0069 49       		.uleb128 0x49
 5237 006a 13       		.uleb128 0x13
 5238 006b 2F       		.uleb128 0x2f
 5239 006c 0B       		.uleb128 0xb
 5240 006d 00       		.byte	0
 5241 006e 00       		.byte	0
 5242 006f 0A       		.uleb128 0xa
 5243 0070 13       		.uleb128 0x13
 5244 0071 01       		.byte	0x1
 5245 0072 0B       		.uleb128 0xb
 5246 0073 0B       		.uleb128 0xb
 5247 0074 3A       		.uleb128 0x3a
 5248 0075 0B       		.uleb128 0xb
 5249 0076 3B       		.uleb128 0x3b
 5250 0077 0B       		.uleb128 0xb
 5251 0078 01       		.uleb128 0x1
 5252 0079 13       		.uleb128 0x13
 5253 007a 00       		.byte	0
 5254 007b 00       		.byte	0
 5255 007c 0B       		.uleb128 0xb
 5256 007d 0D       		.uleb128 0xd
 5257 007e 00       		.byte	0
ARM GAS  /tmp/ccdqkONZ.s 			page 139


 5258 007f 03       		.uleb128 0x3
 5259 0080 0E       		.uleb128 0xe
 5260 0081 3A       		.uleb128 0x3a
 5261 0082 0B       		.uleb128 0xb
 5262 0083 3B       		.uleb128 0x3b
 5263 0084 0B       		.uleb128 0xb
 5264 0085 49       		.uleb128 0x49
 5265 0086 13       		.uleb128 0x13
 5266 0087 38       		.uleb128 0x38
 5267 0088 0B       		.uleb128 0xb
 5268 0089 00       		.byte	0
 5269 008a 00       		.byte	0
 5270 008b 0C       		.uleb128 0xc
 5271 008c 0F       		.uleb128 0xf
 5272 008d 00       		.byte	0
 5273 008e 0B       		.uleb128 0xb
 5274 008f 0B       		.uleb128 0xb
 5275 0090 00       		.byte	0
 5276 0091 00       		.byte	0
 5277 0092 0D       		.uleb128 0xd
 5278 0093 26       		.uleb128 0x26
 5279 0094 00       		.byte	0
 5280 0095 49       		.uleb128 0x49
 5281 0096 13       		.uleb128 0x13
 5282 0097 00       		.byte	0
 5283 0098 00       		.byte	0
 5284 0099 0E       		.uleb128 0xe
 5285 009a 0F       		.uleb128 0xf
 5286 009b 00       		.byte	0
 5287 009c 0B       		.uleb128 0xb
 5288 009d 0B       		.uleb128 0xb
 5289 009e 49       		.uleb128 0x49
 5290 009f 13       		.uleb128 0x13
 5291 00a0 00       		.byte	0
 5292 00a1 00       		.byte	0
 5293 00a2 0F       		.uleb128 0xf
 5294 00a3 13       		.uleb128 0x13
 5295 00a4 01       		.byte	0x1
 5296 00a5 03       		.uleb128 0x3
 5297 00a6 0E       		.uleb128 0xe
 5298 00a7 0B       		.uleb128 0xb
 5299 00a8 0B       		.uleb128 0xb
 5300 00a9 3A       		.uleb128 0x3a
 5301 00aa 0B       		.uleb128 0xb
 5302 00ab 3B       		.uleb128 0x3b
 5303 00ac 0B       		.uleb128 0xb
 5304 00ad 01       		.uleb128 0x1
 5305 00ae 13       		.uleb128 0x13
 5306 00af 00       		.byte	0
 5307 00b0 00       		.byte	0
 5308 00b1 10       		.uleb128 0x10
 5309 00b2 0D       		.uleb128 0xd
 5310 00b3 00       		.byte	0
 5311 00b4 03       		.uleb128 0x3
 5312 00b5 08       		.uleb128 0x8
 5313 00b6 3A       		.uleb128 0x3a
 5314 00b7 0B       		.uleb128 0xb
ARM GAS  /tmp/ccdqkONZ.s 			page 140


 5315 00b8 3B       		.uleb128 0x3b
 5316 00b9 0B       		.uleb128 0xb
 5317 00ba 49       		.uleb128 0x49
 5318 00bb 13       		.uleb128 0x13
 5319 00bc 38       		.uleb128 0x38
 5320 00bd 0B       		.uleb128 0xb
 5321 00be 00       		.byte	0
 5322 00bf 00       		.byte	0
 5323 00c0 11       		.uleb128 0x11
 5324 00c1 13       		.uleb128 0x13
 5325 00c2 01       		.byte	0x1
 5326 00c3 03       		.uleb128 0x3
 5327 00c4 0E       		.uleb128 0xe
 5328 00c5 0B       		.uleb128 0xb
 5329 00c6 05       		.uleb128 0x5
 5330 00c7 3A       		.uleb128 0x3a
 5331 00c8 0B       		.uleb128 0xb
 5332 00c9 3B       		.uleb128 0x3b
 5333 00ca 0B       		.uleb128 0xb
 5334 00cb 01       		.uleb128 0x1
 5335 00cc 13       		.uleb128 0x13
 5336 00cd 00       		.byte	0
 5337 00ce 00       		.byte	0
 5338 00cf 12       		.uleb128 0x12
 5339 00d0 0D       		.uleb128 0xd
 5340 00d1 00       		.byte	0
 5341 00d2 03       		.uleb128 0x3
 5342 00d3 0E       		.uleb128 0xe
 5343 00d4 3A       		.uleb128 0x3a
 5344 00d5 0B       		.uleb128 0xb
 5345 00d6 3B       		.uleb128 0x3b
 5346 00d7 0B       		.uleb128 0xb
 5347 00d8 49       		.uleb128 0x49
 5348 00d9 13       		.uleb128 0x13
 5349 00da 38       		.uleb128 0x38
 5350 00db 05       		.uleb128 0x5
 5351 00dc 00       		.byte	0
 5352 00dd 00       		.byte	0
 5353 00de 13       		.uleb128 0x13
 5354 00df 15       		.uleb128 0x15
 5355 00e0 00       		.byte	0
 5356 00e1 27       		.uleb128 0x27
 5357 00e2 19       		.uleb128 0x19
 5358 00e3 00       		.byte	0
 5359 00e4 00       		.byte	0
 5360 00e5 14       		.uleb128 0x14
 5361 00e6 15       		.uleb128 0x15
 5362 00e7 01       		.byte	0x1
 5363 00e8 27       		.uleb128 0x27
 5364 00e9 19       		.uleb128 0x19
 5365 00ea 49       		.uleb128 0x49
 5366 00eb 13       		.uleb128 0x13
 5367 00ec 01       		.uleb128 0x1
 5368 00ed 13       		.uleb128 0x13
 5369 00ee 00       		.byte	0
 5370 00ef 00       		.byte	0
 5371 00f0 15       		.uleb128 0x15
ARM GAS  /tmp/ccdqkONZ.s 			page 141


 5372 00f1 05       		.uleb128 0x5
 5373 00f2 00       		.byte	0
 5374 00f3 49       		.uleb128 0x49
 5375 00f4 13       		.uleb128 0x13
 5376 00f5 00       		.byte	0
 5377 00f6 00       		.byte	0
 5378 00f7 16       		.uleb128 0x16
 5379 00f8 13       		.uleb128 0x13
 5380 00f9 01       		.byte	0x1
 5381 00fa 03       		.uleb128 0x3
 5382 00fb 0E       		.uleb128 0xe
 5383 00fc 0B       		.uleb128 0xb
 5384 00fd 05       		.uleb128 0x5
 5385 00fe 3A       		.uleb128 0x3a
 5386 00ff 0B       		.uleb128 0xb
 5387 0100 3B       		.uleb128 0x3b
 5388 0101 05       		.uleb128 0x5
 5389 0102 01       		.uleb128 0x1
 5390 0103 13       		.uleb128 0x13
 5391 0104 00       		.byte	0
 5392 0105 00       		.byte	0
 5393 0106 17       		.uleb128 0x17
 5394 0107 0D       		.uleb128 0xd
 5395 0108 00       		.byte	0
 5396 0109 03       		.uleb128 0x3
 5397 010a 0E       		.uleb128 0xe
 5398 010b 3A       		.uleb128 0x3a
 5399 010c 0B       		.uleb128 0xb
 5400 010d 3B       		.uleb128 0x3b
 5401 010e 05       		.uleb128 0x5
 5402 010f 49       		.uleb128 0x49
 5403 0110 13       		.uleb128 0x13
 5404 0111 38       		.uleb128 0x38
 5405 0112 0B       		.uleb128 0xb
 5406 0113 00       		.byte	0
 5407 0114 00       		.byte	0
 5408 0115 18       		.uleb128 0x18
 5409 0116 0D       		.uleb128 0xd
 5410 0117 00       		.byte	0
 5411 0118 03       		.uleb128 0x3
 5412 0119 0E       		.uleb128 0xe
 5413 011a 3A       		.uleb128 0x3a
 5414 011b 0B       		.uleb128 0xb
 5415 011c 3B       		.uleb128 0x3b
 5416 011d 05       		.uleb128 0x5
 5417 011e 49       		.uleb128 0x49
 5418 011f 13       		.uleb128 0x13
 5419 0120 38       		.uleb128 0x38
 5420 0121 05       		.uleb128 0x5
 5421 0122 00       		.byte	0
 5422 0123 00       		.byte	0
 5423 0124 19       		.uleb128 0x19
 5424 0125 13       		.uleb128 0x13
 5425 0126 01       		.byte	0x1
 5426 0127 03       		.uleb128 0x3
 5427 0128 0E       		.uleb128 0xe
 5428 0129 0B       		.uleb128 0xb
ARM GAS  /tmp/ccdqkONZ.s 			page 142


 5429 012a 0B       		.uleb128 0xb
 5430 012b 3A       		.uleb128 0x3a
 5431 012c 0B       		.uleb128 0xb
 5432 012d 3B       		.uleb128 0x3b
 5433 012e 05       		.uleb128 0x5
 5434 012f 01       		.uleb128 0x1
 5435 0130 13       		.uleb128 0x13
 5436 0131 00       		.byte	0
 5437 0132 00       		.byte	0
 5438 0133 1A       		.uleb128 0x1a
 5439 0134 13       		.uleb128 0x13
 5440 0135 01       		.byte	0x1
 5441 0136 0B       		.uleb128 0xb
 5442 0137 0B       		.uleb128 0xb
 5443 0138 3A       		.uleb128 0x3a
 5444 0139 0B       		.uleb128 0xb
 5445 013a 3B       		.uleb128 0x3b
 5446 013b 05       		.uleb128 0x5
 5447 013c 01       		.uleb128 0x1
 5448 013d 13       		.uleb128 0x13
 5449 013e 00       		.byte	0
 5450 013f 00       		.byte	0
 5451 0140 1B       		.uleb128 0x1b
 5452 0141 17       		.uleb128 0x17
 5453 0142 01       		.byte	0x1
 5454 0143 0B       		.uleb128 0xb
 5455 0144 0B       		.uleb128 0xb
 5456 0145 3A       		.uleb128 0x3a
 5457 0146 0B       		.uleb128 0xb
 5458 0147 3B       		.uleb128 0x3b
 5459 0148 05       		.uleb128 0x5
 5460 0149 01       		.uleb128 0x1
 5461 014a 13       		.uleb128 0x13
 5462 014b 00       		.byte	0
 5463 014c 00       		.byte	0
 5464 014d 1C       		.uleb128 0x1c
 5465 014e 0D       		.uleb128 0xd
 5466 014f 00       		.byte	0
 5467 0150 03       		.uleb128 0x3
 5468 0151 0E       		.uleb128 0xe
 5469 0152 3A       		.uleb128 0x3a
 5470 0153 0B       		.uleb128 0xb
 5471 0154 3B       		.uleb128 0x3b
 5472 0155 05       		.uleb128 0x5
 5473 0156 49       		.uleb128 0x49
 5474 0157 13       		.uleb128 0x13
 5475 0158 00       		.byte	0
 5476 0159 00       		.byte	0
 5477 015a 1D       		.uleb128 0x1d
 5478 015b 15       		.uleb128 0x15
 5479 015c 01       		.byte	0x1
 5480 015d 27       		.uleb128 0x27
 5481 015e 19       		.uleb128 0x19
 5482 015f 01       		.uleb128 0x1
 5483 0160 13       		.uleb128 0x13
 5484 0161 00       		.byte	0
 5485 0162 00       		.byte	0
ARM GAS  /tmp/ccdqkONZ.s 			page 143


 5486 0163 1E       		.uleb128 0x1e
 5487 0164 34       		.uleb128 0x34
 5488 0165 00       		.byte	0
 5489 0166 03       		.uleb128 0x3
 5490 0167 0E       		.uleb128 0xe
 5491 0168 3A       		.uleb128 0x3a
 5492 0169 0B       		.uleb128 0xb
 5493 016a 3B       		.uleb128 0x3b
 5494 016b 05       		.uleb128 0x5
 5495 016c 49       		.uleb128 0x49
 5496 016d 13       		.uleb128 0x13
 5497 016e 3F       		.uleb128 0x3f
 5498 016f 19       		.uleb128 0x19
 5499 0170 3C       		.uleb128 0x3c
 5500 0171 19       		.uleb128 0x19
 5501 0172 00       		.byte	0
 5502 0173 00       		.byte	0
 5503 0174 1F       		.uleb128 0x1f
 5504 0175 26       		.uleb128 0x26
 5505 0176 00       		.byte	0
 5506 0177 00       		.byte	0
 5507 0178 00       		.byte	0
 5508 0179 20       		.uleb128 0x20
 5509 017a 35       		.uleb128 0x35
 5510 017b 00       		.byte	0
 5511 017c 49       		.uleb128 0x49
 5512 017d 13       		.uleb128 0x13
 5513 017e 00       		.byte	0
 5514 017f 00       		.byte	0
 5515 0180 21       		.uleb128 0x21
 5516 0181 34       		.uleb128 0x34
 5517 0182 00       		.byte	0
 5518 0183 03       		.uleb128 0x3
 5519 0184 0E       		.uleb128 0xe
 5520 0185 3A       		.uleb128 0x3a
 5521 0186 0B       		.uleb128 0xb
 5522 0187 3B       		.uleb128 0x3b
 5523 0188 0B       		.uleb128 0xb
 5524 0189 49       		.uleb128 0x49
 5525 018a 13       		.uleb128 0x13
 5526 018b 3F       		.uleb128 0x3f
 5527 018c 19       		.uleb128 0x19
 5528 018d 3C       		.uleb128 0x3c
 5529 018e 19       		.uleb128 0x19
 5530 018f 00       		.byte	0
 5531 0190 00       		.byte	0
 5532 0191 22       		.uleb128 0x22
 5533 0192 13       		.uleb128 0x13
 5534 0193 00       		.byte	0
 5535 0194 03       		.uleb128 0x3
 5536 0195 0E       		.uleb128 0xe
 5537 0196 3C       		.uleb128 0x3c
 5538 0197 19       		.uleb128 0x19
 5539 0198 00       		.byte	0
 5540 0199 00       		.byte	0
 5541 019a 23       		.uleb128 0x23
 5542 019b 2E       		.uleb128 0x2e
ARM GAS  /tmp/ccdqkONZ.s 			page 144


 5543 019c 01       		.byte	0x1
 5544 019d 3F       		.uleb128 0x3f
 5545 019e 19       		.uleb128 0x19
 5546 019f 03       		.uleb128 0x3
 5547 01a0 0E       		.uleb128 0xe
 5548 01a1 3A       		.uleb128 0x3a
 5549 01a2 0B       		.uleb128 0xb
 5550 01a3 3B       		.uleb128 0x3b
 5551 01a4 05       		.uleb128 0x5
 5552 01a5 27       		.uleb128 0x27
 5553 01a6 19       		.uleb128 0x19
 5554 01a7 49       		.uleb128 0x49
 5555 01a8 13       		.uleb128 0x13
 5556 01a9 11       		.uleb128 0x11
 5557 01aa 01       		.uleb128 0x1
 5558 01ab 12       		.uleb128 0x12
 5559 01ac 06       		.uleb128 0x6
 5560 01ad 40       		.uleb128 0x40
 5561 01ae 18       		.uleb128 0x18
 5562 01af 9742     		.uleb128 0x2117
 5563 01b1 19       		.uleb128 0x19
 5564 01b2 01       		.uleb128 0x1
 5565 01b3 13       		.uleb128 0x13
 5566 01b4 00       		.byte	0
 5567 01b5 00       		.byte	0
 5568 01b6 24       		.uleb128 0x24
 5569 01b7 05       		.uleb128 0x5
 5570 01b8 00       		.byte	0
 5571 01b9 03       		.uleb128 0x3
 5572 01ba 0E       		.uleb128 0xe
 5573 01bb 3A       		.uleb128 0x3a
 5574 01bc 0B       		.uleb128 0xb
 5575 01bd 3B       		.uleb128 0x3b
 5576 01be 05       		.uleb128 0x5
 5577 01bf 49       		.uleb128 0x49
 5578 01c0 13       		.uleb128 0x13
 5579 01c1 02       		.uleb128 0x2
 5580 01c2 18       		.uleb128 0x18
 5581 01c3 00       		.byte	0
 5582 01c4 00       		.byte	0
 5583 01c5 25       		.uleb128 0x25
 5584 01c6 34       		.uleb128 0x34
 5585 01c7 00       		.byte	0
 5586 01c8 03       		.uleb128 0x3
 5587 01c9 0E       		.uleb128 0xe
 5588 01ca 3A       		.uleb128 0x3a
 5589 01cb 0B       		.uleb128 0xb
 5590 01cc 3B       		.uleb128 0x3b
 5591 01cd 05       		.uleb128 0x5
 5592 01ce 49       		.uleb128 0x49
 5593 01cf 13       		.uleb128 0x13
 5594 01d0 02       		.uleb128 0x2
 5595 01d1 18       		.uleb128 0x18
 5596 01d2 00       		.byte	0
 5597 01d3 00       		.byte	0
 5598 01d4 26       		.uleb128 0x26
 5599 01d5 2E       		.uleb128 0x2e
ARM GAS  /tmp/ccdqkONZ.s 			page 145


 5600 01d6 01       		.byte	0x1
 5601 01d7 03       		.uleb128 0x3
 5602 01d8 0E       		.uleb128 0xe
 5603 01d9 3A       		.uleb128 0x3a
 5604 01da 0B       		.uleb128 0xb
 5605 01db 3B       		.uleb128 0x3b
 5606 01dc 05       		.uleb128 0x5
 5607 01dd 27       		.uleb128 0x27
 5608 01de 19       		.uleb128 0x19
 5609 01df 49       		.uleb128 0x49
 5610 01e0 13       		.uleb128 0x13
 5611 01e1 11       		.uleb128 0x11
 5612 01e2 01       		.uleb128 0x1
 5613 01e3 12       		.uleb128 0x12
 5614 01e4 06       		.uleb128 0x6
 5615 01e5 40       		.uleb128 0x40
 5616 01e6 18       		.uleb128 0x18
 5617 01e7 9642     		.uleb128 0x2116
 5618 01e9 19       		.uleb128 0x19
 5619 01ea 01       		.uleb128 0x1
 5620 01eb 13       		.uleb128 0x13
 5621 01ec 00       		.byte	0
 5622 01ed 00       		.byte	0
 5623 01ee 27       		.uleb128 0x27
 5624 01ef 2E       		.uleb128 0x2e
 5625 01f0 01       		.byte	0x1
 5626 01f1 03       		.uleb128 0x3
 5627 01f2 0E       		.uleb128 0xe
 5628 01f3 3A       		.uleb128 0x3a
 5629 01f4 0B       		.uleb128 0xb
 5630 01f5 3B       		.uleb128 0x3b
 5631 01f6 05       		.uleb128 0x5
 5632 01f7 27       		.uleb128 0x27
 5633 01f8 19       		.uleb128 0x19
 5634 01f9 11       		.uleb128 0x11
 5635 01fa 01       		.uleb128 0x1
 5636 01fb 12       		.uleb128 0x12
 5637 01fc 06       		.uleb128 0x6
 5638 01fd 40       		.uleb128 0x40
 5639 01fe 18       		.uleb128 0x18
 5640 01ff 9642     		.uleb128 0x2116
 5641 0201 19       		.uleb128 0x19
 5642 0202 01       		.uleb128 0x1
 5643 0203 13       		.uleb128 0x13
 5644 0204 00       		.byte	0
 5645 0205 00       		.byte	0
 5646 0206 28       		.uleb128 0x28
 5647 0207 0B       		.uleb128 0xb
 5648 0208 01       		.byte	0x1
 5649 0209 11       		.uleb128 0x11
 5650 020a 01       		.uleb128 0x1
 5651 020b 12       		.uleb128 0x12
 5652 020c 06       		.uleb128 0x6
 5653 020d 01       		.uleb128 0x1
 5654 020e 13       		.uleb128 0x13
 5655 020f 00       		.byte	0
 5656 0210 00       		.byte	0
ARM GAS  /tmp/ccdqkONZ.s 			page 146


 5657 0211 29       		.uleb128 0x29
 5658 0212 0B       		.uleb128 0xb
 5659 0213 01       		.byte	0x1
 5660 0214 11       		.uleb128 0x11
 5661 0215 01       		.uleb128 0x1
 5662 0216 12       		.uleb128 0x12
 5663 0217 06       		.uleb128 0x6
 5664 0218 00       		.byte	0
 5665 0219 00       		.byte	0
 5666 021a 2A       		.uleb128 0x2a
 5667 021b 2E       		.uleb128 0x2e
 5668 021c 01       		.byte	0x1
 5669 021d 3F       		.uleb128 0x3f
 5670 021e 19       		.uleb128 0x19
 5671 021f 03       		.uleb128 0x3
 5672 0220 0E       		.uleb128 0xe
 5673 0221 3A       		.uleb128 0x3a
 5674 0222 0B       		.uleb128 0xb
 5675 0223 3B       		.uleb128 0x3b
 5676 0224 05       		.uleb128 0x5
 5677 0225 27       		.uleb128 0x27
 5678 0226 19       		.uleb128 0x19
 5679 0227 11       		.uleb128 0x11
 5680 0228 01       		.uleb128 0x1
 5681 0229 12       		.uleb128 0x12
 5682 022a 06       		.uleb128 0x6
 5683 022b 40       		.uleb128 0x40
 5684 022c 18       		.uleb128 0x18
 5685 022d 9642     		.uleb128 0x2116
 5686 022f 19       		.uleb128 0x19
 5687 0230 01       		.uleb128 0x1
 5688 0231 13       		.uleb128 0x13
 5689 0232 00       		.byte	0
 5690 0233 00       		.byte	0
 5691 0234 2B       		.uleb128 0x2b
 5692 0235 2E       		.uleb128 0x2e
 5693 0236 01       		.byte	0x1
 5694 0237 3F       		.uleb128 0x3f
 5695 0238 19       		.uleb128 0x19
 5696 0239 03       		.uleb128 0x3
 5697 023a 0E       		.uleb128 0xe
 5698 023b 3A       		.uleb128 0x3a
 5699 023c 0B       		.uleb128 0xb
 5700 023d 3B       		.uleb128 0x3b
 5701 023e 05       		.uleb128 0x5
 5702 023f 27       		.uleb128 0x27
 5703 0240 19       		.uleb128 0x19
 5704 0241 49       		.uleb128 0x49
 5705 0242 13       		.uleb128 0x13
 5706 0243 11       		.uleb128 0x11
 5707 0244 01       		.uleb128 0x1
 5708 0245 12       		.uleb128 0x12
 5709 0246 06       		.uleb128 0x6
 5710 0247 40       		.uleb128 0x40
 5711 0248 18       		.uleb128 0x18
 5712 0249 9642     		.uleb128 0x2116
 5713 024b 19       		.uleb128 0x19
ARM GAS  /tmp/ccdqkONZ.s 			page 147


 5714 024c 01       		.uleb128 0x1
 5715 024d 13       		.uleb128 0x13
 5716 024e 00       		.byte	0
 5717 024f 00       		.byte	0
 5718 0250 2C       		.uleb128 0x2c
 5719 0251 1D       		.uleb128 0x1d
 5720 0252 01       		.byte	0x1
 5721 0253 31       		.uleb128 0x31
 5722 0254 13       		.uleb128 0x13
 5723 0255 11       		.uleb128 0x11
 5724 0256 01       		.uleb128 0x1
 5725 0257 12       		.uleb128 0x12
 5726 0258 06       		.uleb128 0x6
 5727 0259 58       		.uleb128 0x58
 5728 025a 0B       		.uleb128 0xb
 5729 025b 59       		.uleb128 0x59
 5730 025c 05       		.uleb128 0x5
 5731 025d 01       		.uleb128 0x1
 5732 025e 13       		.uleb128 0x13
 5733 025f 00       		.byte	0
 5734 0260 00       		.byte	0
 5735 0261 2D       		.uleb128 0x2d
 5736 0262 34       		.uleb128 0x34
 5737 0263 00       		.byte	0
 5738 0264 31       		.uleb128 0x31
 5739 0265 13       		.uleb128 0x13
 5740 0266 02       		.uleb128 0x2
 5741 0267 18       		.uleb128 0x18
 5742 0268 00       		.byte	0
 5743 0269 00       		.byte	0
 5744 026a 2E       		.uleb128 0x2e
 5745 026b 1D       		.uleb128 0x1d
 5746 026c 01       		.byte	0x1
 5747 026d 31       		.uleb128 0x31
 5748 026e 13       		.uleb128 0x13
 5749 026f 11       		.uleb128 0x11
 5750 0270 01       		.uleb128 0x1
 5751 0271 12       		.uleb128 0x12
 5752 0272 06       		.uleb128 0x6
 5753 0273 58       		.uleb128 0x58
 5754 0274 0B       		.uleb128 0xb
 5755 0275 59       		.uleb128 0x59
 5756 0276 05       		.uleb128 0x5
 5757 0277 00       		.byte	0
 5758 0278 00       		.byte	0
 5759 0279 2F       		.uleb128 0x2f
 5760 027a 05       		.uleb128 0x5
 5761 027b 00       		.byte	0
 5762 027c 31       		.uleb128 0x31
 5763 027d 13       		.uleb128 0x13
 5764 027e 02       		.uleb128 0x2
 5765 027f 18       		.uleb128 0x18
 5766 0280 00       		.byte	0
 5767 0281 00       		.byte	0
 5768 0282 30       		.uleb128 0x30
 5769 0283 2E       		.uleb128 0x2e
 5770 0284 01       		.byte	0x1
ARM GAS  /tmp/ccdqkONZ.s 			page 148


 5771 0285 3F       		.uleb128 0x3f
 5772 0286 19       		.uleb128 0x19
 5773 0287 03       		.uleb128 0x3
 5774 0288 0E       		.uleb128 0xe
 5775 0289 3A       		.uleb128 0x3a
 5776 028a 0B       		.uleb128 0xb
 5777 028b 3B       		.uleb128 0x3b
 5778 028c 0B       		.uleb128 0xb
 5779 028d 27       		.uleb128 0x27
 5780 028e 19       		.uleb128 0x19
 5781 028f 49       		.uleb128 0x49
 5782 0290 13       		.uleb128 0x13
 5783 0291 11       		.uleb128 0x11
 5784 0292 01       		.uleb128 0x1
 5785 0293 12       		.uleb128 0x12
 5786 0294 06       		.uleb128 0x6
 5787 0295 40       		.uleb128 0x40
 5788 0296 18       		.uleb128 0x18
 5789 0297 9642     		.uleb128 0x2116
 5790 0299 19       		.uleb128 0x19
 5791 029a 01       		.uleb128 0x1
 5792 029b 13       		.uleb128 0x13
 5793 029c 00       		.byte	0
 5794 029d 00       		.byte	0
 5795 029e 31       		.uleb128 0x31
 5796 029f 05       		.uleb128 0x5
 5797 02a0 00       		.byte	0
 5798 02a1 03       		.uleb128 0x3
 5799 02a2 0E       		.uleb128 0xe
 5800 02a3 3A       		.uleb128 0x3a
 5801 02a4 0B       		.uleb128 0xb
 5802 02a5 3B       		.uleb128 0x3b
 5803 02a6 0B       		.uleb128 0xb
 5804 02a7 49       		.uleb128 0x49
 5805 02a8 13       		.uleb128 0x13
 5806 02a9 02       		.uleb128 0x2
 5807 02aa 18       		.uleb128 0x18
 5808 02ab 00       		.byte	0
 5809 02ac 00       		.byte	0
 5810 02ad 32       		.uleb128 0x32
 5811 02ae 2E       		.uleb128 0x2e
 5812 02af 01       		.byte	0x1
 5813 02b0 03       		.uleb128 0x3
 5814 02b1 0E       		.uleb128 0xe
 5815 02b2 3A       		.uleb128 0x3a
 5816 02b3 0B       		.uleb128 0xb
 5817 02b4 3B       		.uleb128 0x3b
 5818 02b5 0B       		.uleb128 0xb
 5819 02b6 27       		.uleb128 0x27
 5820 02b7 19       		.uleb128 0x19
 5821 02b8 20       		.uleb128 0x20
 5822 02b9 0B       		.uleb128 0xb
 5823 02ba 01       		.uleb128 0x1
 5824 02bb 13       		.uleb128 0x13
 5825 02bc 00       		.byte	0
 5826 02bd 00       		.byte	0
 5827 02be 33       		.uleb128 0x33
ARM GAS  /tmp/ccdqkONZ.s 			page 149


 5828 02bf 05       		.uleb128 0x5
 5829 02c0 00       		.byte	0
 5830 02c1 03       		.uleb128 0x3
 5831 02c2 0E       		.uleb128 0xe
 5832 02c3 3A       		.uleb128 0x3a
 5833 02c4 0B       		.uleb128 0xb
 5834 02c5 3B       		.uleb128 0x3b
 5835 02c6 0B       		.uleb128 0xb
 5836 02c7 49       		.uleb128 0x49
 5837 02c8 13       		.uleb128 0x13
 5838 02c9 00       		.byte	0
 5839 02ca 00       		.byte	0
 5840 02cb 34       		.uleb128 0x34
 5841 02cc 2E       		.uleb128 0x2e
 5842 02cd 01       		.byte	0x1
 5843 02ce 03       		.uleb128 0x3
 5844 02cf 0E       		.uleb128 0xe
 5845 02d0 3A       		.uleb128 0x3a
 5846 02d1 0B       		.uleb128 0xb
 5847 02d2 3B       		.uleb128 0x3b
 5848 02d3 0B       		.uleb128 0xb
 5849 02d4 27       		.uleb128 0x27
 5850 02d5 19       		.uleb128 0x19
 5851 02d6 49       		.uleb128 0x49
 5852 02d7 13       		.uleb128 0x13
 5853 02d8 20       		.uleb128 0x20
 5854 02d9 0B       		.uleb128 0xb
 5855 02da 00       		.byte	0
 5856 02db 00       		.byte	0
 5857 02dc 35       		.uleb128 0x35
 5858 02dd 34       		.uleb128 0x34
 5859 02de 00       		.byte	0
 5860 02df 03       		.uleb128 0x3
 5861 02e0 0E       		.uleb128 0xe
 5862 02e1 3A       		.uleb128 0x3a
 5863 02e2 0B       		.uleb128 0xb
 5864 02e3 3B       		.uleb128 0x3b
 5865 02e4 0B       		.uleb128 0xb
 5866 02e5 49       		.uleb128 0x49
 5867 02e6 13       		.uleb128 0x13
 5868 02e7 00       		.byte	0
 5869 02e8 00       		.byte	0
 5870 02e9 00       		.byte	0
 5871              		.section	.debug_aranges,"",%progbits
 5872 0000 1C000000 		.4byte	0x1c
 5873 0004 0200     		.2byte	0x2
 5874 0006 00000000 		.4byte	.Ldebug_info0
 5875 000a 04       		.byte	0x4
 5876 000b 00       		.byte	0
 5877 000c 0000     		.2byte	0
 5878 000e 0000     		.2byte	0
 5879 0010 00000000 		.4byte	.Ltext0
 5880 0014 AE0B0000 		.4byte	.Letext0-.Ltext0
 5881 0018 00000000 		.4byte	0
 5882 001c 00000000 		.4byte	0
 5883              		.section	.debug_line,"",%progbits
 5884              	.Ldebug_line0:
ARM GAS  /tmp/ccdqkONZ.s 			page 150


 5885 0000 19040000 		.section	.debug_str,"MS",%progbits,1
 5885      02006001 
 5885      00000201 
 5885      FB0E0D00 
 5885      01010101 
 5886              	.LASF137:
 5887 0000 75784E75 		.ascii	"uxNumberOfItems\000"
 5887      6D626572 
 5887      4F664974 
 5887      656D7300 
 5888              	.LASF219:
 5889 0010 474E5520 		.ascii	"GNU C99 6.3.1 20170620 -mthumb -mcpu=cortex-m3 -g -"
 5889      43393920 
 5889      362E332E 
 5889      31203230 
 5889      31373036 
 5890 0043 7374643D 		.ascii	"std=c99 -fno-common\000"
 5890      63393920 
 5890      2D666E6F 
 5890      2D636F6D 
 5890      6D6F6E00 
 5891              	.LASF41:
 5892 0057 5F6F6E5F 		.ascii	"_on_exit_args\000"
 5892      65786974 
 5892      5F617267 
 5892      7300
 5893              	.LASF164:
 5894 0065 53656D61 		.ascii	"SemaphoreData\000"
 5894      70686F72 
 5894      65446174 
 5894      6100
 5895              	.LASF108:
 5896 0073 5F776374 		.ascii	"_wctomb_state\000"
 5896      6F6D625F 
 5896      73746174 
 5896      6500
 5897              	.LASF222:
 5898 0081 74736B54 		.ascii	"tskTaskControlBlock\000"
 5898      61736B43 
 5898      6F6E7472 
 5898      6F6C426C 
 5898      6F636B00 
 5899              	.LASF167:
 5900 0095 53656D61 		.ascii	"SemaphoreData_t\000"
 5900      70686F72 
 5900      65446174 
 5900      615F7400 
 5901              	.LASF105:
 5902 00a5 5F723438 		.ascii	"_r48\000"
 5902      00
 5903              	.LASF199:
 5904 00aa 78517565 		.ascii	"xQueueReceive\000"
 5904      75655265 
 5904      63656976 
 5904      6500
 5905              	.LASF191:
 5906 00b8 78517565 		.ascii	"xQueueReceiveFromISR\000"
ARM GAS  /tmp/ccdqkONZ.s 			page 151


 5906      75655265 
 5906      63656976 
 5906      6546726F 
 5906      6D495352 
 5907              	.LASF154:
 5908 00cd 78546173 		.ascii	"xTasksWaitingToReceive\000"
 5908      6B735761 
 5908      6974696E 
 5908      67546F52 
 5908      65636569 
 5909              	.LASF192:
 5910 00e4 70784869 		.ascii	"pxHigherPriorityTaskWoken\000"
 5910      67686572 
 5910      5072696F 
 5910      72697479 
 5910      5461736B 
 5911              	.LASF110:
 5912 00fe 5F736967 		.ascii	"_signal_buf\000"
 5912      6E616C5F 
 5912      62756600 
 5913              	.LASF0:
 5914 010a 756E7369 		.ascii	"unsigned int\000"
 5914      676E6564 
 5914      20696E74 
 5914      00
 5915              	.LASF138:
 5916 0117 7078496E 		.ascii	"pxIndex\000"
 5916      64657800 
 5917              	.LASF145:
 5918 011f 7854494D 		.ascii	"xTIME_OUT\000"
 5918      455F4F55 
 5918      5400
 5919              	.LASF55:
 5920 0129 5F6C6266 		.ascii	"_lbfsize\000"
 5920      73697A65 
 5920      00
 5921              	.LASF53:
 5922 0132 5F666C61 		.ascii	"_flags\000"
 5922      677300
 5923              	.LASF223:
 5924 0139 76517565 		.ascii	"vQueueDelete\000"
 5924      75654465 
 5924      6C657465 
 5924      00
 5925              	.LASF130:
 5926 0146 784C4953 		.ascii	"xLIST_ITEM\000"
 5926      545F4954 
 5926      454D00
 5927              	.LASF70:
 5928 0151 5F657272 		.ascii	"_errno\000"
 5928      6E6F00
 5929              	.LASF201:
 5930 0158 78517565 		.ascii	"xQueueGenericSendFromISR\000"
 5930      75654765 
 5930      6E657269 
 5930      6353656E 
 5930      6446726F 
ARM GAS  /tmp/ccdqkONZ.s 			page 152


 5931              	.LASF153:
 5932 0171 78546173 		.ascii	"xTasksWaitingToSend\000"
 5932      6B735761 
 5932      6974696E 
 5932      67546F53 
 5932      656E6400 
 5933              	.LASF13:
 5934 0185 5F4C4F43 		.ascii	"_LOCK_RECURSIVE_T\000"
 5934      4B5F5245 
 5934      43555253 
 5934      4956455F 
 5934      5400
 5935              	.LASF186:
 5936 0197 75785175 		.ascii	"uxQueueSpacesAvailable\000"
 5936      65756553 
 5936      70616365 
 5936      73417661 
 5936      696C6162 
 5937              	.LASF57:
 5938 01ae 5F726561 		.ascii	"_read\000"
 5938      6400
 5939              	.LASF159:
 5940 01b4 6354784C 		.ascii	"cTxLock\000"
 5940      6F636B00 
 5941              	.LASF112:
 5942 01bc 5F6D6272 		.ascii	"_mbrlen_state\000"
 5942      6C656E5F 
 5942      73746174 
 5942      6500
 5943              	.LASF146:
 5944 01ca 784F7665 		.ascii	"xOverflowCount\000"
 5944      72666C6F 
 5944      77436F75 
 5944      6E7400
 5945              	.LASF72:
 5946 01d9 5F737464 		.ascii	"_stdout\000"
 5946      6F757400 
 5947              	.LASF15:
 5948 01e1 5F66706F 		.ascii	"_fpos_t\000"
 5948      735F7400 
 5949              	.LASF171:
 5950 01e9 51756575 		.ascii	"Queue_t\000"
 5950      655F7400 
 5951              	.LASF48:
 5952 01f1 5F666E73 		.ascii	"_fns\000"
 5952      00
 5953              	.LASF56:
 5954 01f6 5F636F6F 		.ascii	"_cookie\000"
 5954      6B696500 
 5955              	.LASF185:
 5956 01fe 75785265 		.ascii	"uxReturn\000"
 5956      7475726E 
 5956      00
 5957              	.LASF30:
 5958 0207 5F426967 		.ascii	"_Bigint\000"
 5958      696E7400 
 5959              	.LASF38:
ARM GAS  /tmp/ccdqkONZ.s 			page 153


 5960 020f 5F5F746D 		.ascii	"__tm_wday\000"
 5960      5F776461 
 5960      7900
 5961              	.LASF162:
 5962 0219 70635265 		.ascii	"pcReadFrom\000"
 5962      61644672 
 5962      6F6D00
 5963              	.LASF80:
 5964 0224 5F726573 		.ascii	"_result\000"
 5964      756C7400 
 5965              	.LASF189:
 5966 022c 75785361 		.ascii	"uxSavedInterruptStatus\000"
 5966      76656449 
 5966      6E746572 
 5966      72757074 
 5966      53746174 
 5967              	.LASF206:
 5968 0243 70727649 		.ascii	"prvInitialiseNewQueue\000"
 5968      6E697469 
 5968      616C6973 
 5968      654E6577 
 5968      51756575 
 5969              	.LASF125:
 5970 0259 75696E74 		.ascii	"uint32_t\000"
 5970      33325F74 
 5970      00
 5971              	.LASF123:
 5972 0262 696E7438 		.ascii	"int8_t\000"
 5972      5F7400
 5973              	.LASF34:
 5974 0269 5F5F746D 		.ascii	"__tm_hour\000"
 5974      5F686F75 
 5974      7200
 5975              	.LASF205:
 5976 0273 78596965 		.ascii	"xYieldRequired\000"
 5976      6C645265 
 5976      71756972 
 5976      656400
 5977              	.LASF71:
 5978 0282 5F737464 		.ascii	"_stdin\000"
 5978      696E00
 5979              	.LASF217:
 5980 0289 756C4F72 		.ascii	"ulOriginalBASEPRI\000"
 5980      6967696E 
 5980      616C4241 
 5980      53455052 
 5980      4900
 5981              	.LASF20:
 5982 029b 5F5F636F 		.ascii	"__count\000"
 5982      756E7400 
 5983              	.LASF168:
 5984 02a3 78517565 		.ascii	"xQueue\000"
 5984      756500
 5985              	.LASF178:
 5986 02aa 70727655 		.ascii	"prvUnlockQueue\000"
 5986      6E6C6F63 
 5986      6B517565 
ARM GAS  /tmp/ccdqkONZ.s 			page 154


 5986      756500
 5987              	.LASF210:
 5988 02b9 70784E65 		.ascii	"pxNewQueue\000"
 5988      77517565 
 5988      756500
 5989              	.LASF33:
 5990 02c4 5F5F746D 		.ascii	"__tm_min\000"
 5990      5F6D696E 
 5990      00
 5991              	.LASF121:
 5992 02cd 5F696D70 		.ascii	"_impure_ptr\000"
 5992      7572655F 
 5992      70747200 
 5993              	.LASF150:
 5994 02d9 51756575 		.ascii	"QueueDefinition\000"
 5994      65446566 
 5994      696E6974 
 5994      696F6E00 
 5995              	.LASF118:
 5996 02e9 5F6E6578 		.ascii	"_nextf\000"
 5996      746600
 5997              	.LASF95:
 5998 02f0 5F72616E 		.ascii	"_rand48\000"
 5998      64343800 
 5999              	.LASF81:
 6000 02f8 5F726573 		.ascii	"_result_k\000"
 6000      756C745F 
 6000      6B00
 6001              	.LASF12:
 6002 0302 6C6F6E67 		.ascii	"long long unsigned int\000"
 6002      206C6F6E 
 6002      6720756E 
 6002      7369676E 
 6002      65642069 
 6003              	.LASF220:
 6004 0319 46726565 		.ascii	"FreeRTOS/Source/queue.c\000"
 6004      52544F53 
 6004      2F536F75 
 6004      7263652F 
 6004      71756575 
 6005              	.LASF101:
 6006 0331 5F617363 		.ascii	"_asctime_buf\000"
 6006      74696D65 
 6006      5F627566 
 6006      00
 6007              	.LASF52:
 6008 033e 5F5F7346 		.ascii	"__sFILE\000"
 6008      494C4500 
 6009              	.LASF29:
 6010 0346 5F776473 		.ascii	"_wds\000"
 6010      00
 6011              	.LASF180:
 6012 034b 70764275 		.ascii	"pvBuffer\000"
 6012      66666572 
 6012      00
 6013              	.LASF133:
 6014 0354 70785072 		.ascii	"pxPrevious\000"
ARM GAS  /tmp/ccdqkONZ.s 			page 155


 6014      6576696F 
 6014      757300
 6015              	.LASF155:
 6016 035f 75784D65 		.ascii	"uxMessagesWaiting\000"
 6016      73736167 
 6016      65735761 
 6016      6974696E 
 6016      6700
 6017              	.LASF169:
 6018 0371 7853656D 		.ascii	"xSemaphore\000"
 6018      6170686F 
 6018      726500
 6019              	.LASF91:
 6020 037c 5F5F4649 		.ascii	"__FILE\000"
 6020      4C4500
 6021              	.LASF64:
 6022 0383 5F6F6666 		.ascii	"_offset\000"
 6022      73657400 
 6023              	.LASF193:
 6024 038b 78517565 		.ascii	"xQueuePeek\000"
 6024      75655065 
 6024      656B00
 6025              	.LASF165:
 6026 0396 784D7574 		.ascii	"xMutexHolder\000"
 6026      6578486F 
 6026      6C646572 
 6026      00
 6027              	.LASF75:
 6028 03a3 5F656D65 		.ascii	"_emergency\000"
 6028      7267656E 
 6028      637900
 6029              	.LASF195:
 6030 03ae 78456E74 		.ascii	"xEntryTimeSet\000"
 6030      72795469 
 6030      6D655365 
 6030      7400
 6031              	.LASF1:
 6032 03bc 73697A65 		.ascii	"size_t\000"
 6032      5F7400
 6033              	.LASF196:
 6034 03c3 7854696D 		.ascii	"xTimeOut\000"
 6034      654F7574 
 6034      00
 6035              	.LASF216:
 6036 03cc 756C506F 		.ascii	"ulPortRaiseBASEPRI\000"
 6036      72745261 
 6036      69736542 
 6036      41534550 
 6036      524900
 6037              	.LASF32:
 6038 03df 5F5F746D 		.ascii	"__tm_sec\000"
 6038      5F736563 
 6038      00
 6039              	.LASF39:
 6040 03e8 5F5F746D 		.ascii	"__tm_yday\000"
 6040      5F796461 
 6040      7900
ARM GAS  /tmp/ccdqkONZ.s 			page 156


 6041              	.LASF74:
 6042 03f2 5F696E63 		.ascii	"_inc\000"
 6042      00
 6043              	.LASF47:
 6044 03f7 5F696E64 		.ascii	"_ind\000"
 6044      00
 6045              	.LASF136:
 6046 03fc 784C4953 		.ascii	"xLIST\000"
 6046      5400
 6047              	.LASF141:
 6048 0402 784D494E 		.ascii	"xMINI_LIST_ITEM\000"
 6048      495F4C49 
 6048      53545F49 
 6048      54454D00 
 6049              	.LASF26:
 6050 0412 5F6E6578 		.ascii	"_next\000"
 6050      7400
 6051              	.LASF114:
 6052 0418 5F6D6273 		.ascii	"_mbsrtowcs_state\000"
 6052      72746F77 
 6052      63735F73 
 6052      74617465 
 6052      00
 6053              	.LASF197:
 6054 0429 78517565 		.ascii	"xQueueSemaphoreTake\000"
 6054      75655365 
 6054      6D617068 
 6054      6F726554 
 6054      616B6500 
 6055              	.LASF215:
 6056 043d 76506F72 		.ascii	"vPortSetBASEPRI\000"
 6056      74536574 
 6056      42415345 
 6056      50524900 
 6057              	.LASF172:
 6058 044d 78526574 		.ascii	"xReturn\000"
 6058      75726E00 
 6059              	.LASF204:
 6060 0455 78517565 		.ascii	"xQueueGenericSend\000"
 6060      75654765 
 6060      6E657269 
 6060      6353656E 
 6060      6400
 6061              	.LASF21:
 6062 0467 5F5F7661 		.ascii	"__value\000"
 6062      6C756500 
 6063              	.LASF157:
 6064 046f 75784974 		.ascii	"uxItemSize\000"
 6064      656D5369 
 6064      7A6500
 6065              	.LASF82:
 6066 047a 5F703573 		.ascii	"_p5s\000"
 6066      00
 6067              	.LASF203:
 6068 047f 75785072 		.ascii	"uxPreviousMessagesWaiting\000"
 6068      6576696F 
 6068      75734D65 
ARM GAS  /tmp/ccdqkONZ.s 			page 157


 6068      73736167 
 6068      65735761 
 6069              	.LASF116:
 6070 0499 5F776373 		.ascii	"_wcsrtombs_state\000"
 6070      72746F6D 
 6070      62735F73 
 6070      74617465 
 6070      00
 6071              	.LASF106:
 6072 04aa 5F6D626C 		.ascii	"_mblen_state\000"
 6072      656E5F73 
 6072      74617465 
 6072      00
 6073              	.LASF24:
 6074 04b7 63686172 		.ascii	"char\000"
 6074      00
 6075              	.LASF35:
 6076 04bc 5F5F746D 		.ascii	"__tm_mday\000"
 6076      5F6D6461 
 6076      7900
 6077              	.LASF140:
 6078 04c6 4C697374 		.ascii	"ListItem_t\000"
 6078      4974656D 
 6078      5F7400
 6079              	.LASF88:
 6080 04d1 5F736967 		.ascii	"_sig_func\000"
 6080      5F66756E 
 6080      6300
 6081              	.LASF113:
 6082 04db 5F6D6272 		.ascii	"_mbrtowc_state\000"
 6082      746F7763 
 6082      5F737461 
 6082      746500
 6083              	.LASF87:
 6084 04ea 5F617465 		.ascii	"_atexit0\000"
 6084      78697430 
 6084      00
 6085              	.LASF160:
 6086 04f3 51756575 		.ascii	"QueuePointers\000"
 6086      65506F69 
 6086      6E746572 
 6086      7300
 6087              	.LASF218:
 6088 0501 756C4E65 		.ascii	"ulNewBASEPRI\000"
 6088      77424153 
 6088      45505249 
 6088      00
 6089              	.LASF128:
 6090 050e 55426173 		.ascii	"UBaseType_t\000"
 6090      65547970 
 6090      655F7400 
 6091              	.LASF200:
 6092 051a 78517565 		.ascii	"xQueueGiveFromISR\000"
 6092      75654769 
 6092      76654672 
 6092      6F6D4953 
 6092      5200
ARM GAS  /tmp/ccdqkONZ.s 			page 158


 6093              	.LASF149:
 6094 052c 51756575 		.ascii	"QueueHandle_t\000"
 6094      6548616E 
 6094      646C655F 
 6094      7400
 6095              	.LASF139:
 6096 053a 784C6973 		.ascii	"xListEnd\000"
 6096      74456E64 
 6096      00
 6097              	.LASF23:
 6098 0543 5F666C6F 		.ascii	"_flock_t\000"
 6098      636B5F74 
 6098      00
 6099              	.LASF184:
 6100 054c 75785175 		.ascii	"uxQueueMessagesWaitingFromISR\000"
 6100      6575654D 
 6100      65737361 
 6100      67657357 
 6100      61697469 
 6101              	.LASF142:
 6102 056a 4D696E69 		.ascii	"MiniListItem_t\000"
 6102      4C697374 
 6102      4974656D 
 6102      5F7400
 6103              	.LASF17:
 6104 0579 5F5F7763 		.ascii	"__wch\000"
 6104      6800
 6105              	.LASF94:
 6106 057f 5F696F62 		.ascii	"_iobs\000"
 6106      7300
 6107              	.LASF124:
 6108 0585 75696E74 		.ascii	"uint8_t\000"
 6108      385F7400 
 6109              	.LASF60:
 6110 058d 5F636C6F 		.ascii	"_close\000"
 6110      736500
 6111              	.LASF78:
 6112 0594 5F5F7364 		.ascii	"__sdidinit\000"
 6112      6964696E 
 6112      697400
 6113              	.LASF177:
 6114 059f 70727649 		.ascii	"prvIsQueueEmpty\000"
 6114      73517565 
 6114      7565456D 
 6114      70747900 
 6115              	.LASF211:
 6116 05af 78517565 		.ascii	"xQueueGenericCreate\000"
 6116      75654765 
 6116      6E657269 
 6116      63437265 
 6116      61746500 
 6117              	.LASF221:
 6118 05c3 2F686F6D 		.ascii	"/home/sls/workspace/stm32f103c8-blink\000"
 6118      652F736C 
 6118      732F776F 
 6118      726B7370 
 6118      6163652F 
ARM GAS  /tmp/ccdqkONZ.s 			page 159


 6119              	.LASF103:
 6120 05e9 5F67616D 		.ascii	"_gamma_signgam\000"
 6120      6D615F73 
 6120      69676E67 
 6120      616D00
 6121              	.LASF183:
 6122 05f8 78506F73 		.ascii	"xPosition\000"
 6122      6974696F 
 6122      6E00
 6123              	.LASF11:
 6124 0602 6C6F6E67 		.ascii	"long long int\000"
 6124      206C6F6E 
 6124      6720696E 
 6124      7400
 6125              	.LASF176:
 6126 0610 70727649 		.ascii	"prvIsQueueFull\000"
 6126      73517565 
 6126      75654675 
 6126      6C6C00
 6127              	.LASF50:
 6128 061f 5F626173 		.ascii	"_base\000"
 6128      6500
 6129              	.LASF83:
 6130 0625 5F667265 		.ascii	"_freelist\000"
 6130      656C6973 
 6130      7400
 6131              	.LASF97:
 6132 062f 5F6D756C 		.ascii	"_mult\000"
 6132      7400
 6133              	.LASF25:
 6134 0635 5F5F554C 		.ascii	"__ULong\000"
 6134      6F6E6700 
 6135              	.LASF115:
 6136 063d 5F776372 		.ascii	"_wcrtomb_state\000"
 6136      746F6D62 
 6136      5F737461 
 6136      746500
 6137              	.LASF127:
 6138 064c 42617365 		.ascii	"BaseType_t\000"
 6138      54797065 
 6138      5F7400
 6139              	.LASF208:
 6140 0657 70756351 		.ascii	"pucQueueStorage\000"
 6140      75657565 
 6140      53746F72 
 6140      61676500 
 6141              	.LASF54:
 6142 0667 5F66696C 		.ascii	"_file\000"
 6142      6500
 6143              	.LASF147:
 6144 066d 7854696D 		.ascii	"xTimeOnEntering\000"
 6144      654F6E45 
 6144      6E746572 
 6144      696E6700 
 6145              	.LASF132:
 6146 067d 70784E65 		.ascii	"pxNext\000"
 6146      787400
ARM GAS  /tmp/ccdqkONZ.s 			page 160


 6147              	.LASF79:
 6148 0684 5F5F636C 		.ascii	"__cleanup\000"
 6148      65616E75 
 6148      7000
 6149              	.LASF202:
 6150 068e 78436F70 		.ascii	"xCopyPosition\000"
 6150      79506F73 
 6150      6974696F 
 6150      6E00
 6151              	.LASF22:
 6152 069c 5F6D6273 		.ascii	"_mbstate_t\000"
 6152      74617465 
 6152      5F7400
 6153              	.LASF148:
 6154 06a7 54696D65 		.ascii	"TimeOut_t\000"
 6154      4F75745F 
 6154      7400
 6155              	.LASF40:
 6156 06b1 5F5F746D 		.ascii	"__tm_isdst\000"
 6156      5F697364 
 6156      737400
 6157              	.LASF190:
 6158 06bc 70634F72 		.ascii	"pcOriginalReadPosition\000"
 6158      6967696E 
 6158      616C5265 
 6158      6164506F 
 6158      73697469 
 6159              	.LASF144:
 6160 06d3 5461736B 		.ascii	"TaskHandle_t\000"
 6160      48616E64 
 6160      6C655F74 
 6160      00
 6161              	.LASF224:
 6162 06e0 756C4E65 		.ascii	"ulNewMaskValue\000"
 6162      774D6173 
 6162      6B56616C 
 6162      756500
 6163              	.LASF117:
 6164 06ef 5F685F65 		.ascii	"_h_errno\000"
 6164      72726E6F 
 6164      00
 6165              	.LASF209:
 6166 06f8 75635175 		.ascii	"ucQueueType\000"
 6166      65756554 
 6166      79706500 
 6167              	.LASF182:
 6168 0704 70764974 		.ascii	"pvItemToQueue\000"
 6168      656D546F 
 6168      51756575 
 6168      6500
 6169              	.LASF143:
 6170 0712 4C697374 		.ascii	"List_t\000"
 6170      5F7400
 6171              	.LASF198:
 6172 0719 75785365 		.ascii	"uxSemaphoreCount\000"
 6172      6D617068 
 6172      6F726543 
ARM GAS  /tmp/ccdqkONZ.s 			page 161


 6172      6F756E74 
 6172      00
 6173              	.LASF152:
 6174 072a 70635772 		.ascii	"pcWriteTo\000"
 6174      69746554 
 6174      6F00
 6175              	.LASF129:
 6176 0734 5469636B 		.ascii	"TickType_t\000"
 6176      54797065 
 6176      5F7400
 6177              	.LASF2:
 6178 073f 5F5F696E 		.ascii	"__int8_t\000"
 6178      74385F74 
 6178      00
 6179              	.LASF207:
 6180 0748 75785175 		.ascii	"uxQueueLength\000"
 6180      6575654C 
 6180      656E6774 
 6180      6800
 6181              	.LASF36:
 6182 0756 5F5F746D 		.ascii	"__tm_mon\000"
 6182      5F6D6F6E 
 6182      00
 6183              	.LASF126:
 6184 075f 53797374 		.ascii	"SystemCoreClock\000"
 6184      656D436F 
 6184      7265436C 
 6184      6F636B00 
 6185              	.LASF58:
 6186 076f 5F777269 		.ascii	"_write\000"
 6186      746500
 6187              	.LASF135:
 6188 0776 7076436F 		.ascii	"pvContainer\000"
 6188      6E746169 
 6188      6E657200 
 6189              	.LASF46:
 6190 0782 5F617465 		.ascii	"_atexit\000"
 6190      78697400 
 6191              	.LASF67:
 6192 078a 5F6D6273 		.ascii	"_mbstate\000"
 6192      74617465 
 6192      00
 6193              	.LASF163:
 6194 0793 51756575 		.ascii	"QueuePointers_t\000"
 6194      65506F69 
 6194      6E746572 
 6194      735F7400 
 6195              	.LASF156:
 6196 07a3 75784C65 		.ascii	"uxLength\000"
 6196      6E677468 
 6196      00
 6197              	.LASF6:
 6198 07ac 73686F72 		.ascii	"short int\000"
 6198      7420696E 
 6198      7400
 6199              	.LASF131:
 6200 07b6 78497465 		.ascii	"xItemValue\000"
ARM GAS  /tmp/ccdqkONZ.s 			page 162


 6200      6D56616C 
 6200      756500
 6201              	.LASF8:
 6202 07c1 6C6F6E67 		.ascii	"long int\000"
 6202      20696E74 
 6202      00
 6203              	.LASF212:
 6204 07ca 78517565 		.ascii	"xQueueSizeInBytes\000"
 6204      75655369 
 6204      7A65496E 
 6204      42797465 
 6204      7300
 6205              	.LASF90:
 6206 07dc 5F5F7366 		.ascii	"__sf\000"
 6206      00
 6207              	.LASF28:
 6208 07e1 5F736967 		.ascii	"_sign\000"
 6208      6E00
 6209              	.LASF77:
 6210 07e7 5F637572 		.ascii	"_current_locale\000"
 6210      72656E74 
 6210      5F6C6F63 
 6210      616C6500 
 6211              	.LASF65:
 6212 07f7 5F646174 		.ascii	"_data\000"
 6212      6100
 6213              	.LASF18:
 6214 07fd 5F5F7763 		.ascii	"__wchb\000"
 6214      686200
 6215              	.LASF122:
 6216 0804 5F676C6F 		.ascii	"_global_impure_ptr\000"
 6216      62616C5F 
 6216      696D7075 
 6216      72655F70 
 6216      747200
 6217              	.LASF37:
 6218 0817 5F5F746D 		.ascii	"__tm_year\000"
 6218      5F796561 
 6218      7200
 6219              	.LASF158:
 6220 0821 6352784C 		.ascii	"cRxLock\000"
 6220      6F636B00 
 6221              	.LASF174:
 6222 0829 78517565 		.ascii	"xQueueIsQueueFullFromISR\000"
 6222      75654973 
 6222      51756575 
 6222      6546756C 
 6222      6C46726F 
 6223              	.LASF187:
 6224 0842 75785175 		.ascii	"uxQueueMessagesWaiting\000"
 6224      6575654D 
 6224      65737361 
 6224      67657357 
 6224      61697469 
 6225              	.LASF161:
 6226 0859 70635461 		.ascii	"pcTail\000"
 6226      696C00
ARM GAS  /tmp/ccdqkONZ.s 			page 163


 6227              	.LASF102:
 6228 0860 5F6C6F63 		.ascii	"_localtime_buf\000"
 6228      616C7469 
 6228      6D655F62 
 6228      756600
 6229              	.LASF120:
 6230 086f 5F756E75 		.ascii	"_unused\000"
 6230      73656400 
 6231              	.LASF4:
 6232 0877 5F5F7569 		.ascii	"__uint8_t\000"
 6232      6E74385F 
 6232      7400
 6233              	.LASF86:
 6234 0881 5F6E6577 		.ascii	"_new\000"
 6234      00
 6235              	.LASF84:
 6236 0886 5F637674 		.ascii	"_cvtlen\000"
 6236      6C656E00 
 6237              	.LASF27:
 6238 088e 5F6D6178 		.ascii	"_maxwds\000"
 6238      77647300 
 6239              	.LASF109:
 6240 0896 5F6C3634 		.ascii	"_l64a_buf\000"
 6240      615F6275 
 6240      6600
 6241              	.LASF173:
 6242 08a0 70785175 		.ascii	"pxQueue\000"
 6242      65756500 
 6243              	.LASF76:
 6244 08a8 5F637572 		.ascii	"_current_category\000"
 6244      72656E74 
 6244      5F636174 
 6244      65676F72 
 6244      7900
 6245              	.LASF63:
 6246 08ba 5F626C6B 		.ascii	"_blksize\000"
 6246      73697A65 
 6246      00
 6247              	.LASF31:
 6248 08c3 5F5F746D 		.ascii	"__tm\000"
 6248      00
 6249              	.LASF66:
 6250 08c8 5F6C6F63 		.ascii	"_lock\000"
 6250      6B00
 6251              	.LASF19:
 6252 08ce 73697A65 		.ascii	"sizetype\000"
 6252      74797065 
 6252      00
 6253              	.LASF10:
 6254 08d7 6C6F6E67 		.ascii	"long unsigned int\000"
 6254      20756E73 
 6254      69676E65 
 6254      6420696E 
 6254      7400
 6255              	.LASF93:
 6256 08e9 5F6E696F 		.ascii	"_niobs\000"
 6256      627300
ARM GAS  /tmp/ccdqkONZ.s 			page 164


 6257              	.LASF16:
 6258 08f0 77696E74 		.ascii	"wint_t\000"
 6258      5F7400
 6259              	.LASF166:
 6260 08f7 75785265 		.ascii	"uxRecursiveCallCount\000"
 6260      63757273 
 6260      69766543 
 6260      616C6C43 
 6260      6F756E74 
 6261              	.LASF188:
 6262 090c 78517565 		.ascii	"xQueuePeekFromISR\000"
 6262      75655065 
 6262      656B4672 
 6262      6F6D4953 
 6262      5200
 6263              	.LASF43:
 6264 091e 5F64736F 		.ascii	"_dso_handle\000"
 6264      5F68616E 
 6264      646C6500 
 6265              	.LASF181:
 6266 092a 70727643 		.ascii	"prvCopyDataToQueue\000"
 6266      6F707944 
 6266      61746154 
 6266      6F517565 
 6266      756500
 6267              	.LASF85:
 6268 093d 5F637674 		.ascii	"_cvtbuf\000"
 6268      62756600 
 6269              	.LASF5:
 6270 0945 756E7369 		.ascii	"unsigned char\000"
 6270      676E6564 
 6270      20636861 
 6270      7200
 6271              	.LASF9:
 6272 0953 5F5F7569 		.ascii	"__uint32_t\000"
 6272      6E743332 
 6272      5F7400
 6273              	.LASF179:
 6274 095e 70727643 		.ascii	"prvCopyDataFromQueue\000"
 6274      6F707944 
 6274      61746146 
 6274      726F6D51 
 6274      75657565 
 6275              	.LASF111:
 6276 0973 5F676574 		.ascii	"_getdate_err\000"
 6276      64617465 
 6276      5F657272 
 6276      00
 6277              	.LASF98:
 6278 0980 5F616464 		.ascii	"_add\000"
 6278      00
 6279              	.LASF194:
 6280 0985 78546963 		.ascii	"xTicksToWait\000"
 6280      6B73546F 
 6280      57616974 
 6280      00
 6281              	.LASF134:
ARM GAS  /tmp/ccdqkONZ.s 			page 165


 6282 0992 70764F77 		.ascii	"pvOwner\000"
 6282      6E657200 
 6283              	.LASF49:
 6284 099a 5F5F7362 		.ascii	"__sbuf\000"
 6284      756600
 6285              	.LASF151:
 6286 09a1 70634865 		.ascii	"pcHead\000"
 6286      616400
 6287              	.LASF92:
 6288 09a8 5F676C75 		.ascii	"_glue\000"
 6288      6500
 6289              	.LASF89:
 6290 09ae 5F5F7367 		.ascii	"__sglue\000"
 6290      6C756500 
 6291              	.LASF100:
 6292 09b6 5F737472 		.ascii	"_strtok_last\000"
 6292      746F6B5F 
 6292      6C617374 
 6292      00
 6293              	.LASF107:
 6294 09c3 5F6D6274 		.ascii	"_mbtowc_state\000"
 6294      6F77635F 
 6294      73746174 
 6294      6500
 6295              	.LASF213:
 6296 09d1 78517565 		.ascii	"xQueueGenericReset\000"
 6296      75654765 
 6296      6E657269 
 6296      63526573 
 6296      657400
 6297              	.LASF42:
 6298 09e4 5F666E61 		.ascii	"_fnargs\000"
 6298      72677300 
 6299              	.LASF175:
 6300 09ec 78517565 		.ascii	"xQueueIsQueueEmptyFromISR\000"
 6300      75654973 
 6300      51756575 
 6300      65456D70 
 6300      74794672 
 6301              	.LASF3:
 6302 0a06 7369676E 		.ascii	"signed char\000"
 6302      65642063 
 6302      68617200 
 6303              	.LASF69:
 6304 0a12 5F726565 		.ascii	"_reent\000"
 6304      6E7400
 6305              	.LASF7:
 6306 0a19 73686F72 		.ascii	"short unsigned int\000"
 6306      7420756E 
 6306      7369676E 
 6306      65642069 
 6306      6E7400
 6307              	.LASF170:
 6308 0a2c 78515545 		.ascii	"xQUEUE\000"
 6308      554500
 6309              	.LASF44:
 6310 0a33 5F666E74 		.ascii	"_fntypes\000"
ARM GAS  /tmp/ccdqkONZ.s 			page 166


 6310      79706573 
 6310      00
 6311              	.LASF51:
 6312 0a3c 5F73697A 		.ascii	"_size\000"
 6312      6500
 6313              	.LASF14:
 6314 0a42 5F6F6666 		.ascii	"_off_t\000"
 6314      5F7400
 6315              	.LASF62:
 6316 0a49 5F6E6275 		.ascii	"_nbuf\000"
 6316      6600
 6317              	.LASF99:
 6318 0a4f 5F756E75 		.ascii	"_unused_rand\000"
 6318      7365645F 
 6318      72616E64 
 6318      00
 6319              	.LASF68:
 6320 0a5c 5F666C61 		.ascii	"_flags2\000"
 6320      67733200 
 6321              	.LASF45:
 6322 0a64 5F69735F 		.ascii	"_is_cxa\000"
 6322      63786100 
 6323              	.LASF96:
 6324 0a6c 5F736565 		.ascii	"_seed\000"
 6324      6400
 6325              	.LASF104:
 6326 0a72 5F72616E 		.ascii	"_rand_next\000"
 6326      645F6E65 
 6326      787400
 6327              	.LASF59:
 6328 0a7d 5F736565 		.ascii	"_seek\000"
 6328      6B00
 6329              	.LASF73:
 6330 0a83 5F737464 		.ascii	"_stderr\000"
 6330      65727200 
 6331              	.LASF119:
 6332 0a8b 5F6E6D61 		.ascii	"_nmalloc\000"
 6332      6C6C6F63 
 6332      00
 6333              	.LASF61:
 6334 0a94 5F756275 		.ascii	"_ubuf\000"
 6334      6600
 6335              	.LASF214:
 6336 0a9a 784E6577 		.ascii	"xNewQueue\000"
 6336      51756575 
 6336      6500
 6337              		.ident	"GCC: (15:6.3.1+svn253039-1build1) 6.3.1 20170620"
ARM GAS  /tmp/ccdqkONZ.s 			page 167


DEFINED SYMBOLS
                            *ABS*:0000000000000000 queue.c
     /tmp/ccdqkONZ.s:15     .text:0000000000000000 $t
     /tmp/ccdqkONZ.s:22     .text:0000000000000000 xQueueGenericReset
     /tmp/ccdqkONZ.s:142    .text:00000000000000b0 $d
     /tmp/ccdqkONZ.s:146    .text:00000000000000b4 $t
     /tmp/ccdqkONZ.s:153    .text:00000000000000b4 xQueueGenericCreate
     /tmp/ccdqkONZ.s:222    .text:0000000000000104 prvInitialiseNewQueue
     /tmp/ccdqkONZ.s:285    .text:0000000000000142 xQueueGenericSend
     /tmp/ccdqkONZ.s:1877   .text:0000000000000952 prvCopyDataToQueue
     /tmp/ccdqkONZ.s:2314   .text:0000000000000b50 prvIsQueueFull
     /tmp/ccdqkONZ.s:2079   .text:0000000000000a56 prvUnlockQueue
     /tmp/ccdqkONZ.s:504    .text:0000000000000294 $d
     /tmp/ccdqkONZ.s:508    .text:0000000000000298 $t
     /tmp/ccdqkONZ.s:515    .text:0000000000000298 xQueueGenericSendFromISR
     /tmp/ccdqkONZ.s:665    .text:0000000000000350 xQueueGiveFromISR
     /tmp/ccdqkONZ.s:807    .text:00000000000003f6 xQueueReceive
     /tmp/ccdqkONZ.s:2011   .text:0000000000000a0a prvCopyDataFromQueue
     /tmp/ccdqkONZ.s:2207   .text:0000000000000afa prvIsQueueEmpty
     /tmp/ccdqkONZ.s:1013   .text:0000000000000538 $d
     /tmp/ccdqkONZ.s:1017   .text:000000000000053c $t
     /tmp/ccdqkONZ.s:1024   .text:000000000000053c xQueueSemaphoreTake
     /tmp/ccdqkONZ.s:1225   .text:0000000000000674 $d
     /tmp/ccdqkONZ.s:1229   .text:0000000000000678 $t
     /tmp/ccdqkONZ.s:1236   .text:0000000000000678 xQueuePeek
     /tmp/ccdqkONZ.s:1445   .text:00000000000007bc $d
     /tmp/ccdqkONZ.s:1449   .text:00000000000007c0 $t
     /tmp/ccdqkONZ.s:1456   .text:00000000000007c0 xQueueReceiveFromISR
     /tmp/ccdqkONZ.s:1601   .text:000000000000086c xQueuePeekFromISR
     /tmp/ccdqkONZ.s:1702   .text:00000000000008d0 uxQueueMessagesWaiting
     /tmp/ccdqkONZ.s:1745   .text:00000000000008f0 uxQueueSpacesAvailable
     /tmp/ccdqkONZ.s:1794   .text:000000000000091a uxQueueMessagesWaitingFromISR
     /tmp/ccdqkONZ.s:1839   .text:0000000000000938 vQueueDelete
     /tmp/ccdqkONZ.s:2260   .text:0000000000000b26 xQueueIsQueueEmptyFromISR
     /tmp/ccdqkONZ.s:2369   .text:0000000000000b80 xQueueIsQueueFullFromISR
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
vPortEnterCritical
xTaskRemoveFromEventList
vListInitialise
vPortExitCritical
pvPortMalloc
vTaskInternalSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortFree
memcpy
vTaskMissedYield
