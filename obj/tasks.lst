ARM GAS  /tmp/cckqXCjj.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"tasks.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.global	pxCurrentTCB
  16              		.bss
  17              		.align	2
  18              		.type	pxCurrentTCB, %object
  19              		.size	pxCurrentTCB, 4
  20              	pxCurrentTCB:
  21 0000 00000000 		.space	4
  22              		.align	2
  23              	pxReadyTasksLists:
  24 0004 00000000 		.space	100
  24      00000000 
  24      00000000 
  24      00000000 
  24      00000000 
  25              		.size	pxReadyTasksLists, 100
  26              		.align	2
  27              	xDelayedTaskList1:
  28 0068 00000000 		.space	20
  28      00000000 
  28      00000000 
  28      00000000 
  28      00000000 
  29              		.size	xDelayedTaskList1, 20
  30              		.align	2
  31              	xDelayedTaskList2:
  32 007c 00000000 		.space	20
  32      00000000 
  32      00000000 
  32      00000000 
  32      00000000 
  33              		.size	xDelayedTaskList2, 20
  34              		.align	2
  35              	pxDelayedTaskList:
  36 0090 00000000 		.space	4
  37              		.size	pxDelayedTaskList, 4
  38              		.align	2
  39              	pxOverflowDelayedTaskList:
  40 0094 00000000 		.space	4
  41              		.size	pxOverflowDelayedTaskList, 4
  42              		.align	2
  43              	xPendingReadyList:
  44 0098 00000000 		.space	20
  44      00000000 
ARM GAS  /tmp/cckqXCjj.s 			page 2


  44      00000000 
  44      00000000 
  44      00000000 
  45              		.size	xPendingReadyList, 20
  46              		.align	2
  47              	xTasksWaitingTermination:
  48 00ac 00000000 		.space	20
  48      00000000 
  48      00000000 
  48      00000000 
  48      00000000 
  49              		.size	xTasksWaitingTermination, 20
  50              		.align	2
  51              	uxDeletedTasksWaitingCleanUp:
  52 00c0 00000000 		.space	4
  53              		.size	uxDeletedTasksWaitingCleanUp, 4
  54              		.align	2
  55              	xSuspendedTaskList:
  56 00c4 00000000 		.space	20
  56      00000000 
  56      00000000 
  56      00000000 
  56      00000000 
  57              		.size	xSuspendedTaskList, 20
  58              		.align	2
  59              	uxCurrentNumberOfTasks:
  60 00d8 00000000 		.space	4
  61              		.size	uxCurrentNumberOfTasks, 4
  62              		.align	2
  63              	xTickCount:
  64 00dc 00000000 		.space	4
  65              		.size	xTickCount, 4
  66              		.align	2
  67              	uxTopReadyPriority:
  68 00e0 00000000 		.space	4
  69              		.size	uxTopReadyPriority, 4
  70              		.align	2
  71              	xSchedulerRunning:
  72 00e4 00000000 		.space	4
  73              		.size	xSchedulerRunning, 4
  74              		.align	2
  75              	xPendedTicks:
  76 00e8 00000000 		.space	4
  77              		.size	xPendedTicks, 4
  78              		.align	2
  79              	xYieldPending:
  80 00ec 00000000 		.space	4
  81              		.size	xYieldPending, 4
  82              		.align	2
  83              	xNumOfOverflows:
  84 00f0 00000000 		.space	4
  85              		.size	xNumOfOverflows, 4
  86              		.align	2
  87              	uxTaskNumber:
  88 00f4 00000000 		.space	4
  89              		.size	uxTaskNumber, 4
  90              		.align	2
ARM GAS  /tmp/cckqXCjj.s 			page 3


  91              	xNextTaskUnblockTime:
  92 00f8 00000000 		.space	4
  93              		.size	xNextTaskUnblockTime, 4
  94              		.align	2
  95              	xIdleTaskHandle:
  96 00fc 00000000 		.space	4
  97              		.size	xIdleTaskHandle, 4
  98              		.align	2
  99              	uxSchedulerSuspended:
 100 0100 00000000 		.space	4
 101              		.size	uxSchedulerSuspended, 4
 102              		.text
 103              		.align	1
 104              		.global	xTaskCreate
 105              		.syntax unified
 106              		.thumb
 107              		.thumb_func
 108              		.fpu softvfp
 109              		.type	xTaskCreate, %function
 110              	xTaskCreate:
 111              	.LFB5:
 112              		.file 1 "FreeRTOS/Source/tasks.c"
   1:FreeRTOS/Source/tasks.c **** /*
   2:FreeRTOS/Source/tasks.c ****  * FreeRTOS Kernel V10.3.1
   3:FreeRTOS/Source/tasks.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Source/tasks.c ****  *
   5:FreeRTOS/Source/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Source/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Source/tasks.c ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Source/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Source/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Source/tasks.c ****  * subject to the following conditions:
  11:FreeRTOS/Source/tasks.c ****  *
  12:FreeRTOS/Source/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  13:FreeRTOS/Source/tasks.c ****  * copies or substantial portions of the Software.
  14:FreeRTOS/Source/tasks.c ****  *
  15:FreeRTOS/Source/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:FreeRTOS/Source/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:FreeRTOS/Source/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:FreeRTOS/Source/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:FreeRTOS/Source/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:FreeRTOS/Source/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:FreeRTOS/Source/tasks.c ****  *
  22:FreeRTOS/Source/tasks.c ****  * http://www.FreeRTOS.org
  23:FreeRTOS/Source/tasks.c ****  * http://aws.amazon.com/freertos
  24:FreeRTOS/Source/tasks.c ****  *
  25:FreeRTOS/Source/tasks.c ****  * 1 tab == 4 spaces!
  26:FreeRTOS/Source/tasks.c ****  */
  27:FreeRTOS/Source/tasks.c **** 
  28:FreeRTOS/Source/tasks.c **** /* Standard includes. */
  29:FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  30:FreeRTOS/Source/tasks.c **** #include <string.h>
  31:FreeRTOS/Source/tasks.c **** 
  32:FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  33:FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  34:FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  35:FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
ARM GAS  /tmp/cckqXCjj.s 			page 4


  36:FreeRTOS/Source/tasks.c **** 
  37:FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  38:FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  39:FreeRTOS/Source/tasks.c **** #include "task.h"
  40:FreeRTOS/Source/tasks.c **** #include "timers.h"
  41:FreeRTOS/Source/tasks.c **** #include "stack_macros.h"
  42:FreeRTOS/Source/tasks.c **** 
  43:FreeRTOS/Source/tasks.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  44:FreeRTOS/Source/tasks.c **** because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  45:FreeRTOS/Source/tasks.c **** for the header files above, but not in this file, in order to generate the
  46:FreeRTOS/Source/tasks.c **** correct privileged Vs unprivileged linkage and placement. */
  47:FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  48:FreeRTOS/Source/tasks.c **** 
  49:FreeRTOS/Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  50:FreeRTOS/Source/tasks.c **** functions but without including stdio.h here. */
  51:FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  52:FreeRTOS/Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  53:FreeRTOS/Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  54:FreeRTOS/Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  55:FreeRTOS/Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  56:FreeRTOS/Source/tasks.c **** 	#include <stdio.h>
  57:FreeRTOS/Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  58:FreeRTOS/Source/tasks.c **** 
  59:FreeRTOS/Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
  60:FreeRTOS/Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
  61:FreeRTOS/Source/tasks.c **** 	performed just because a higher priority task has been woken. */
  62:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
  63:FreeRTOS/Source/tasks.c **** #else
  64:FreeRTOS/Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
  65:FreeRTOS/Source/tasks.c **** #endif
  66:FreeRTOS/Source/tasks.c **** 
  67:FreeRTOS/Source/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  68:FreeRTOS/Source/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
  69:FreeRTOS/Source/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
  70:FreeRTOS/Source/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
  71:FreeRTOS/Source/tasks.c **** 
  72:FreeRTOS/Source/tasks.c **** /*
  73:FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  74:FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
  75:FreeRTOS/Source/tasks.c ****  */
  76:FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
  77:FreeRTOS/Source/tasks.c **** 
  78:FreeRTOS/Source/tasks.c **** /* Bits used to recored how a task's stack and TCB were allocated. */
  79:FreeRTOS/Source/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
  80:FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
  81:FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
  82:FreeRTOS/Source/tasks.c **** 
  83:FreeRTOS/Source/tasks.c **** /* If any of the following are set then task stacks are filled with a known
  84:FreeRTOS/Source/tasks.c **** value so the high water mark can be determined.  If none of the following are
  85:FreeRTOS/Source/tasks.c **** set then don't fill the stack so there is no unnecessary dependency on memset. */
  86:FreeRTOS/Source/tasks.c **** #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTas
  87:FreeRTOS/Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
  88:FreeRTOS/Source/tasks.c **** #else
  89:FreeRTOS/Source/tasks.c **** 	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
  90:FreeRTOS/Source/tasks.c **** #endif
  91:FreeRTOS/Source/tasks.c **** 
  92:FreeRTOS/Source/tasks.c **** /*
ARM GAS  /tmp/cckqXCjj.s 			page 5


  93:FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
  94:FreeRTOS/Source/tasks.c ****  */
  95:FreeRTOS/Source/tasks.c **** #define tskRUNNING_CHAR		( 'X' )
  96:FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
  97:FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
  98:FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
  99:FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 100:FreeRTOS/Source/tasks.c **** 
 101:FreeRTOS/Source/tasks.c **** /*
 102:FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 103:FreeRTOS/Source/tasks.c ****  * global, rather than file scope.
 104:FreeRTOS/Source/tasks.c ****  */
 105:FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 106:FreeRTOS/Source/tasks.c **** 	#define static
 107:FreeRTOS/Source/tasks.c **** #endif
 108:FreeRTOS/Source/tasks.c **** 
 109:FreeRTOS/Source/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 110:FreeRTOS/Source/tasks.c **** configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 111:FreeRTOS/Source/tasks.c **** #ifndef configIDLE_TASK_NAME
 112:FreeRTOS/Source/tasks.c **** 	#define configIDLE_TASK_NAME "IDLE"
 113:FreeRTOS/Source/tasks.c **** #endif
 114:FreeRTOS/Source/tasks.c **** 
 115:FreeRTOS/Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 116:FreeRTOS/Source/tasks.c **** 
 117:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 118:FreeRTOS/Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 119:FreeRTOS/Source/tasks.c **** 	microcontroller architecture. */
 120:FreeRTOS/Source/tasks.c **** 
 121:FreeRTOS/Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 122:FreeRTOS/Source/tasks.c **** 	state task. */
 123:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 124:FreeRTOS/Source/tasks.c **** 	{																									\
 125:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 126:FreeRTOS/Source/tasks.c **** 		{																								\
 127:FreeRTOS/Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
 128:FreeRTOS/Source/tasks.c **** 		}																								\
 129:FreeRTOS/Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 130:FreeRTOS/Source/tasks.c **** 
 131:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 132:FreeRTOS/Source/tasks.c **** 
 133:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 134:FreeRTOS/Source/tasks.c **** 	{																									\
 135:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 136:FreeRTOS/Source/tasks.c **** 																										\
 137:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 138:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 139:FreeRTOS/Source/tasks.c **** 		{																								\
 140:FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopPriority );																\
 141:FreeRTOS/Source/tasks.c **** 			--uxTopPriority;																			\
 142:FreeRTOS/Source/tasks.c **** 		}																								\
 143:FreeRTOS/Source/tasks.c **** 																										\
 144:FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 145:FreeRTOS/Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 146:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 147:FreeRTOS/Source/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 148:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 149:FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/cckqXCjj.s 			page 6


 150:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 151:FreeRTOS/Source/tasks.c **** 
 152:FreeRTOS/Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 153:FreeRTOS/Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 154:FreeRTOS/Source/tasks.c **** 	being used. */
 155:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 156:FreeRTOS/Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 157:FreeRTOS/Source/tasks.c **** 
 158:FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 159:FreeRTOS/Source/tasks.c **** 
 160:FreeRTOS/Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 161:FreeRTOS/Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 162:FreeRTOS/Source/tasks.c **** 	architecture being used. */
 163:FreeRTOS/Source/tasks.c **** 
 164:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 165:FreeRTOS/Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 166:FreeRTOS/Source/tasks.c **** 
 167:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 168:FreeRTOS/Source/tasks.c **** 
 169:FreeRTOS/Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 170:FreeRTOS/Source/tasks.c **** 	{																								\
 171:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 172:FreeRTOS/Source/tasks.c **** 																									\
 173:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 174:FreeRTOS/Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 175:FreeRTOS/Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 176:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 177:FreeRTOS/Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 178:FreeRTOS/Source/tasks.c **** 
 179:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
 180:FreeRTOS/Source/tasks.c **** 
 181:FreeRTOS/Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 182:FreeRTOS/Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 183:FreeRTOS/Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 184:FreeRTOS/Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
 185:FreeRTOS/Source/tasks.c **** 	{																									\
 186:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 187:FreeRTOS/Source/tasks.c **** 		{																								\
 188:FreeRTOS/Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 189:FreeRTOS/Source/tasks.c **** 		}																								\
 190:FreeRTOS/Source/tasks.c **** 	}
 191:FreeRTOS/Source/tasks.c **** 
 192:FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 193:FreeRTOS/Source/tasks.c **** 
 194:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 195:FreeRTOS/Source/tasks.c **** 
 196:FreeRTOS/Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 197:FreeRTOS/Source/tasks.c **** count overflows. */
 198:FreeRTOS/Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 199:FreeRTOS/Source/tasks.c **** {																									\
 200:FreeRTOS/Source/tasks.c **** 	List_t *pxTemp;																					\
 201:FreeRTOS/Source/tasks.c **** 																									\
 202:FreeRTOS/Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 203:FreeRTOS/Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 204:FreeRTOS/Source/tasks.c **** 																									\
 205:FreeRTOS/Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 206:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
ARM GAS  /tmp/cckqXCjj.s 			page 7


 207:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 208:FreeRTOS/Source/tasks.c **** 	xNumOfOverflows++;																				\
 209:FreeRTOS/Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 210:FreeRTOS/Source/tasks.c **** }
 211:FreeRTOS/Source/tasks.c **** 
 212:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 213:FreeRTOS/Source/tasks.c **** 
 214:FreeRTOS/Source/tasks.c **** /*
 215:FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 216:FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 217:FreeRTOS/Source/tasks.c ****  */
 218:FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 219:FreeRTOS/Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 220:FreeRTOS/Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 221:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 222:FreeRTOS/Source/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 223:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 224:FreeRTOS/Source/tasks.c **** 
 225:FreeRTOS/Source/tasks.c **** /*
 226:FreeRTOS/Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 227:FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 228:FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 229:FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 230:FreeRTOS/Source/tasks.c ****  */
 231:FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
 232:FreeRTOS/Source/tasks.c **** 
 233:FreeRTOS/Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 234:FreeRTOS/Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 235:FreeRTOS/Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 236:FreeRTOS/Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 237:FreeRTOS/Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 238:FreeRTOS/Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 239:FreeRTOS/Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 240:FreeRTOS/Source/tasks.c **** to its original value when it is released. */
 241:FreeRTOS/Source/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
 242:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 243:FreeRTOS/Source/tasks.c **** #else
 244:FreeRTOS/Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 245:FreeRTOS/Source/tasks.c **** #endif
 246:FreeRTOS/Source/tasks.c **** 
 247:FreeRTOS/Source/tasks.c **** /*
 248:FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 249:FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 250:FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
 251:FreeRTOS/Source/tasks.c ****  */
 252:FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock 			/* The old naming convention is used to prevent breaking kern
 253:FreeRTOS/Source/tasks.c **** {
 254:FreeRTOS/Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 255:FreeRTOS/Source/tasks.c **** 
 256:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 257:FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 258:FreeRTOS/Source/tasks.c **** 	#endif
 259:FreeRTOS/Source/tasks.c **** 
 260:FreeRTOS/Source/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 261:FreeRTOS/Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 262:FreeRTOS/Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 263:FreeRTOS/Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
ARM GAS  /tmp/cckqXCjj.s 			page 8


 264:FreeRTOS/Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 265:FreeRTOS/Source/tasks.c **** 
 266:FreeRTOS/Source/tasks.c **** 	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 267:FreeRTOS/Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
 268:FreeRTOS/Source/tasks.c **** 	#endif
 269:FreeRTOS/Source/tasks.c **** 
 270:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 271:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 272:FreeRTOS/Source/tasks.c **** 	#endif
 273:FreeRTOS/Source/tasks.c **** 
 274:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 275:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 276:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 277:FreeRTOS/Source/tasks.c **** 	#endif
 278:FreeRTOS/Source/tasks.c **** 
 279:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 280:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 281:FreeRTOS/Source/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 282:FreeRTOS/Source/tasks.c **** 	#endif
 283:FreeRTOS/Source/tasks.c **** 
 284:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 285:FreeRTOS/Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 286:FreeRTOS/Source/tasks.c **** 	#endif
 287:FreeRTOS/Source/tasks.c **** 
 288:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 289:FreeRTOS/Source/tasks.c **** 		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 290:FreeRTOS/Source/tasks.c **** 	#endif
 291:FreeRTOS/Source/tasks.c **** 
 292:FreeRTOS/Source/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 293:FreeRTOS/Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 294:FreeRTOS/Source/tasks.c **** 	#endif
 295:FreeRTOS/Source/tasks.c **** 
 296:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 297:FreeRTOS/Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 298:FreeRTOS/Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
 299:FreeRTOS/Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 300:FreeRTOS/Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 301:FreeRTOS/Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 302:FreeRTOS/Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 303:FreeRTOS/Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks.
 304:FreeRTOS/Source/tasks.c **** 
 305:FreeRTOS/Source/tasks.c **** 		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
 306:FreeRTOS/Source/tasks.c **** 		for additional information. */
 307:FreeRTOS/Source/tasks.c **** 		struct	_reent xNewLib_reent;
 308:FreeRTOS/Source/tasks.c **** 	#endif
 309:FreeRTOS/Source/tasks.c **** 
 310:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 311:FreeRTOS/Source/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 312:FreeRTOS/Source/tasks.c **** 		volatile uint8_t ucNotifyState;
 313:FreeRTOS/Source/tasks.c **** 	#endif
 314:FreeRTOS/Source/tasks.c **** 
 315:FreeRTOS/Source/tasks.c **** 	/* See the comments in FreeRTOS.h with the definition of
 316:FreeRTOS/Source/tasks.c **** 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 317:FreeRTOS/Source/tasks.c **** 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolida
 318:FreeRTOS/Source/tasks.c **** 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensur
 319:FreeRTOS/Source/tasks.c **** 	#endif
 320:FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/cckqXCjj.s 			page 9


 321:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 322:FreeRTOS/Source/tasks.c **** 		uint8_t ucDelayAborted;
 323:FreeRTOS/Source/tasks.c **** 	#endif
 324:FreeRTOS/Source/tasks.c **** 
 325:FreeRTOS/Source/tasks.c **** 	#if( configUSE_POSIX_ERRNO == 1 )
 326:FreeRTOS/Source/tasks.c **** 		int iTaskErrno;
 327:FreeRTOS/Source/tasks.c **** 	#endif
 328:FreeRTOS/Source/tasks.c **** 
 329:FreeRTOS/Source/tasks.c **** } tskTCB;
 330:FreeRTOS/Source/tasks.c **** 
 331:FreeRTOS/Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 332:FreeRTOS/Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 333:FreeRTOS/Source/tasks.c **** typedef tskTCB TCB_t;
 334:FreeRTOS/Source/tasks.c **** 
 335:FreeRTOS/Source/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 336:FreeRTOS/Source/tasks.c **** which static variables must be declared volatile. */
 337:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 338:FreeRTOS/Source/tasks.c **** 
 339:FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------
 340:FreeRTOS/Source/tasks.c **** xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
 341:FreeRTOS/Source/tasks.c **** doing so breaks some kernel aware debuggers and debuggers that rely on removing
 342:FreeRTOS/Source/tasks.c **** the static qualifier. */
 343:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 344:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 345:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 346:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 347:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 348:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 349:FreeRTOS/Source/tasks.c **** 
 350:FreeRTOS/Source/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 351:FreeRTOS/Source/tasks.c **** 
 352:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 353:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 354:FreeRTOS/Source/tasks.c **** 
 355:FreeRTOS/Source/tasks.c **** #endif
 356:FreeRTOS/Source/tasks.c **** 
 357:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 358:FreeRTOS/Source/tasks.c **** 
 359:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 360:FreeRTOS/Source/tasks.c **** 
 361:FreeRTOS/Source/tasks.c **** #endif
 362:FreeRTOS/Source/tasks.c **** 
 363:FreeRTOS/Source/tasks.c **** /* Global POSIX errno. Its value is changed upon context switching to match
 364:FreeRTOS/Source/tasks.c **** the errno of the currently running task. */
 365:FreeRTOS/Source/tasks.c **** #if ( configUSE_POSIX_ERRNO == 1 )
 366:FreeRTOS/Source/tasks.c **** 	int FreeRTOS_errno = 0;
 367:FreeRTOS/Source/tasks.c **** #endif
 368:FreeRTOS/Source/tasks.c **** 
 369:FreeRTOS/Source/tasks.c **** /* Other file private variables. --------------------------------*/
 370:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
 371:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT
 372:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 373:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 374:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xPendedTicks 			= ( TickType_t ) 0U;
 375:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 376:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 377:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
ARM GAS  /tmp/cckqXCjj.s 			page 10


 378:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 379:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 380:FreeRTOS/Source/tasks.c **** 
 381:FreeRTOS/Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 382:FreeRTOS/Source/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 383:FreeRTOS/Source/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 384:FreeRTOS/Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 385:FreeRTOS/Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 386:FreeRTOS/Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 387:FreeRTOS/Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 388:FreeRTOS/Source/tasks.c **** accessed from a critical section. */
 389:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 390:FreeRTOS/Source/tasks.c **** 
 391:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 392:FreeRTOS/Source/tasks.c **** 
 393:FreeRTOS/Source/tasks.c **** 	/* Do not move these variables to function scope as doing so prevents the
 394:FreeRTOS/Source/tasks.c **** 	code working with debuggers that need to remove the static qualifier. */
 395:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 396:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 397:FreeRTOS/Source/tasks.c **** 
 398:FreeRTOS/Source/tasks.c **** #endif
 399:FreeRTOS/Source/tasks.c **** 
 400:FreeRTOS/Source/tasks.c **** /*lint -restore */
 401:FreeRTOS/Source/tasks.c **** 
 402:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 403:FreeRTOS/Source/tasks.c **** 
 404:FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 405:FreeRTOS/Source/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 406:FreeRTOS/Source/tasks.c **** 
 407:FreeRTOS/Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 408:FreeRTOS/Source/tasks.c **** 
 409:FreeRTOS/Source/tasks.c **** #endif
 410:FreeRTOS/Source/tasks.c **** 
 411:FreeRTOS/Source/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 412:FreeRTOS/Source/tasks.c **** 
 413:FreeRTOS/Source/tasks.c **** 	extern void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application 
 414:FreeRTOS/Source/tasks.c **** 
 415:FreeRTOS/Source/tasks.c **** #endif
 416:FreeRTOS/Source/tasks.c **** 
 417:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 418:FreeRTOS/Source/tasks.c **** 
 419:FreeRTOS/Source/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 420:FreeRTOS/Source/tasks.c **** 
 421:FreeRTOS/Source/tasks.c **** #endif
 422:FreeRTOS/Source/tasks.c **** 
 423:FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 424:FreeRTOS/Source/tasks.c **** 
 425:FreeRTOS/Source/tasks.c **** /**
 426:FreeRTOS/Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 427:FreeRTOS/Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 428:FreeRTOS/Source/tasks.c ****  * is in any other state.
 429:FreeRTOS/Source/tasks.c ****  */
 430:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 431:FreeRTOS/Source/tasks.c **** 
 432:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 433:FreeRTOS/Source/tasks.c **** 
 434:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
ARM GAS  /tmp/cckqXCjj.s 			page 11


 435:FreeRTOS/Source/tasks.c **** 
 436:FreeRTOS/Source/tasks.c **** /*
 437:FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 438:FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 439:FreeRTOS/Source/tasks.c ****  */
 440:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 441:FreeRTOS/Source/tasks.c **** 
 442:FreeRTOS/Source/tasks.c **** /*
 443:FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 444:FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 445:FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 446:FreeRTOS/Source/tasks.c ****  *
 447:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 448:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 449:FreeRTOS/Source/tasks.c ****  *
 450:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 451:FreeRTOS/Source/tasks.c ****  *
 452:FreeRTOS/Source/tasks.c ****  */
 453:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 454:FreeRTOS/Source/tasks.c **** 
 455:FreeRTOS/Source/tasks.c **** /*
 456:FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 457:FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 458:FreeRTOS/Source/tasks.c ****  *
 459:FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 460:FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 461:FreeRTOS/Source/tasks.c ****  */
 462:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 463:FreeRTOS/Source/tasks.c **** 
 464:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 465:FreeRTOS/Source/tasks.c **** 
 466:FreeRTOS/Source/tasks.c **** #endif
 467:FreeRTOS/Source/tasks.c **** 
 468:FreeRTOS/Source/tasks.c **** /*
 469:FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 470:FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 471:FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 472:FreeRTOS/Source/tasks.c ****  */
 473:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 474:FreeRTOS/Source/tasks.c **** 
 475:FreeRTOS/Source/tasks.c **** /*
 476:FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 477:FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 478:FreeRTOS/Source/tasks.c ****  */
 479:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 480:FreeRTOS/Source/tasks.c **** 
 481:FreeRTOS/Source/tasks.c **** /*
 482:FreeRTOS/Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 483:FreeRTOS/Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 484:FreeRTOS/Source/tasks.c ****  * a suspended list, etc.).
 485:FreeRTOS/Source/tasks.c ****  *
 486:FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 487:FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 488:FreeRTOS/Source/tasks.c ****  */
 489:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 490:FreeRTOS/Source/tasks.c **** 
 491:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
ARM GAS  /tmp/cckqXCjj.s 			page 12


 492:FreeRTOS/Source/tasks.c **** 
 493:FreeRTOS/Source/tasks.c **** #endif
 494:FreeRTOS/Source/tasks.c **** 
 495:FreeRTOS/Source/tasks.c **** /*
 496:FreeRTOS/Source/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 497:FreeRTOS/Source/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 498:FreeRTOS/Source/tasks.c ****  */
 499:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 500:FreeRTOS/Source/tasks.c **** 
 501:FreeRTOS/Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 502:FreeRTOS/Source/tasks.c **** 
 503:FreeRTOS/Source/tasks.c **** #endif
 504:FreeRTOS/Source/tasks.c **** 
 505:FreeRTOS/Source/tasks.c **** /*
 506:FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 507:FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 508:FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 509:FreeRTOS/Source/tasks.c ****  */
 510:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
 511:FreeRTOS/Source/tasks.c **** 
 512:FreeRTOS/Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGE
 513:FreeRTOS/Source/tasks.c **** 
 514:FreeRTOS/Source/tasks.c **** #endif
 515:FreeRTOS/Source/tasks.c **** 
 516:FreeRTOS/Source/tasks.c **** /*
 517:FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 518:FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 519:FreeRTOS/Source/tasks.c ****  *
 520:FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 521:FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 522:FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 523:FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 524:FreeRTOS/Source/tasks.c ****  */
 525:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 526:FreeRTOS/Source/tasks.c **** 
 527:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 528:FreeRTOS/Source/tasks.c **** 
 529:FreeRTOS/Source/tasks.c **** #endif
 530:FreeRTOS/Source/tasks.c **** 
 531:FreeRTOS/Source/tasks.c **** /*
 532:FreeRTOS/Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 533:FreeRTOS/Source/tasks.c ****  * will exit the Blocked state.
 534:FreeRTOS/Source/tasks.c ****  */
 535:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 536:FreeRTOS/Source/tasks.c **** 
 537:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 538:FreeRTOS/Source/tasks.c **** 
 539:FreeRTOS/Source/tasks.c **** 	/*
 540:FreeRTOS/Source/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 541:FreeRTOS/Source/tasks.c **** 	 * human readable tables of task information.
 542:FreeRTOS/Source/tasks.c **** 	 */
 543:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 544:FreeRTOS/Source/tasks.c **** 
 545:FreeRTOS/Source/tasks.c **** #endif
 546:FreeRTOS/Source/tasks.c **** 
 547:FreeRTOS/Source/tasks.c **** /*
 548:FreeRTOS/Source/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
ARM GAS  /tmp/cckqXCjj.s 			page 13


 549:FreeRTOS/Source/tasks.c ****  * dynamically to fill in the structure's members.
 550:FreeRTOS/Source/tasks.c ****  */
 551:FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 552:FreeRTOS/Source/tasks.c **** 									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings a
 553:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 554:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 555:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 556:FreeRTOS/Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 557:FreeRTOS/Source/tasks.c **** 									TCB_t *pxNewTCB,
 558:FreeRTOS/Source/tasks.c **** 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 559:FreeRTOS/Source/tasks.c **** 
 560:FreeRTOS/Source/tasks.c **** /*
 561:FreeRTOS/Source/tasks.c ****  * Called after a new task has been created and initialised to place the task
 562:FreeRTOS/Source/tasks.c ****  * under the control of the scheduler.
 563:FreeRTOS/Source/tasks.c ****  */
 564:FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 565:FreeRTOS/Source/tasks.c **** 
 566:FreeRTOS/Source/tasks.c **** /*
 567:FreeRTOS/Source/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 568:FreeRTOS/Source/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 569:FreeRTOS/Source/tasks.c ****  * called by the function.
 570:FreeRTOS/Source/tasks.c ****  */
 571:FreeRTOS/Source/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 572:FreeRTOS/Source/tasks.c **** 
 573:FreeRTOS/Source/tasks.c **** 	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 574:FreeRTOS/Source/tasks.c **** 
 575:FreeRTOS/Source/tasks.c **** #endif
 576:FreeRTOS/Source/tasks.c **** 
 577:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 578:FreeRTOS/Source/tasks.c **** 
 579:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 580:FreeRTOS/Source/tasks.c **** 
 581:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
 582:FreeRTOS/Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 583:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 584:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 585:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 586:FreeRTOS/Source/tasks.c **** 									StackType_t * const puxStackBuffer,
 587:FreeRTOS/Source/tasks.c **** 									StaticTask_t * const pxTaskBuffer )
 588:FreeRTOS/Source/tasks.c **** 	{
 589:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 590:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
 591:FreeRTOS/Source/tasks.c **** 
 592:FreeRTOS/Source/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 593:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 594:FreeRTOS/Source/tasks.c **** 
 595:FreeRTOS/Source/tasks.c **** 		#if( configASSERT_DEFINED == 1 )
 596:FreeRTOS/Source/tasks.c **** 		{
 597:FreeRTOS/Source/tasks.c **** 			/* Sanity check that the size of the structure used to declare a
 598:FreeRTOS/Source/tasks.c **** 			variable of type StaticTask_t equals the size of the real task
 599:FreeRTOS/Source/tasks.c **** 			structure. */
 600:FreeRTOS/Source/tasks.c **** 			volatile size_t xSize = sizeof( StaticTask_t );
 601:FreeRTOS/Source/tasks.c **** 			configASSERT( xSize == sizeof( TCB_t ) );
 602:FreeRTOS/Source/tasks.c **** 			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 603:FreeRTOS/Source/tasks.c **** 		}
 604:FreeRTOS/Source/tasks.c **** 		#endif /* configASSERT_DEFINED */
 605:FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/cckqXCjj.s 			page 14


 606:FreeRTOS/Source/tasks.c **** 
 607:FreeRTOS/Source/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 608:FreeRTOS/Source/tasks.c **** 		{
 609:FreeRTOS/Source/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 610:FreeRTOS/Source/tasks.c **** 			function - use them. */
 611:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures ar
 612:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 613:FreeRTOS/Source/tasks.c **** 
 614:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consoli
 615:FreeRTOS/Source/tasks.c **** 			{
 616:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 617:FreeRTOS/Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 618:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 619:FreeRTOS/Source/tasks.c **** 			}
 620:FreeRTOS/Source/tasks.c **** 			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 621:FreeRTOS/Source/tasks.c **** 
 622:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 623:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 624:FreeRTOS/Source/tasks.c **** 		}
 625:FreeRTOS/Source/tasks.c **** 		else
 626:FreeRTOS/Source/tasks.c **** 		{
 627:FreeRTOS/Source/tasks.c **** 			xReturn = NULL;
 628:FreeRTOS/Source/tasks.c **** 		}
 629:FreeRTOS/Source/tasks.c **** 
 630:FreeRTOS/Source/tasks.c **** 		return xReturn;
 631:FreeRTOS/Source/tasks.c **** 	}
 632:FreeRTOS/Source/tasks.c **** 
 633:FreeRTOS/Source/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 634:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 635:FreeRTOS/Source/tasks.c **** 
 636:FreeRTOS/Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 637:FreeRTOS/Source/tasks.c **** 
 638:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandl
 639:FreeRTOS/Source/tasks.c **** 	{
 640:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 641:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 642:FreeRTOS/Source/tasks.c **** 
 643:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 644:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 645:FreeRTOS/Source/tasks.c **** 
 646:FreeRTOS/Source/tasks.c **** 		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
 647:FreeRTOS/Source/tasks.c **** 		{
 648:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 649:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 650:FreeRTOS/Source/tasks.c **** 			not static allocation is being used. */
 651:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 652:FreeRTOS/Source/tasks.c **** 
 653:FreeRTOS/Source/tasks.c **** 			/* Store the stack location in the TCB. */
 654:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 655:FreeRTOS/Source/tasks.c **** 
 656:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 657:FreeRTOS/Source/tasks.c **** 			{
 658:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 659:FreeRTOS/Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 660:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 661:FreeRTOS/Source/tasks.c **** 			}
 662:FreeRTOS/Source/tasks.c **** 			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
ARM GAS  /tmp/cckqXCjj.s 			page 15


 663:FreeRTOS/Source/tasks.c **** 
 664:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 665:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->pcName,
 666:FreeRTOS/Source/tasks.c **** 									( uint32_t ) pxTaskDefinition->usStackDepth,
 667:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->pvParameters,
 668:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->uxPriority,
 669:FreeRTOS/Source/tasks.c **** 									pxCreatedTask, pxNewTCB,
 670:FreeRTOS/Source/tasks.c **** 									pxTaskDefinition->xRegions );
 671:FreeRTOS/Source/tasks.c **** 
 672:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 673:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 674:FreeRTOS/Source/tasks.c **** 		}
 675:FreeRTOS/Source/tasks.c **** 
 676:FreeRTOS/Source/tasks.c **** 		return xReturn;
 677:FreeRTOS/Source/tasks.c **** 	}
 678:FreeRTOS/Source/tasks.c **** 
 679:FreeRTOS/Source/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 680:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 681:FreeRTOS/Source/tasks.c **** 
 682:FreeRTOS/Source/tasks.c **** #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 683:FreeRTOS/Source/tasks.c **** 
 684:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *p
 685:FreeRTOS/Source/tasks.c **** 	{
 686:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 687:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 688:FreeRTOS/Source/tasks.c **** 
 689:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer );
 690:FreeRTOS/Source/tasks.c **** 
 691:FreeRTOS/Source/tasks.c **** 		if( pxTaskDefinition->puxStackBuffer != NULL )
 692:FreeRTOS/Source/tasks.c **** 		{
 693:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 694:FreeRTOS/Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 695:FreeRTOS/Source/tasks.c **** 			not static allocation is being used. */
 696:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 697:FreeRTOS/Source/tasks.c **** 
 698:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
 699:FreeRTOS/Source/tasks.c **** 			{
 700:FreeRTOS/Source/tasks.c **** 				/* Store the stack location in the TCB. */
 701:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 702:FreeRTOS/Source/tasks.c **** 
 703:FreeRTOS/Source/tasks.c **** 				#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 704:FreeRTOS/Source/tasks.c **** 				{
 705:FreeRTOS/Source/tasks.c **** 					/* Tasks can be created statically or dynamically, so note
 706:FreeRTOS/Source/tasks.c **** 					this task had a statically allocated stack in case it is
 707:FreeRTOS/Source/tasks.c **** 					later deleted.  The TCB was allocated dynamically. */
 708:FreeRTOS/Source/tasks.c **** 					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 709:FreeRTOS/Source/tasks.c **** 				}
 710:FreeRTOS/Source/tasks.c **** 				#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 711:FreeRTOS/Source/tasks.c **** 
 712:FreeRTOS/Source/tasks.c **** 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 713:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->pcName,
 714:FreeRTOS/Source/tasks.c **** 										( uint32_t ) pxTaskDefinition->usStackDepth,
 715:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->pvParameters,
 716:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->uxPriority,
 717:FreeRTOS/Source/tasks.c **** 										pxCreatedTask, pxNewTCB,
 718:FreeRTOS/Source/tasks.c **** 										pxTaskDefinition->xRegions );
 719:FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/cckqXCjj.s 			page 16


 720:FreeRTOS/Source/tasks.c **** 				prvAddNewTaskToReadyList( pxNewTCB );
 721:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
 722:FreeRTOS/Source/tasks.c **** 			}
 723:FreeRTOS/Source/tasks.c **** 		}
 724:FreeRTOS/Source/tasks.c **** 
 725:FreeRTOS/Source/tasks.c **** 		return xReturn;
 726:FreeRTOS/Source/tasks.c **** 	}
 727:FreeRTOS/Source/tasks.c **** 
 728:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 729:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 730:FreeRTOS/Source/tasks.c **** 
 731:FreeRTOS/Source/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 732:FreeRTOS/Source/tasks.c **** 
 733:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 734:FreeRTOS/Source/tasks.c **** 							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and 
 735:FreeRTOS/Source/tasks.c **** 							const configSTACK_DEPTH_TYPE usStackDepth,
 736:FreeRTOS/Source/tasks.c **** 							void * const pvParameters,
 737:FreeRTOS/Source/tasks.c **** 							UBaseType_t uxPriority,
 738:FreeRTOS/Source/tasks.c **** 							TaskHandle_t * const pxCreatedTask )
 739:FreeRTOS/Source/tasks.c **** 	{
 113              		.loc 1 739 0
 114              		.cfi_startproc
 115              		@ args = 8, pretend = 0, frame = 32
 116              		@ frame_needed = 1, uses_anonymous_args = 0
 117 0000 80B5     		push	{r7, lr}
 118              		.cfi_def_cfa_offset 8
 119              		.cfi_offset 7, -8
 120              		.cfi_offset 14, -4
 121 0002 8CB0     		sub	sp, sp, #48
 122              		.cfi_def_cfa_offset 56
 123 0004 04AF     		add	r7, sp, #16
 124              		.cfi_def_cfa 7, 40
 125 0006 F860     		str	r0, [r7, #12]
 126 0008 B960     		str	r1, [r7, #8]
 127 000a 3B60     		str	r3, [r7]
 128 000c 1346     		mov	r3, r2	@ movhi
 129 000e FB80     		strh	r3, [r7, #6]	@ movhi
 130              	.LBB26:
 740:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNewTCB;
 741:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
 742:FreeRTOS/Source/tasks.c **** 
 743:FreeRTOS/Source/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 744:FreeRTOS/Source/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 745:FreeRTOS/Source/tasks.c **** 		the TCB then the stack. */
 746:FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 747:FreeRTOS/Source/tasks.c **** 		{
 748:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 749:FreeRTOS/Source/tasks.c **** 			the implementation of the port malloc function and whether or not static
 750:FreeRTOS/Source/tasks.c **** 			allocation is being used. */
 751:FreeRTOS/Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 752:FreeRTOS/Source/tasks.c **** 
 753:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB != NULL )
 754:FreeRTOS/Source/tasks.c **** 			{
 755:FreeRTOS/Source/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 756:FreeRTOS/Source/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 757:FreeRTOS/Source/tasks.c **** 				be deleted later if required. */
 758:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
ARM GAS  /tmp/cckqXCjj.s 			page 17


 759:FreeRTOS/Source/tasks.c **** 
 760:FreeRTOS/Source/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 761:FreeRTOS/Source/tasks.c **** 				{
 762:FreeRTOS/Source/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 763:FreeRTOS/Source/tasks.c **** 					vPortFree( pxNewTCB );
 764:FreeRTOS/Source/tasks.c **** 					pxNewTCB = NULL;
 765:FreeRTOS/Source/tasks.c **** 				}
 766:FreeRTOS/Source/tasks.c **** 			}
 767:FreeRTOS/Source/tasks.c **** 		}
 768:FreeRTOS/Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 769:FreeRTOS/Source/tasks.c **** 		{
 770:FreeRTOS/Source/tasks.c **** 		StackType_t *pxStack;
 771:FreeRTOS/Source/tasks.c **** 
 772:FreeRTOS/Source/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 773:FreeRTOS/Source/tasks.c **** 			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079
 131              		.loc 1 773 0
 132 0010 FB88     		ldrh	r3, [r7, #6]
 133 0012 9B00     		lsls	r3, r3, #2
 134 0014 1846     		mov	r0, r3
 135 0016 FFF7FEFF 		bl	pvPortMalloc
 136 001a 7861     		str	r0, [r7, #20]
 774:FreeRTOS/Source/tasks.c **** 
 775:FreeRTOS/Source/tasks.c **** 			if( pxStack != NULL )
 137              		.loc 1 775 0
 138 001c 7B69     		ldr	r3, [r7, #20]
 139 001e 002B     		cmp	r3, #0
 140 0020 0ED0     		beq	.L2
 776:FreeRTOS/Source/tasks.c **** 			{
 777:FreeRTOS/Source/tasks.c **** 				/* Allocate space for the TCB. */
 778:FreeRTOS/Source/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returne
 141              		.loc 1 778 0
 142 0022 4C20     		movs	r0, #76
 143 0024 FFF7FEFF 		bl	pvPortMalloc
 144 0028 F861     		str	r0, [r7, #28]
 779:FreeRTOS/Source/tasks.c **** 
 780:FreeRTOS/Source/tasks.c **** 				if( pxNewTCB != NULL )
 145              		.loc 1 780 0
 146 002a FB69     		ldr	r3, [r7, #28]
 147 002c 002B     		cmp	r3, #0
 148 002e 03D0     		beq	.L3
 781:FreeRTOS/Source/tasks.c **** 				{
 782:FreeRTOS/Source/tasks.c **** 					/* Store the stack location in the TCB. */
 783:FreeRTOS/Source/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 149              		.loc 1 783 0
 150 0030 FB69     		ldr	r3, [r7, #28]
 151 0032 7A69     		ldr	r2, [r7, #20]
 152 0034 1A63     		str	r2, [r3, #48]
 153 0036 05E0     		b	.L5
 154              	.L3:
 784:FreeRTOS/Source/tasks.c **** 				}
 785:FreeRTOS/Source/tasks.c **** 				else
 786:FreeRTOS/Source/tasks.c **** 				{
 787:FreeRTOS/Source/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 788:FreeRTOS/Source/tasks.c **** 					it again. */
 789:FreeRTOS/Source/tasks.c **** 					vPortFree( pxStack );
 155              		.loc 1 789 0
 156 0038 7869     		ldr	r0, [r7, #20]
ARM GAS  /tmp/cckqXCjj.s 			page 18


 157 003a FFF7FEFF 		bl	vPortFree
 158 003e 01E0     		b	.L5
 159              	.L2:
 790:FreeRTOS/Source/tasks.c **** 				}
 791:FreeRTOS/Source/tasks.c **** 			}
 792:FreeRTOS/Source/tasks.c **** 			else
 793:FreeRTOS/Source/tasks.c **** 			{
 794:FreeRTOS/Source/tasks.c **** 				pxNewTCB = NULL;
 160              		.loc 1 794 0
 161 0040 0023     		movs	r3, #0
 162 0042 FB61     		str	r3, [r7, #28]
 163              	.L5:
 164              	.LBE26:
 795:FreeRTOS/Source/tasks.c **** 			}
 796:FreeRTOS/Source/tasks.c **** 		}
 797:FreeRTOS/Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 798:FreeRTOS/Source/tasks.c **** 
 799:FreeRTOS/Source/tasks.c **** 		if( pxNewTCB != NULL )
 165              		.loc 1 799 0
 166 0044 FB69     		ldr	r3, [r7, #28]
 167 0046 002B     		cmp	r3, #0
 168 0048 13D0     		beq	.L6
 800:FreeRTOS/Source/tasks.c **** 		{
 801:FreeRTOS/Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consoli
 802:FreeRTOS/Source/tasks.c **** 			{
 803:FreeRTOS/Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 804:FreeRTOS/Source/tasks.c **** 				task was created dynamically in case it is later deleted. */
 805:FreeRTOS/Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 806:FreeRTOS/Source/tasks.c **** 			}
 807:FreeRTOS/Source/tasks.c **** 			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 808:FreeRTOS/Source/tasks.c **** 
 809:FreeRTOS/Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 169              		.loc 1 809 0
 170 004a FA88     		ldrh	r2, [r7, #6]
 171 004c 0023     		movs	r3, #0
 172 004e 0393     		str	r3, [sp, #12]
 173 0050 FB69     		ldr	r3, [r7, #28]
 174 0052 0293     		str	r3, [sp, #8]
 175 0054 FB6A     		ldr	r3, [r7, #44]
 176 0056 0193     		str	r3, [sp, #4]
 177 0058 BB6A     		ldr	r3, [r7, #40]
 178 005a 0093     		str	r3, [sp]
 179 005c 3B68     		ldr	r3, [r7]
 180 005e B968     		ldr	r1, [r7, #8]
 181 0060 F868     		ldr	r0, [r7, #12]
 182 0062 00F00EF8 		bl	prvInitialiseNewTask
 810:FreeRTOS/Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 183              		.loc 1 810 0
 184 0066 F869     		ldr	r0, [r7, #28]
 185 0068 00F07CF8 		bl	prvAddNewTaskToReadyList
 811:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 186              		.loc 1 811 0
 187 006c 0123     		movs	r3, #1
 188 006e BB61     		str	r3, [r7, #24]
 189 0070 02E0     		b	.L7
 190              	.L6:
 812:FreeRTOS/Source/tasks.c **** 		}
ARM GAS  /tmp/cckqXCjj.s 			page 19


 813:FreeRTOS/Source/tasks.c **** 		else
 814:FreeRTOS/Source/tasks.c **** 		{
 815:FreeRTOS/Source/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 191              		.loc 1 815 0
 192 0072 4FF0FF33 		mov	r3, #-1
 193 0076 BB61     		str	r3, [r7, #24]
 194              	.L7:
 816:FreeRTOS/Source/tasks.c **** 		}
 817:FreeRTOS/Source/tasks.c **** 
 818:FreeRTOS/Source/tasks.c **** 		return xReturn;
 195              		.loc 1 818 0
 196 0078 BB69     		ldr	r3, [r7, #24]
 819:FreeRTOS/Source/tasks.c **** 	}
 197              		.loc 1 819 0
 198 007a 1846     		mov	r0, r3
 199 007c 2037     		adds	r7, r7, #32
 200              		.cfi_def_cfa_offset 8
 201 007e BD46     		mov	sp, r7
 202              		.cfi_def_cfa_register 13
 203              		@ sp needed
 204 0080 80BD     		pop	{r7, pc}
 205              		.cfi_endproc
 206              	.LFE5:
 207              		.size	xTaskCreate, .-xTaskCreate
 208              		.align	1
 209              		.syntax unified
 210              		.thumb
 211              		.thumb_func
 212              		.fpu softvfp
 213              		.type	prvInitialiseNewTask, %function
 214              	prvInitialiseNewTask:
 215              	.LFB6:
 820:FreeRTOS/Source/tasks.c **** 
 821:FreeRTOS/Source/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 822:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 823:FreeRTOS/Source/tasks.c **** 
 824:FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 825:FreeRTOS/Source/tasks.c **** 									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings an
 826:FreeRTOS/Source/tasks.c **** 									const uint32_t ulStackDepth,
 827:FreeRTOS/Source/tasks.c **** 									void * const pvParameters,
 828:FreeRTOS/Source/tasks.c **** 									UBaseType_t uxPriority,
 829:FreeRTOS/Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 830:FreeRTOS/Source/tasks.c **** 									TCB_t *pxNewTCB,
 831:FreeRTOS/Source/tasks.c **** 									const MemoryRegion_t * const xRegions )
 832:FreeRTOS/Source/tasks.c **** {
 216              		.loc 1 832 0
 217              		.cfi_startproc
 218              		@ args = 16, pretend = 0, frame = 24
 219              		@ frame_needed = 1, uses_anonymous_args = 0
 220 0082 80B5     		push	{r7, lr}
 221              		.cfi_def_cfa_offset 8
 222              		.cfi_offset 7, -8
 223              		.cfi_offset 14, -4
 224 0084 86B0     		sub	sp, sp, #24
 225              		.cfi_def_cfa_offset 32
 226 0086 00AF     		add	r7, sp, #0
 227              		.cfi_def_cfa_register 7
ARM GAS  /tmp/cckqXCjj.s 			page 20


 228 0088 F860     		str	r0, [r7, #12]
 229 008a B960     		str	r1, [r7, #8]
 230 008c 7A60     		str	r2, [r7, #4]
 231 008e 3B60     		str	r3, [r7]
 833:FreeRTOS/Source/tasks.c **** StackType_t *pxTopOfStack;
 834:FreeRTOS/Source/tasks.c **** UBaseType_t x;
 835:FreeRTOS/Source/tasks.c **** 
 836:FreeRTOS/Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 837:FreeRTOS/Source/tasks.c **** 		/* Should the task be created in privileged mode? */
 838:FreeRTOS/Source/tasks.c **** 		BaseType_t xRunPrivileged;
 839:FreeRTOS/Source/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 840:FreeRTOS/Source/tasks.c **** 		{
 841:FreeRTOS/Source/tasks.c **** 			xRunPrivileged = pdTRUE;
 842:FreeRTOS/Source/tasks.c **** 		}
 843:FreeRTOS/Source/tasks.c **** 		else
 844:FreeRTOS/Source/tasks.c **** 		{
 845:FreeRTOS/Source/tasks.c **** 			xRunPrivileged = pdFALSE;
 846:FreeRTOS/Source/tasks.c **** 		}
 847:FreeRTOS/Source/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 848:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
 849:FreeRTOS/Source/tasks.c **** 
 850:FreeRTOS/Source/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 851:FreeRTOS/Source/tasks.c **** 	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 852:FreeRTOS/Source/tasks.c **** 	{
 853:FreeRTOS/Source/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 854:FreeRTOS/Source/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 855:FreeRTOS/Source/tasks.c **** 	}
 856:FreeRTOS/Source/tasks.c **** 	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 857:FreeRTOS/Source/tasks.c **** 
 858:FreeRTOS/Source/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 859:FreeRTOS/Source/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 860:FreeRTOS/Source/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 861:FreeRTOS/Source/tasks.c **** 	by the port. */
 862:FreeRTOS/Source/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 863:FreeRTOS/Source/tasks.c **** 	{
 864:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 232              		.loc 1 864 0
 233 0090 BB6A     		ldr	r3, [r7, #40]
 234 0092 1A6B     		ldr	r2, [r3, #48]
 235 0094 7B68     		ldr	r3, [r7, #4]
 236 0096 03F18043 		add	r3, r3, #1073741824
 237 009a 013B     		subs	r3, r3, #1
 238 009c 9B00     		lsls	r3, r3, #2
 239 009e 1344     		add	r3, r3, r2
 240 00a0 3B61     		str	r3, [r7, #16]
 865:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 241              		.loc 1 865 0
 242 00a2 3B69     		ldr	r3, [r7, #16]
 243 00a4 23F00703 		bic	r3, r3, #7
 244 00a8 3B61     		str	r3, [r7, #16]
 866:FreeRTOS/Source/tasks.c **** 
 867:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 868:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 869:FreeRTOS/Source/tasks.c **** 
 870:FreeRTOS/Source/tasks.c **** 		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
 871:FreeRTOS/Source/tasks.c **** 		{
 872:FreeRTOS/Source/tasks.c **** 			/* Also record the stack's high address, which may assist
ARM GAS  /tmp/cckqXCjj.s 			page 21


 873:FreeRTOS/Source/tasks.c **** 			debugging. */
 874:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxTopOfStack;
 875:FreeRTOS/Source/tasks.c **** 		}
 876:FreeRTOS/Source/tasks.c **** 		#endif /* configRECORD_STACK_HIGH_ADDRESS */
 877:FreeRTOS/Source/tasks.c **** 	}
 878:FreeRTOS/Source/tasks.c **** 	#else /* portSTACK_GROWTH */
 879:FreeRTOS/Source/tasks.c **** 	{
 880:FreeRTOS/Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 881:FreeRTOS/Source/tasks.c **** 
 882:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 883:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 884:FreeRTOS/Source/tasks.c **** 
 885:FreeRTOS/Source/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 886:FreeRTOS/Source/tasks.c **** 		performed. */
 887:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 888:FreeRTOS/Source/tasks.c **** 	}
 889:FreeRTOS/Source/tasks.c **** 	#endif /* portSTACK_GROWTH */
 890:FreeRTOS/Source/tasks.c **** 
 891:FreeRTOS/Source/tasks.c **** 	/* Store the task name in the TCB. */
 892:FreeRTOS/Source/tasks.c **** 	if( pcName != NULL )
 245              		.loc 1 892 0
 246 00aa BB68     		ldr	r3, [r7, #8]
 247 00ac 002B     		cmp	r3, #0
 248 00ae 1FD0     		beq	.L10
 893:FreeRTOS/Source/tasks.c **** 	{
 894:FreeRTOS/Source/tasks.c **** 		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 249              		.loc 1 894 0
 250 00b0 0023     		movs	r3, #0
 251 00b2 7B61     		str	r3, [r7, #20]
 252 00b4 12E0     		b	.L11
 253              	.L14:
 895:FreeRTOS/Source/tasks.c **** 		{
 896:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 254              		.loc 1 896 0
 255 00b6 BA68     		ldr	r2, [r7, #8]
 256 00b8 7B69     		ldr	r3, [r7, #20]
 257 00ba 1344     		add	r3, r3, r2
 258 00bc 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 259 00be BA6A     		ldr	r2, [r7, #40]
 260 00c0 7B69     		ldr	r3, [r7, #20]
 261 00c2 1344     		add	r3, r3, r2
 262 00c4 3433     		adds	r3, r3, #52
 263 00c6 0A46     		mov	r2, r1
 264 00c8 1A70     		strb	r2, [r3]
 897:FreeRTOS/Source/tasks.c **** 
 898:FreeRTOS/Source/tasks.c **** 			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 899:FreeRTOS/Source/tasks.c **** 			configMAX_TASK_NAME_LEN characters just in case the memory after the
 900:FreeRTOS/Source/tasks.c **** 			string is not accessible (extremely unlikely). */
 901:FreeRTOS/Source/tasks.c **** 			if( pcName[ x ] == ( char ) 0x00 )
 265              		.loc 1 901 0
 266 00ca BA68     		ldr	r2, [r7, #8]
 267 00cc 7B69     		ldr	r3, [r7, #20]
 268 00ce 1344     		add	r3, r3, r2
 269 00d0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 270 00d2 002B     		cmp	r3, #0
 271 00d4 06D0     		beq	.L18
 894:FreeRTOS/Source/tasks.c **** 		{
ARM GAS  /tmp/cckqXCjj.s 			page 22


 272              		.loc 1 894 0 discriminator 2
 273 00d6 7B69     		ldr	r3, [r7, #20]
 274 00d8 0133     		adds	r3, r3, #1
 275 00da 7B61     		str	r3, [r7, #20]
 276              	.L11:
 894:FreeRTOS/Source/tasks.c **** 		{
 277              		.loc 1 894 0 is_stmt 0 discriminator 1
 278 00dc 7B69     		ldr	r3, [r7, #20]
 279 00de 0F2B     		cmp	r3, #15
 280 00e0 E9D9     		bls	.L14
 281 00e2 00E0     		b	.L13
 282              	.L18:
 902:FreeRTOS/Source/tasks.c **** 			{
 903:FreeRTOS/Source/tasks.c **** 				break;
 283              		.loc 1 903 0 is_stmt 1
 284 00e4 00BF     		nop
 285              	.L13:
 904:FreeRTOS/Source/tasks.c **** 			}
 905:FreeRTOS/Source/tasks.c **** 			else
 906:FreeRTOS/Source/tasks.c **** 			{
 907:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 908:FreeRTOS/Source/tasks.c **** 			}
 909:FreeRTOS/Source/tasks.c **** 		}
 910:FreeRTOS/Source/tasks.c **** 
 911:FreeRTOS/Source/tasks.c **** 		/* Ensure the name string is terminated in the case that the string length
 912:FreeRTOS/Source/tasks.c **** 		was greater or equal to configMAX_TASK_NAME_LEN. */
 913:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 286              		.loc 1 913 0
 287 00e6 BB6A     		ldr	r3, [r7, #40]
 288 00e8 0022     		movs	r2, #0
 289 00ea 83F84320 		strb	r2, [r3, #67]
 290 00ee 03E0     		b	.L15
 291              	.L10:
 914:FreeRTOS/Source/tasks.c **** 	}
 915:FreeRTOS/Source/tasks.c **** 	else
 916:FreeRTOS/Source/tasks.c **** 	{
 917:FreeRTOS/Source/tasks.c **** 		/* The task has not been given a name, so just ensure there is a NULL
 918:FreeRTOS/Source/tasks.c **** 		terminator when it is read out. */
 919:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 292              		.loc 1 919 0
 293 00f0 BB6A     		ldr	r3, [r7, #40]
 294 00f2 0022     		movs	r2, #0
 295 00f4 83F83420 		strb	r2, [r3, #52]
 296              	.L15:
 920:FreeRTOS/Source/tasks.c **** 	}
 921:FreeRTOS/Source/tasks.c **** 
 922:FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 923:FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
 924:FreeRTOS/Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 297              		.loc 1 924 0
 298 00f8 3B6A     		ldr	r3, [r7, #32]
 299 00fa 042B     		cmp	r3, #4
 300 00fc 01D9     		bls	.L16
 925:FreeRTOS/Source/tasks.c **** 	{
 926:FreeRTOS/Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 301              		.loc 1 926 0
 302 00fe 0423     		movs	r3, #4
ARM GAS  /tmp/cckqXCjj.s 			page 23


 303 0100 3B62     		str	r3, [r7, #32]
 304              	.L16:
 927:FreeRTOS/Source/tasks.c **** 	}
 928:FreeRTOS/Source/tasks.c **** 	else
 929:FreeRTOS/Source/tasks.c **** 	{
 930:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 931:FreeRTOS/Source/tasks.c **** 	}
 932:FreeRTOS/Source/tasks.c **** 
 933:FreeRTOS/Source/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 305              		.loc 1 933 0
 306 0102 BB6A     		ldr	r3, [r7, #40]
 307 0104 3A6A     		ldr	r2, [r7, #32]
 308 0106 DA62     		str	r2, [r3, #44]
 934:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 935:FreeRTOS/Source/tasks.c **** 	{
 936:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 937:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 938:FreeRTOS/Source/tasks.c **** 	}
 939:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
 940:FreeRTOS/Source/tasks.c **** 
 941:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 309              		.loc 1 941 0
 310 0108 BB6A     		ldr	r3, [r7, #40]
 311 010a 0433     		adds	r3, r3, #4
 312 010c 1846     		mov	r0, r3
 313 010e FFF7FEFF 		bl	vListInitialiseItem
 942:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 314              		.loc 1 942 0
 315 0112 BB6A     		ldr	r3, [r7, #40]
 316 0114 1833     		adds	r3, r3, #24
 317 0116 1846     		mov	r0, r3
 318 0118 FFF7FEFF 		bl	vListInitialiseItem
 943:FreeRTOS/Source/tasks.c **** 
 944:FreeRTOS/Source/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 945:FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 946:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 319              		.loc 1 946 0
 320 011c BB6A     		ldr	r3, [r7, #40]
 321 011e BA6A     		ldr	r2, [r7, #40]
 322 0120 1A61     		str	r2, [r3, #16]
 947:FreeRTOS/Source/tasks.c **** 
 948:FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
 949:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 323              		.loc 1 949 0
 324 0122 3B6A     		ldr	r3, [r7, #32]
 325 0124 C3F10502 		rsb	r2, r3, #5
 326 0128 BB6A     		ldr	r3, [r7, #40]
 327 012a 9A61     		str	r2, [r3, #24]
 950:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 328              		.loc 1 950 0
 329 012c BB6A     		ldr	r3, [r7, #40]
 330 012e BA6A     		ldr	r2, [r7, #40]
 331 0130 5A62     		str	r2, [r3, #36]
 951:FreeRTOS/Source/tasks.c **** 
 952:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 953:FreeRTOS/Source/tasks.c **** 	{
 954:FreeRTOS/Source/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
ARM GAS  /tmp/cckqXCjj.s 			page 24


 955:FreeRTOS/Source/tasks.c **** 	}
 956:FreeRTOS/Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 957:FreeRTOS/Source/tasks.c **** 
 958:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 959:FreeRTOS/Source/tasks.c **** 	{
 960:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 961:FreeRTOS/Source/tasks.c **** 	}
 962:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 963:FreeRTOS/Source/tasks.c **** 
 964:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 965:FreeRTOS/Source/tasks.c **** 	{
 966:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 967:FreeRTOS/Source/tasks.c **** 	}
 968:FreeRTOS/Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 969:FreeRTOS/Source/tasks.c **** 
 970:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 971:FreeRTOS/Source/tasks.c **** 	{
 972:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 973:FreeRTOS/Source/tasks.c **** 	}
 974:FreeRTOS/Source/tasks.c **** 	#else
 975:FreeRTOS/Source/tasks.c **** 	{
 976:FreeRTOS/Source/tasks.c **** 		/* Avoid compiler warning about unreferenced parameter. */
 977:FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
 978:FreeRTOS/Source/tasks.c **** 	}
 979:FreeRTOS/Source/tasks.c **** 	#endif
 980:FreeRTOS/Source/tasks.c **** 
 981:FreeRTOS/Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 982:FreeRTOS/Source/tasks.c **** 	{
 983:FreeRTOS/Source/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 984:FreeRTOS/Source/tasks.c **** 		{
 985:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 986:FreeRTOS/Source/tasks.c **** 		}
 987:FreeRTOS/Source/tasks.c **** 	}
 988:FreeRTOS/Source/tasks.c **** 	#endif
 989:FreeRTOS/Source/tasks.c **** 
 990:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 991:FreeRTOS/Source/tasks.c **** 	{
 992:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
 332              		.loc 1 992 0
 333 0132 BB6A     		ldr	r3, [r7, #40]
 334 0134 0022     		movs	r2, #0
 335 0136 5A64     		str	r2, [r3, #68]
 993:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 336              		.loc 1 993 0
 337 0138 BB6A     		ldr	r3, [r7, #40]
 338 013a 0022     		movs	r2, #0
 339 013c 83F84820 		strb	r2, [r3, #72]
 994:FreeRTOS/Source/tasks.c **** 	}
 995:FreeRTOS/Source/tasks.c **** 	#endif
 996:FreeRTOS/Source/tasks.c **** 
 997:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 998:FreeRTOS/Source/tasks.c **** 	{
 999:FreeRTOS/Source/tasks.c **** 		/* Initialise this task's Newlib reent structure.
1000:FreeRTOS/Source/tasks.c **** 		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
1001:FreeRTOS/Source/tasks.c **** 		for additional information. */
1002:FreeRTOS/Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
1003:FreeRTOS/Source/tasks.c **** 	}
ARM GAS  /tmp/cckqXCjj.s 			page 25


1004:FreeRTOS/Source/tasks.c **** 	#endif
1005:FreeRTOS/Source/tasks.c **** 
1006:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
1007:FreeRTOS/Source/tasks.c **** 	{
1008:FreeRTOS/Source/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
1009:FreeRTOS/Source/tasks.c **** 	}
1010:FreeRTOS/Source/tasks.c **** 	#endif
1011:FreeRTOS/Source/tasks.c **** 
1012:FreeRTOS/Source/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
1013:FreeRTOS/Source/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
1014:FreeRTOS/Source/tasks.c **** 	to the start of the task function. Once the stack has been initialised
1015:FreeRTOS/Source/tasks.c **** 	the top of stack variable is updated. */
1016:FreeRTOS/Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
1017:FreeRTOS/Source/tasks.c **** 	{
1018:FreeRTOS/Source/tasks.c **** 		/* If the port has capability to detect stack overflow,
1019:FreeRTOS/Source/tasks.c **** 		pass the stack end address to the stack initialization
1020:FreeRTOS/Source/tasks.c **** 		function as well. */
1021:FreeRTOS/Source/tasks.c **** 		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
1022:FreeRTOS/Source/tasks.c **** 		{
1023:FreeRTOS/Source/tasks.c **** 			#if( portSTACK_GROWTH < 0 )
1024:FreeRTOS/Source/tasks.c **** 			{
1025:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pv
1026:FreeRTOS/Source/tasks.c **** 			}
1027:FreeRTOS/Source/tasks.c **** 			#else /* portSTACK_GROWTH */
1028:FreeRTOS/Source/tasks.c **** 			{
1029:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCod
1030:FreeRTOS/Source/tasks.c **** 			}
1031:FreeRTOS/Source/tasks.c **** 			#endif /* portSTACK_GROWTH */
1032:FreeRTOS/Source/tasks.c **** 		}
1033:FreeRTOS/Source/tasks.c **** 		#else /* portHAS_STACK_OVERFLOW_CHECKING */
1034:FreeRTOS/Source/tasks.c **** 		{
1035:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
1036:FreeRTOS/Source/tasks.c **** 		}
1037:FreeRTOS/Source/tasks.c **** 		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
1038:FreeRTOS/Source/tasks.c **** 	}
1039:FreeRTOS/Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
1040:FreeRTOS/Source/tasks.c **** 	{
1041:FreeRTOS/Source/tasks.c **** 		/* If the port has capability to detect stack overflow,
1042:FreeRTOS/Source/tasks.c **** 		pass the stack end address to the stack initialization
1043:FreeRTOS/Source/tasks.c **** 		function as well. */
1044:FreeRTOS/Source/tasks.c **** 		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
1045:FreeRTOS/Source/tasks.c **** 		{
1046:FreeRTOS/Source/tasks.c **** 			#if( portSTACK_GROWTH < 0 )
1047:FreeRTOS/Source/tasks.c **** 			{
1048:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pv
1049:FreeRTOS/Source/tasks.c **** 			}
1050:FreeRTOS/Source/tasks.c **** 			#else /* portSTACK_GROWTH */
1051:FreeRTOS/Source/tasks.c **** 			{
1052:FreeRTOS/Source/tasks.c **** 				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCod
1053:FreeRTOS/Source/tasks.c **** 			}
1054:FreeRTOS/Source/tasks.c **** 			#endif /* portSTACK_GROWTH */
1055:FreeRTOS/Source/tasks.c **** 		}
1056:FreeRTOS/Source/tasks.c **** 		#else /* portHAS_STACK_OVERFLOW_CHECKING */
1057:FreeRTOS/Source/tasks.c **** 		{
1058:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 340              		.loc 1 1058 0
 341 0140 3A68     		ldr	r2, [r7]
ARM GAS  /tmp/cckqXCjj.s 			page 26


 342 0142 F968     		ldr	r1, [r7, #12]
 343 0144 3869     		ldr	r0, [r7, #16]
 344 0146 FFF7FEFF 		bl	pxPortInitialiseStack
 345 014a 0246     		mov	r2, r0
 346 014c BB6A     		ldr	r3, [r7, #40]
 347 014e 1A60     		str	r2, [r3]
1059:FreeRTOS/Source/tasks.c **** 		}
1060:FreeRTOS/Source/tasks.c **** 		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
1061:FreeRTOS/Source/tasks.c **** 	}
1062:FreeRTOS/Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
1063:FreeRTOS/Source/tasks.c **** 
1064:FreeRTOS/Source/tasks.c **** 	if( pxCreatedTask != NULL )
 348              		.loc 1 1064 0
 349 0150 7B6A     		ldr	r3, [r7, #36]
 350 0152 002B     		cmp	r3, #0
 351 0154 02D0     		beq	.L19
1065:FreeRTOS/Source/tasks.c **** 	{
1066:FreeRTOS/Source/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
1067:FreeRTOS/Source/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
1068:FreeRTOS/Source/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 352              		.loc 1 1068 0
 353 0156 7B6A     		ldr	r3, [r7, #36]
 354 0158 BA6A     		ldr	r2, [r7, #40]
 355 015a 1A60     		str	r2, [r3]
 356              	.L19:
1069:FreeRTOS/Source/tasks.c **** 	}
1070:FreeRTOS/Source/tasks.c **** 	else
1071:FreeRTOS/Source/tasks.c **** 	{
1072:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1073:FreeRTOS/Source/tasks.c **** 	}
1074:FreeRTOS/Source/tasks.c **** }
 357              		.loc 1 1074 0
 358 015c 00BF     		nop
 359 015e 1837     		adds	r7, r7, #24
 360              		.cfi_def_cfa_offset 8
 361 0160 BD46     		mov	sp, r7
 362              		.cfi_def_cfa_register 13
 363              		@ sp needed
 364 0162 80BD     		pop	{r7, pc}
 365              		.cfi_endproc
 366              	.LFE6:
 367              		.size	prvInitialiseNewTask, .-prvInitialiseNewTask
 368              		.align	1
 369              		.syntax unified
 370              		.thumb
 371              		.thumb_func
 372              		.fpu softvfp
 373              		.type	prvAddNewTaskToReadyList, %function
 374              	prvAddNewTaskToReadyList:
 375              	.LFB7:
1075:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1076:FreeRTOS/Source/tasks.c **** 
1077:FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
1078:FreeRTOS/Source/tasks.c **** {
 376              		.loc 1 1078 0
 377              		.cfi_startproc
 378              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/cckqXCjj.s 			page 27


 379              		@ frame_needed = 1, uses_anonymous_args = 0
 380 0164 80B5     		push	{r7, lr}
 381              		.cfi_def_cfa_offset 8
 382              		.cfi_offset 7, -8
 383              		.cfi_offset 14, -4
 384 0166 82B0     		sub	sp, sp, #8
 385              		.cfi_def_cfa_offset 16
 386 0168 00AF     		add	r7, sp, #0
 387              		.cfi_def_cfa_register 7
 388 016a 7860     		str	r0, [r7, #4]
1079:FreeRTOS/Source/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
1080:FreeRTOS/Source/tasks.c **** 	updated. */
1081:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 389              		.loc 1 1081 0
 390 016c FFF7FEFF 		bl	vPortEnterCritical
1082:FreeRTOS/Source/tasks.c **** 	{
1083:FreeRTOS/Source/tasks.c **** 		uxCurrentNumberOfTasks++;
 391              		.loc 1 1083 0
 392 0170 2A4B     		ldr	r3, .L25
 393 0172 1B68     		ldr	r3, [r3]
 394 0174 0133     		adds	r3, r3, #1
 395 0176 294A     		ldr	r2, .L25
 396 0178 1360     		str	r3, [r2]
1084:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB == NULL )
 397              		.loc 1 1084 0
 398 017a 294B     		ldr	r3, .L25+4
 399 017c 1B68     		ldr	r3, [r3]
 400 017e 002B     		cmp	r3, #0
 401 0180 09D1     		bne	.L21
1085:FreeRTOS/Source/tasks.c **** 		{
1086:FreeRTOS/Source/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
1087:FreeRTOS/Source/tasks.c **** 			the suspended state - make this the current task. */
1088:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB = pxNewTCB;
 402              		.loc 1 1088 0
 403 0182 274A     		ldr	r2, .L25+4
 404 0184 7B68     		ldr	r3, [r7, #4]
 405 0186 1360     		str	r3, [r2]
1089:FreeRTOS/Source/tasks.c **** 
1090:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 406              		.loc 1 1090 0
 407 0188 244B     		ldr	r3, .L25
 408 018a 1B68     		ldr	r3, [r3]
 409 018c 012B     		cmp	r3, #1
 410 018e 10D1     		bne	.L22
1091:FreeRTOS/Source/tasks.c **** 			{
1092:FreeRTOS/Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
1093:FreeRTOS/Source/tasks.c **** 				initialisation required.  We will not recover if this call
1094:FreeRTOS/Source/tasks.c **** 				fails, but we will report the failure. */
1095:FreeRTOS/Source/tasks.c **** 				prvInitialiseTaskLists();
 411              		.loc 1 1095 0
 412 0190 00F0FEFE 		bl	prvInitialiseTaskLists
 413 0194 0DE0     		b	.L22
 414              	.L21:
1096:FreeRTOS/Source/tasks.c **** 			}
1097:FreeRTOS/Source/tasks.c **** 			else
1098:FreeRTOS/Source/tasks.c **** 			{
1099:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
ARM GAS  /tmp/cckqXCjj.s 			page 28


1100:FreeRTOS/Source/tasks.c **** 			}
1101:FreeRTOS/Source/tasks.c **** 		}
1102:FreeRTOS/Source/tasks.c **** 		else
1103:FreeRTOS/Source/tasks.c **** 		{
1104:FreeRTOS/Source/tasks.c **** 			/* If the scheduler is not already running, make this task the
1105:FreeRTOS/Source/tasks.c **** 			current task if it is the highest priority task to be created
1106:FreeRTOS/Source/tasks.c **** 			so far. */
1107:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
 415              		.loc 1 1107 0
 416 0196 234B     		ldr	r3, .L25+8
 417 0198 1B68     		ldr	r3, [r3]
 418 019a 002B     		cmp	r3, #0
 419 019c 09D1     		bne	.L22
1108:FreeRTOS/Source/tasks.c **** 			{
1109:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 420              		.loc 1 1109 0
 421 019e 204B     		ldr	r3, .L25+4
 422 01a0 1B68     		ldr	r3, [r3]
 423 01a2 DA6A     		ldr	r2, [r3, #44]
 424 01a4 7B68     		ldr	r3, [r7, #4]
 425 01a6 DB6A     		ldr	r3, [r3, #44]
 426 01a8 9A42     		cmp	r2, r3
 427 01aa 02D8     		bhi	.L22
1110:FreeRTOS/Source/tasks.c **** 				{
1111:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = pxNewTCB;
 428              		.loc 1 1111 0
 429 01ac 1C4A     		ldr	r2, .L25+4
 430 01ae 7B68     		ldr	r3, [r7, #4]
 431 01b0 1360     		str	r3, [r2]
 432              	.L22:
1112:FreeRTOS/Source/tasks.c **** 				}
1113:FreeRTOS/Source/tasks.c **** 				else
1114:FreeRTOS/Source/tasks.c **** 				{
1115:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1116:FreeRTOS/Source/tasks.c **** 				}
1117:FreeRTOS/Source/tasks.c **** 			}
1118:FreeRTOS/Source/tasks.c **** 			else
1119:FreeRTOS/Source/tasks.c **** 			{
1120:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1121:FreeRTOS/Source/tasks.c **** 			}
1122:FreeRTOS/Source/tasks.c **** 		}
1123:FreeRTOS/Source/tasks.c **** 
1124:FreeRTOS/Source/tasks.c **** 		uxTaskNumber++;
 433              		.loc 1 1124 0
 434 01b2 1D4B     		ldr	r3, .L25+12
 435 01b4 1B68     		ldr	r3, [r3]
 436 01b6 0133     		adds	r3, r3, #1
 437 01b8 1B4A     		ldr	r2, .L25+12
 438 01ba 1360     		str	r3, [r2]
1125:FreeRTOS/Source/tasks.c **** 
1126:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
1127:FreeRTOS/Source/tasks.c **** 		{
1128:FreeRTOS/Source/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
1129:FreeRTOS/Source/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
1130:FreeRTOS/Source/tasks.c **** 		}
1131:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
1132:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
ARM GAS  /tmp/cckqXCjj.s 			page 29


1133:FreeRTOS/Source/tasks.c **** 
1134:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
 439              		.loc 1 1134 0
 440 01bc 7B68     		ldr	r3, [r7, #4]
 441 01be DB6A     		ldr	r3, [r3, #44]
 442 01c0 0122     		movs	r2, #1
 443 01c2 9A40     		lsls	r2, r2, r3
 444 01c4 194B     		ldr	r3, .L25+16
 445 01c6 1B68     		ldr	r3, [r3]
 446 01c8 1343     		orrs	r3, r3, r2
 447 01ca 184A     		ldr	r2, .L25+16
 448 01cc 1360     		str	r3, [r2]
 449 01ce 7B68     		ldr	r3, [r7, #4]
 450 01d0 DA6A     		ldr	r2, [r3, #44]
 451 01d2 1346     		mov	r3, r2
 452 01d4 9B00     		lsls	r3, r3, #2
 453 01d6 1344     		add	r3, r3, r2
 454 01d8 9B00     		lsls	r3, r3, #2
 455 01da 154A     		ldr	r2, .L25+20
 456 01dc 1A44     		add	r2, r2, r3
 457 01de 7B68     		ldr	r3, [r7, #4]
 458 01e0 0433     		adds	r3, r3, #4
 459 01e2 1946     		mov	r1, r3
 460 01e4 1046     		mov	r0, r2
 461 01e6 FFF7FEFF 		bl	vListInsertEnd
1135:FreeRTOS/Source/tasks.c **** 
1136:FreeRTOS/Source/tasks.c **** 		portSETUP_TCB( pxNewTCB );
1137:FreeRTOS/Source/tasks.c **** 	}
1138:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 462              		.loc 1 1138 0
 463 01ea FFF7FEFF 		bl	vPortExitCritical
1139:FreeRTOS/Source/tasks.c **** 
1140:FreeRTOS/Source/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
 464              		.loc 1 1140 0
 465 01ee 0D4B     		ldr	r3, .L25+8
 466 01f0 1B68     		ldr	r3, [r3]
 467 01f2 002B     		cmp	r3, #0
 468 01f4 0ED0     		beq	.L24
1141:FreeRTOS/Source/tasks.c **** 	{
1142:FreeRTOS/Source/tasks.c **** 		/* If the created task is of a higher priority than the current task
1143:FreeRTOS/Source/tasks.c **** 		then it should run now. */
1144:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 469              		.loc 1 1144 0
 470 01f6 0A4B     		ldr	r3, .L25+4
 471 01f8 1B68     		ldr	r3, [r3]
 472 01fa DA6A     		ldr	r2, [r3, #44]
 473 01fc 7B68     		ldr	r3, [r7, #4]
 474 01fe DB6A     		ldr	r3, [r3, #44]
 475 0200 9A42     		cmp	r2, r3
 476 0202 07D2     		bcs	.L24
1145:FreeRTOS/Source/tasks.c **** 		{
1146:FreeRTOS/Source/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
 477              		.loc 1 1146 0
 478 0204 0B4B     		ldr	r3, .L25+24
 479 0206 4FF08052 		mov	r2, #268435456
 480 020a 1A60     		str	r2, [r3]
 481              		.syntax unified
ARM GAS  /tmp/cckqXCjj.s 			page 30


 482              	@ 1146 "FreeRTOS/Source/tasks.c" 1
 483 020c BFF34F8F 		dsb
 484              	@ 0 "" 2
 485              	@ 1146 "FreeRTOS/Source/tasks.c" 1
 486 0210 BFF36F8F 		isb
 487              	@ 0 "" 2
 488              		.thumb
 489              		.syntax unified
 490              	.L24:
1147:FreeRTOS/Source/tasks.c **** 		}
1148:FreeRTOS/Source/tasks.c **** 		else
1149:FreeRTOS/Source/tasks.c **** 		{
1150:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1151:FreeRTOS/Source/tasks.c **** 		}
1152:FreeRTOS/Source/tasks.c **** 	}
1153:FreeRTOS/Source/tasks.c **** 	else
1154:FreeRTOS/Source/tasks.c **** 	{
1155:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
1156:FreeRTOS/Source/tasks.c **** 	}
1157:FreeRTOS/Source/tasks.c **** }
 491              		.loc 1 1157 0
 492 0214 00BF     		nop
 493 0216 0837     		adds	r7, r7, #8
 494              		.cfi_def_cfa_offset 8
 495 0218 BD46     		mov	sp, r7
 496              		.cfi_def_cfa_register 13
 497              		@ sp needed
 498 021a 80BD     		pop	{r7, pc}
 499              	.L26:
 500              		.align	2
 501              	.L25:
 502 021c D8000000 		.word	uxCurrentNumberOfTasks
 503 0220 00000000 		.word	pxCurrentTCB
 504 0224 E4000000 		.word	xSchedulerRunning
 505 0228 F4000000 		.word	uxTaskNumber
 506 022c E0000000 		.word	uxTopReadyPriority
 507 0230 04000000 		.word	pxReadyTasksLists
 508 0234 04ED00E0 		.word	-536810236
 509              		.cfi_endproc
 510              	.LFE7:
 511              		.size	prvAddNewTaskToReadyList, .-prvAddNewTaskToReadyList
 512              		.align	1
 513              		.global	vTaskDelete
 514              		.syntax unified
 515              		.thumb
 516              		.thumb_func
 517              		.fpu softvfp
 518              		.type	vTaskDelete, %function
 519              	vTaskDelete:
 520              	.LFB8:
1158:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1159:FreeRTOS/Source/tasks.c **** 
1160:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1161:FreeRTOS/Source/tasks.c **** 
1162:FreeRTOS/Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
1163:FreeRTOS/Source/tasks.c **** 	{
 521              		.loc 1 1163 0
ARM GAS  /tmp/cckqXCjj.s 			page 31


 522              		.cfi_startproc
 523              		@ args = 0, pretend = 0, frame = 16
 524              		@ frame_needed = 1, uses_anonymous_args = 0
 525 0238 80B5     		push	{r7, lr}
 526              		.cfi_def_cfa_offset 8
 527              		.cfi_offset 7, -8
 528              		.cfi_offset 14, -4
 529 023a 84B0     		sub	sp, sp, #16
 530              		.cfi_def_cfa_offset 24
 531 023c 00AF     		add	r7, sp, #0
 532              		.cfi_def_cfa_register 7
 533 023e 7860     		str	r0, [r7, #4]
1164:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1165:FreeRTOS/Source/tasks.c **** 
1166:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 534              		.loc 1 1166 0
 535 0240 FFF7FEFF 		bl	vPortEnterCritical
1167:FreeRTOS/Source/tasks.c **** 		{
1168:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
1169:FreeRTOS/Source/tasks.c **** 			being deleted. */
1170:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 536              		.loc 1 1170 0
 537 0244 7B68     		ldr	r3, [r7, #4]
 538 0246 002B     		cmp	r3, #0
 539 0248 02D1     		bne	.L28
 540              		.loc 1 1170 0 is_stmt 0 discriminator 1
 541 024a 314B     		ldr	r3, .L37
 542 024c 1B68     		ldr	r3, [r3]
 543 024e 00E0     		b	.L29
 544              	.L28:
 545              		.loc 1 1170 0 discriminator 2
 546 0250 7B68     		ldr	r3, [r7, #4]
 547              	.L29:
 548              		.loc 1 1170 0 discriminator 4
 549 0252 FB60     		str	r3, [r7, #12]
1171:FreeRTOS/Source/tasks.c **** 
1172:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list. */
1173:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 550              		.loc 1 1173 0 is_stmt 1 discriminator 4
 551 0254 FB68     		ldr	r3, [r7, #12]
 552 0256 0433     		adds	r3, r3, #4
 553 0258 1846     		mov	r0, r3
 554 025a FFF7FEFF 		bl	uxListRemove
 555 025e 0346     		mov	r3, r0
 556 0260 002B     		cmp	r3, #0
 557 0262 15D1     		bne	.L30
1174:FreeRTOS/Source/tasks.c **** 			{
1175:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 558              		.loc 1 1175 0
 559 0264 FB68     		ldr	r3, [r7, #12]
 560 0266 DA6A     		ldr	r2, [r3, #44]
 561 0268 2A49     		ldr	r1, .L37+4
 562 026a 1346     		mov	r3, r2
 563 026c 9B00     		lsls	r3, r3, #2
 564 026e 1344     		add	r3, r3, r2
 565 0270 9B00     		lsls	r3, r3, #2
 566 0272 0B44     		add	r3, r3, r1
ARM GAS  /tmp/cckqXCjj.s 			page 32


 567 0274 1B68     		ldr	r3, [r3]
 568 0276 002B     		cmp	r3, #0
 569 0278 0AD1     		bne	.L30
 570              		.loc 1 1175 0 is_stmt 0 discriminator 1
 571 027a FB68     		ldr	r3, [r7, #12]
 572 027c DB6A     		ldr	r3, [r3, #44]
 573 027e 0122     		movs	r2, #1
 574 0280 02FA03F3 		lsl	r3, r2, r3
 575 0284 DA43     		mvns	r2, r3
 576 0286 244B     		ldr	r3, .L37+8
 577 0288 1B68     		ldr	r3, [r3]
 578 028a 1340     		ands	r3, r3, r2
 579 028c 224A     		ldr	r2, .L37+8
 580 028e 1360     		str	r3, [r2]
 581              	.L30:
1176:FreeRTOS/Source/tasks.c **** 			}
1177:FreeRTOS/Source/tasks.c **** 			else
1178:FreeRTOS/Source/tasks.c **** 			{
1179:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1180:FreeRTOS/Source/tasks.c **** 			}
1181:FreeRTOS/Source/tasks.c **** 
1182:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1183:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 582              		.loc 1 1183 0 is_stmt 1
 583 0290 FB68     		ldr	r3, [r7, #12]
 584 0292 9B6A     		ldr	r3, [r3, #40]
 585 0294 002B     		cmp	r3, #0
 586 0296 04D0     		beq	.L32
1184:FreeRTOS/Source/tasks.c **** 			{
1185:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 587              		.loc 1 1185 0
 588 0298 FB68     		ldr	r3, [r7, #12]
 589 029a 1833     		adds	r3, r3, #24
 590 029c 1846     		mov	r0, r3
 591 029e FFF7FEFF 		bl	uxListRemove
 592              	.L32:
1186:FreeRTOS/Source/tasks.c **** 			}
1187:FreeRTOS/Source/tasks.c **** 			else
1188:FreeRTOS/Source/tasks.c **** 			{
1189:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1190:FreeRTOS/Source/tasks.c **** 			}
1191:FreeRTOS/Source/tasks.c **** 
1192:FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1193:FreeRTOS/Source/tasks.c **** 			detect that the task lists need re-generating.  This is done before
1194:FreeRTOS/Source/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1195:FreeRTOS/Source/tasks.c **** 			not return. */
1196:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 593              		.loc 1 1196 0
 594 02a2 1E4B     		ldr	r3, .L37+12
 595 02a4 1B68     		ldr	r3, [r3]
 596 02a6 0133     		adds	r3, r3, #1
 597 02a8 1C4A     		ldr	r2, .L37+12
 598 02aa 1360     		str	r3, [r2]
1197:FreeRTOS/Source/tasks.c **** 
1198:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 599              		.loc 1 1198 0
 600 02ac 184B     		ldr	r3, .L37
ARM GAS  /tmp/cckqXCjj.s 			page 33


 601 02ae 1B68     		ldr	r3, [r3]
 602 02b0 FA68     		ldr	r2, [r7, #12]
 603 02b2 9A42     		cmp	r2, r3
 604 02b4 0BD1     		bne	.L33
1199:FreeRTOS/Source/tasks.c **** 			{
1200:FreeRTOS/Source/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
1201:FreeRTOS/Source/tasks.c **** 				task itself, as a context switch to another task is required.
1202:FreeRTOS/Source/tasks.c **** 				Place the task in the termination list.  The idle task will
1203:FreeRTOS/Source/tasks.c **** 				check the termination list and free up any memory allocated by
1204:FreeRTOS/Source/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
1205:FreeRTOS/Source/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 605              		.loc 1 1205 0
 606 02b6 FB68     		ldr	r3, [r7, #12]
 607 02b8 0433     		adds	r3, r3, #4
 608 02ba 1946     		mov	r1, r3
 609 02bc 1848     		ldr	r0, .L37+16
 610 02be FFF7FEFF 		bl	vListInsertEnd
1206:FreeRTOS/Source/tasks.c **** 
1207:FreeRTOS/Source/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
1208:FreeRTOS/Source/tasks.c **** 				there is a task that has been deleted and that it should therefore
1209:FreeRTOS/Source/tasks.c **** 				check the xTasksWaitingTermination list. */
1210:FreeRTOS/Source/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
 611              		.loc 1 1210 0
 612 02c2 184B     		ldr	r3, .L37+20
 613 02c4 1B68     		ldr	r3, [r3]
 614 02c6 0133     		adds	r3, r3, #1
 615 02c8 164A     		ldr	r2, .L37+20
 616 02ca 1360     		str	r3, [r2]
 617 02cc 09E0     		b	.L34
 618              	.L33:
1211:FreeRTOS/Source/tasks.c **** 
1212:FreeRTOS/Source/tasks.c **** 				/* Call the delete hook before portPRE_TASK_DELETE_HOOK() as
1213:FreeRTOS/Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */
1214:FreeRTOS/Source/tasks.c **** 				traceTASK_DELETE( pxTCB );
1215:FreeRTOS/Source/tasks.c **** 
1216:FreeRTOS/Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1217:FreeRTOS/Source/tasks.c **** 				in which Windows specific clean up operations are performed,
1218:FreeRTOS/Source/tasks.c **** 				after which it is not possible to yield away from this task -
1219:FreeRTOS/Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1220:FreeRTOS/Source/tasks.c **** 				required. */
1221:FreeRTOS/Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1222:FreeRTOS/Source/tasks.c **** 			}
1223:FreeRTOS/Source/tasks.c **** 			else
1224:FreeRTOS/Source/tasks.c **** 			{
1225:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
 619              		.loc 1 1225 0
 620 02ce 164B     		ldr	r3, .L37+24
 621 02d0 1B68     		ldr	r3, [r3]
 622 02d2 013B     		subs	r3, r3, #1
 623 02d4 144A     		ldr	r2, .L37+24
 624 02d6 1360     		str	r3, [r2]
1226:FreeRTOS/Source/tasks.c **** 				traceTASK_DELETE( pxTCB );
1227:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 625              		.loc 1 1227 0
 626 02d8 F868     		ldr	r0, [r7, #12]
 627 02da 00F0C5FE 		bl	prvDeleteTCB
1228:FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/cckqXCjj.s 			page 34


1229:FreeRTOS/Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1230:FreeRTOS/Source/tasks.c **** 				the task that has just been deleted. */
1231:FreeRTOS/Source/tasks.c **** 				prvResetNextTaskUnblockTime();
 628              		.loc 1 1231 0
 629 02de 00F0D3FE 		bl	prvResetNextTaskUnblockTime
 630              	.L34:
1232:FreeRTOS/Source/tasks.c **** 			}
1233:FreeRTOS/Source/tasks.c **** 		}
1234:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 631              		.loc 1 1234 0
 632 02e2 FFF7FEFF 		bl	vPortExitCritical
1235:FreeRTOS/Source/tasks.c **** 
1236:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1237:FreeRTOS/Source/tasks.c **** 		been deleted. */
1238:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 633              		.loc 1 1238 0
 634 02e6 114B     		ldr	r3, .L37+28
 635 02e8 1B68     		ldr	r3, [r3]
 636 02ea 002B     		cmp	r3, #0
 637 02ec 0CD0     		beq	.L36
1239:FreeRTOS/Source/tasks.c **** 		{
1240:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 638              		.loc 1 1240 0
 639 02ee 084B     		ldr	r3, .L37
 640 02f0 1B68     		ldr	r3, [r3]
 641 02f2 FA68     		ldr	r2, [r7, #12]
 642 02f4 9A42     		cmp	r2, r3
 643 02f6 07D1     		bne	.L36
1241:FreeRTOS/Source/tasks.c **** 			{
1242:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1243:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 644              		.loc 1 1243 0
 645 02f8 0D4B     		ldr	r3, .L37+32
 646 02fa 4FF08052 		mov	r2, #268435456
 647 02fe 1A60     		str	r2, [r3]
 648              		.syntax unified
 649              	@ 1243 "FreeRTOS/Source/tasks.c" 1
 650 0300 BFF34F8F 		dsb
 651              	@ 0 "" 2
 652              	@ 1243 "FreeRTOS/Source/tasks.c" 1
 653 0304 BFF36F8F 		isb
 654              	@ 0 "" 2
 655              		.thumb
 656              		.syntax unified
 657              	.L36:
1244:FreeRTOS/Source/tasks.c **** 			}
1245:FreeRTOS/Source/tasks.c **** 			else
1246:FreeRTOS/Source/tasks.c **** 			{
1247:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1248:FreeRTOS/Source/tasks.c **** 			}
1249:FreeRTOS/Source/tasks.c **** 		}
1250:FreeRTOS/Source/tasks.c **** 	}
 658              		.loc 1 1250 0
 659 0308 00BF     		nop
 660 030a 1037     		adds	r7, r7, #16
 661              		.cfi_def_cfa_offset 8
 662 030c BD46     		mov	sp, r7
ARM GAS  /tmp/cckqXCjj.s 			page 35


 663              		.cfi_def_cfa_register 13
 664              		@ sp needed
 665 030e 80BD     		pop	{r7, pc}
 666              	.L38:
 667              		.align	2
 668              	.L37:
 669 0310 00000000 		.word	pxCurrentTCB
 670 0314 04000000 		.word	pxReadyTasksLists
 671 0318 E0000000 		.word	uxTopReadyPriority
 672 031c F4000000 		.word	uxTaskNumber
 673 0320 AC000000 		.word	xTasksWaitingTermination
 674 0324 C0000000 		.word	uxDeletedTasksWaitingCleanUp
 675 0328 D8000000 		.word	uxCurrentNumberOfTasks
 676 032c E4000000 		.word	xSchedulerRunning
 677 0330 04ED00E0 		.word	-536810236
 678              		.cfi_endproc
 679              	.LFE8:
 680              		.size	vTaskDelete, .-vTaskDelete
 681              		.align	1
 682              		.global	vTaskDelayUntil
 683              		.syntax unified
 684              		.thumb
 685              		.thumb_func
 686              		.fpu softvfp
 687              		.type	vTaskDelayUntil, %function
 688              	vTaskDelayUntil:
 689              	.LFB9:
1251:FreeRTOS/Source/tasks.c **** 
1252:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1253:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1254:FreeRTOS/Source/tasks.c **** 
1255:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1256:FreeRTOS/Source/tasks.c **** 
1257:FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1258:FreeRTOS/Source/tasks.c **** 	{
 690              		.loc 1 1258 0
 691              		.cfi_startproc
 692              		@ args = 0, pretend = 0, frame = 24
 693              		@ frame_needed = 1, uses_anonymous_args = 0
 694 0334 80B5     		push	{r7, lr}
 695              		.cfi_def_cfa_offset 8
 696              		.cfi_offset 7, -8
 697              		.cfi_offset 14, -4
 698 0336 86B0     		sub	sp, sp, #24
 699              		.cfi_def_cfa_offset 32
 700 0338 00AF     		add	r7, sp, #0
 701              		.cfi_def_cfa_register 7
 702 033a 7860     		str	r0, [r7, #4]
 703 033c 3960     		str	r1, [r7]
1259:FreeRTOS/Source/tasks.c **** 	TickType_t xTimeToWake;
1260:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 704              		.loc 1 1260 0
 705 033e 0023     		movs	r3, #0
 706 0340 7B61     		str	r3, [r7, #20]
1261:FreeRTOS/Source/tasks.c **** 
1262:FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
1263:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
ARM GAS  /tmp/cckqXCjj.s 			page 36


1264:FreeRTOS/Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
1265:FreeRTOS/Source/tasks.c **** 
1266:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 707              		.loc 1 1266 0
 708 0342 FFF7FEFF 		bl	vTaskSuspendAll
 709              	.LBB27:
1267:FreeRTOS/Source/tasks.c **** 		{
1268:FreeRTOS/Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1269:FreeRTOS/Source/tasks.c **** 			block. */
1270:FreeRTOS/Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 710              		.loc 1 1270 0
 711 0346 214B     		ldr	r3, .L46
 712 0348 1B68     		ldr	r3, [r3]
 713 034a 3B61     		str	r3, [r7, #16]
1271:FreeRTOS/Source/tasks.c **** 
1272:FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1273:FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 714              		.loc 1 1273 0
 715 034c 7B68     		ldr	r3, [r7, #4]
 716 034e 1A68     		ldr	r2, [r3]
 717 0350 3B68     		ldr	r3, [r7]
 718 0352 1344     		add	r3, r3, r2
 719 0354 FB60     		str	r3, [r7, #12]
1274:FreeRTOS/Source/tasks.c **** 
1275:FreeRTOS/Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 720              		.loc 1 1275 0
 721 0356 7B68     		ldr	r3, [r7, #4]
 722 0358 1A68     		ldr	r2, [r3]
 723 035a 3B69     		ldr	r3, [r7, #16]
 724 035c 9A42     		cmp	r2, r3
 725 035e 0BD9     		bls	.L40
1276:FreeRTOS/Source/tasks.c **** 			{
1277:FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
1278:FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
1279:FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1280:FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
1281:FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
1282:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 726              		.loc 1 1282 0
 727 0360 7B68     		ldr	r3, [r7, #4]
 728 0362 1A68     		ldr	r2, [r3]
 729 0364 FB68     		ldr	r3, [r7, #12]
 730 0366 9A42     		cmp	r2, r3
 731 0368 11D9     		bls	.L41
 732              		.loc 1 1282 0 is_stmt 0 discriminator 1
 733 036a FA68     		ldr	r2, [r7, #12]
 734 036c 3B69     		ldr	r3, [r7, #16]
 735 036e 9A42     		cmp	r2, r3
 736 0370 0DD9     		bls	.L41
1283:FreeRTOS/Source/tasks.c **** 				{
1284:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 737              		.loc 1 1284 0 is_stmt 1
 738 0372 0123     		movs	r3, #1
 739 0374 7B61     		str	r3, [r7, #20]
 740 0376 0AE0     		b	.L41
 741              	.L40:
1285:FreeRTOS/Source/tasks.c **** 				}
ARM GAS  /tmp/cckqXCjj.s 			page 37


1286:FreeRTOS/Source/tasks.c **** 				else
1287:FreeRTOS/Source/tasks.c **** 				{
1288:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1289:FreeRTOS/Source/tasks.c **** 				}
1290:FreeRTOS/Source/tasks.c **** 			}
1291:FreeRTOS/Source/tasks.c **** 			else
1292:FreeRTOS/Source/tasks.c **** 			{
1293:FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1294:FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1295:FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
1296:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 742              		.loc 1 1296 0
 743 0378 7B68     		ldr	r3, [r7, #4]
 744 037a 1A68     		ldr	r2, [r3]
 745 037c FB68     		ldr	r3, [r7, #12]
 746 037e 9A42     		cmp	r2, r3
 747 0380 03D8     		bhi	.L42
 748              		.loc 1 1296 0 is_stmt 0 discriminator 1
 749 0382 FA68     		ldr	r2, [r7, #12]
 750 0384 3B69     		ldr	r3, [r7, #16]
 751 0386 9A42     		cmp	r2, r3
 752 0388 01D9     		bls	.L41
 753              	.L42:
1297:FreeRTOS/Source/tasks.c **** 				{
1298:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 754              		.loc 1 1298 0 is_stmt 1
 755 038a 0123     		movs	r3, #1
 756 038c 7B61     		str	r3, [r7, #20]
 757              	.L41:
1299:FreeRTOS/Source/tasks.c **** 				}
1300:FreeRTOS/Source/tasks.c **** 				else
1301:FreeRTOS/Source/tasks.c **** 				{
1302:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1303:FreeRTOS/Source/tasks.c **** 				}
1304:FreeRTOS/Source/tasks.c **** 			}
1305:FreeRTOS/Source/tasks.c **** 
1306:FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
1307:FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 758              		.loc 1 1307 0
 759 038e 7B68     		ldr	r3, [r7, #4]
 760 0390 FA68     		ldr	r2, [r7, #12]
 761 0392 1A60     		str	r2, [r3]
1308:FreeRTOS/Source/tasks.c **** 
1309:FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 762              		.loc 1 1309 0
 763 0394 7B69     		ldr	r3, [r7, #20]
 764 0396 002B     		cmp	r3, #0
 765 0398 06D0     		beq	.L43
1310:FreeRTOS/Source/tasks.c **** 			{
1311:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1312:FreeRTOS/Source/tasks.c **** 
1313:FreeRTOS/Source/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1314:FreeRTOS/Source/tasks.c **** 				the time to wake, so subtract the current tick count. */
1315:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 766              		.loc 1 1315 0
 767 039a FA68     		ldr	r2, [r7, #12]
 768 039c 3B69     		ldr	r3, [r7, #16]
ARM GAS  /tmp/cckqXCjj.s 			page 38


 769 039e D31A     		subs	r3, r2, r3
 770 03a0 0021     		movs	r1, #0
 771 03a2 1846     		mov	r0, r3
 772 03a4 01F054F9 		bl	prvAddCurrentTaskToDelayedList
 773              	.L43:
 774              	.LBE27:
1316:FreeRTOS/Source/tasks.c **** 			}
1317:FreeRTOS/Source/tasks.c **** 			else
1318:FreeRTOS/Source/tasks.c **** 			{
1319:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1320:FreeRTOS/Source/tasks.c **** 			}
1321:FreeRTOS/Source/tasks.c **** 		}
1322:FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 775              		.loc 1 1322 0
 776 03a8 FFF7FEFF 		bl	xTaskResumeAll
 777 03ac B860     		str	r0, [r7, #8]
1323:FreeRTOS/Source/tasks.c **** 
1324:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1325:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
1326:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 778              		.loc 1 1326 0
 779 03ae BB68     		ldr	r3, [r7, #8]
 780 03b0 002B     		cmp	r3, #0
 781 03b2 07D1     		bne	.L45
1327:FreeRTOS/Source/tasks.c **** 		{
1328:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 782              		.loc 1 1328 0
 783 03b4 064B     		ldr	r3, .L46+4
 784 03b6 4FF08052 		mov	r2, #268435456
 785 03ba 1A60     		str	r2, [r3]
 786              		.syntax unified
 787              	@ 1328 "FreeRTOS/Source/tasks.c" 1
 788 03bc BFF34F8F 		dsb
 789              	@ 0 "" 2
 790              	@ 1328 "FreeRTOS/Source/tasks.c" 1
 791 03c0 BFF36F8F 		isb
 792              	@ 0 "" 2
 793              		.thumb
 794              		.syntax unified
 795              	.L45:
1329:FreeRTOS/Source/tasks.c **** 		}
1330:FreeRTOS/Source/tasks.c **** 		else
1331:FreeRTOS/Source/tasks.c **** 		{
1332:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1333:FreeRTOS/Source/tasks.c **** 		}
1334:FreeRTOS/Source/tasks.c **** 	}
 796              		.loc 1 1334 0
 797 03c4 00BF     		nop
 798 03c6 1837     		adds	r7, r7, #24
 799              		.cfi_def_cfa_offset 8
 800 03c8 BD46     		mov	sp, r7
 801              		.cfi_def_cfa_register 13
 802              		@ sp needed
 803 03ca 80BD     		pop	{r7, pc}
 804              	.L47:
 805              		.align	2
 806              	.L46:
ARM GAS  /tmp/cckqXCjj.s 			page 39


 807 03cc DC000000 		.word	xTickCount
 808 03d0 04ED00E0 		.word	-536810236
 809              		.cfi_endproc
 810              	.LFE9:
 811              		.size	vTaskDelayUntil, .-vTaskDelayUntil
 812              		.align	1
 813              		.global	vTaskDelay
 814              		.syntax unified
 815              		.thumb
 816              		.thumb_func
 817              		.fpu softvfp
 818              		.type	vTaskDelay, %function
 819              	vTaskDelay:
 820              	.LFB10:
1335:FreeRTOS/Source/tasks.c **** 
1336:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1337:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1338:FreeRTOS/Source/tasks.c **** 
1339:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1340:FreeRTOS/Source/tasks.c **** 
1341:FreeRTOS/Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1342:FreeRTOS/Source/tasks.c **** 	{
 821              		.loc 1 1342 0
 822              		.cfi_startproc
 823              		@ args = 0, pretend = 0, frame = 16
 824              		@ frame_needed = 1, uses_anonymous_args = 0
 825 03d4 80B5     		push	{r7, lr}
 826              		.cfi_def_cfa_offset 8
 827              		.cfi_offset 7, -8
 828              		.cfi_offset 14, -4
 829 03d6 84B0     		sub	sp, sp, #16
 830              		.cfi_def_cfa_offset 24
 831 03d8 00AF     		add	r7, sp, #0
 832              		.cfi_def_cfa_register 7
 833 03da 7860     		str	r0, [r7, #4]
1343:FreeRTOS/Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 834              		.loc 1 1343 0
 835 03dc 0023     		movs	r3, #0
 836 03de FB60     		str	r3, [r7, #12]
1344:FreeRTOS/Source/tasks.c **** 
1345:FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1346:FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
 837              		.loc 1 1346 0
 838 03e0 7B68     		ldr	r3, [r7, #4]
 839 03e2 002B     		cmp	r3, #0
 840 03e4 08D0     		beq	.L49
1347:FreeRTOS/Source/tasks.c **** 		{
1348:FreeRTOS/Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
1349:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 841              		.loc 1 1349 0
 842 03e6 FFF7FEFF 		bl	vTaskSuspendAll
1350:FreeRTOS/Source/tasks.c **** 			{
1351:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
1352:FreeRTOS/Source/tasks.c **** 
1353:FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
1354:FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
1355:FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
ARM GAS  /tmp/cckqXCjj.s 			page 40


1356:FreeRTOS/Source/tasks.c **** 				is resumed.
1357:FreeRTOS/Source/tasks.c **** 
1358:FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
1359:FreeRTOS/Source/tasks.c **** 				executing task. */
1360:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 843              		.loc 1 1360 0
 844 03ea 0021     		movs	r1, #0
 845 03ec 7868     		ldr	r0, [r7, #4]
 846 03ee 01F02FF9 		bl	prvAddCurrentTaskToDelayedList
1361:FreeRTOS/Source/tasks.c **** 			}
1362:FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 847              		.loc 1 1362 0
 848 03f2 FFF7FEFF 		bl	xTaskResumeAll
 849 03f6 F860     		str	r0, [r7, #12]
 850              	.L49:
1363:FreeRTOS/Source/tasks.c **** 		}
1364:FreeRTOS/Source/tasks.c **** 		else
1365:FreeRTOS/Source/tasks.c **** 		{
1366:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1367:FreeRTOS/Source/tasks.c **** 		}
1368:FreeRTOS/Source/tasks.c **** 
1369:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1370:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
1371:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 851              		.loc 1 1371 0
 852 03f8 FB68     		ldr	r3, [r7, #12]
 853 03fa 002B     		cmp	r3, #0
 854 03fc 07D1     		bne	.L51
1372:FreeRTOS/Source/tasks.c **** 		{
1373:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 855              		.loc 1 1373 0
 856 03fe 064B     		ldr	r3, .L52
 857 0400 4FF08052 		mov	r2, #268435456
 858 0404 1A60     		str	r2, [r3]
 859              		.syntax unified
 860              	@ 1373 "FreeRTOS/Source/tasks.c" 1
 861 0406 BFF34F8F 		dsb
 862              	@ 0 "" 2
 863              	@ 1373 "FreeRTOS/Source/tasks.c" 1
 864 040a BFF36F8F 		isb
 865              	@ 0 "" 2
 866              		.thumb
 867              		.syntax unified
 868              	.L51:
1374:FreeRTOS/Source/tasks.c **** 		}
1375:FreeRTOS/Source/tasks.c **** 		else
1376:FreeRTOS/Source/tasks.c **** 		{
1377:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1378:FreeRTOS/Source/tasks.c **** 		}
1379:FreeRTOS/Source/tasks.c **** 	}
 869              		.loc 1 1379 0
 870 040e 00BF     		nop
 871 0410 1037     		adds	r7, r7, #16
 872              		.cfi_def_cfa_offset 8
 873 0412 BD46     		mov	sp, r7
 874              		.cfi_def_cfa_register 13
 875              		@ sp needed
ARM GAS  /tmp/cckqXCjj.s 			page 41


 876 0414 80BD     		pop	{r7, pc}
 877              	.L53:
 878 0416 00BF     		.align	2
 879              	.L52:
 880 0418 04ED00E0 		.word	-536810236
 881              		.cfi_endproc
 882              	.LFE10:
 883              		.size	vTaskDelay, .-vTaskDelay
 884              		.align	1
 885              		.global	uxTaskPriorityGet
 886              		.syntax unified
 887              		.thumb
 888              		.thumb_func
 889              		.fpu softvfp
 890              		.type	uxTaskPriorityGet, %function
 891              	uxTaskPriorityGet:
 892              	.LFB11:
1380:FreeRTOS/Source/tasks.c **** 
1381:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1382:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1383:FreeRTOS/Source/tasks.c **** 
1384:FreeRTOS/Source/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDel
1385:FreeRTOS/Source/tasks.c **** 
1386:FreeRTOS/Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1387:FreeRTOS/Source/tasks.c **** 	{
1388:FreeRTOS/Source/tasks.c **** 	eTaskState eReturn;
1389:FreeRTOS/Source/tasks.c **** 	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
1390:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
1391:FreeRTOS/Source/tasks.c **** 
1392:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1393:FreeRTOS/Source/tasks.c **** 
1394:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
1395:FreeRTOS/Source/tasks.c **** 		{
1396:FreeRTOS/Source/tasks.c **** 			/* The task calling this function is querying its own state. */
1397:FreeRTOS/Source/tasks.c **** 			eReturn = eRunning;
1398:FreeRTOS/Source/tasks.c **** 		}
1399:FreeRTOS/Source/tasks.c **** 		else
1400:FreeRTOS/Source/tasks.c **** 		{
1401:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1402:FreeRTOS/Source/tasks.c **** 			{
1403:FreeRTOS/Source/tasks.c **** 				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
1404:FreeRTOS/Source/tasks.c **** 				pxDelayedList = pxDelayedTaskList;
1405:FreeRTOS/Source/tasks.c **** 				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
1406:FreeRTOS/Source/tasks.c **** 			}
1407:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1408:FreeRTOS/Source/tasks.c **** 
1409:FreeRTOS/Source/tasks.c **** 			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
1410:FreeRTOS/Source/tasks.c **** 			{
1411:FreeRTOS/Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1412:FreeRTOS/Source/tasks.c **** 				lists. */
1413:FreeRTOS/Source/tasks.c **** 				eReturn = eBlocked;
1414:FreeRTOS/Source/tasks.c **** 			}
1415:FreeRTOS/Source/tasks.c **** 
1416:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1417:FreeRTOS/Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
1418:FreeRTOS/Source/tasks.c **** 				{
1419:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the suspended
ARM GAS  /tmp/cckqXCjj.s 			page 42


1420:FreeRTOS/Source/tasks.c **** 					list.  Is it genuinely suspended or is it blocked
1421:FreeRTOS/Source/tasks.c **** 					indefinitely? */
1422:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
1423:FreeRTOS/Source/tasks.c **** 					{
1424:FreeRTOS/Source/tasks.c **** 						#if( configUSE_TASK_NOTIFICATIONS == 1 )
1425:FreeRTOS/Source/tasks.c **** 						{
1426:FreeRTOS/Source/tasks.c **** 							/* The task does not appear on the event list item of
1427:FreeRTOS/Source/tasks.c **** 							and of the RTOS objects, but could still be in the
1428:FreeRTOS/Source/tasks.c **** 							blocked state if it is waiting on its notification
1429:FreeRTOS/Source/tasks.c **** 							rather than waiting on an object. */
1430:FreeRTOS/Source/tasks.c **** 							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
1431:FreeRTOS/Source/tasks.c **** 							{
1432:FreeRTOS/Source/tasks.c **** 								eReturn = eBlocked;
1433:FreeRTOS/Source/tasks.c **** 							}
1434:FreeRTOS/Source/tasks.c **** 							else
1435:FreeRTOS/Source/tasks.c **** 							{
1436:FreeRTOS/Source/tasks.c **** 								eReturn = eSuspended;
1437:FreeRTOS/Source/tasks.c **** 							}
1438:FreeRTOS/Source/tasks.c **** 						}
1439:FreeRTOS/Source/tasks.c **** 						#else
1440:FreeRTOS/Source/tasks.c **** 						{
1441:FreeRTOS/Source/tasks.c **** 							eReturn = eSuspended;
1442:FreeRTOS/Source/tasks.c **** 						}
1443:FreeRTOS/Source/tasks.c **** 						#endif
1444:FreeRTOS/Source/tasks.c **** 					}
1445:FreeRTOS/Source/tasks.c **** 					else
1446:FreeRTOS/Source/tasks.c **** 					{
1447:FreeRTOS/Source/tasks.c **** 						eReturn = eBlocked;
1448:FreeRTOS/Source/tasks.c **** 					}
1449:FreeRTOS/Source/tasks.c **** 				}
1450:FreeRTOS/Source/tasks.c **** 			#endif
1451:FreeRTOS/Source/tasks.c **** 
1452:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1453:FreeRTOS/Source/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
1454:FreeRTOS/Source/tasks.c **** 				{
1455:FreeRTOS/Source/tasks.c **** 					/* The task being queried is referenced from the deleted
1456:FreeRTOS/Source/tasks.c **** 					tasks list, or it is not referenced from any lists at
1457:FreeRTOS/Source/tasks.c **** 					all. */
1458:FreeRTOS/Source/tasks.c **** 					eReturn = eDeleted;
1459:FreeRTOS/Source/tasks.c **** 				}
1460:FreeRTOS/Source/tasks.c **** 			#endif
1461:FreeRTOS/Source/tasks.c **** 
1462:FreeRTOS/Source/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1463:FreeRTOS/Source/tasks.c **** 			{
1464:FreeRTOS/Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
1465:FreeRTOS/Source/tasks.c **** 				Ready (including pending ready) state. */
1466:FreeRTOS/Source/tasks.c **** 				eReturn = eReady;
1467:FreeRTOS/Source/tasks.c **** 			}
1468:FreeRTOS/Source/tasks.c **** 		}
1469:FreeRTOS/Source/tasks.c **** 
1470:FreeRTOS/Source/tasks.c **** 		return eReturn;
1471:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
1472:FreeRTOS/Source/tasks.c **** 
1473:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1474:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1475:FreeRTOS/Source/tasks.c **** 
1476:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
ARM GAS  /tmp/cckqXCjj.s 			page 43


1477:FreeRTOS/Source/tasks.c **** 
1478:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
1479:FreeRTOS/Source/tasks.c **** 	{
 893              		.loc 1 1479 0
 894              		.cfi_startproc
 895              		@ args = 0, pretend = 0, frame = 16
 896              		@ frame_needed = 1, uses_anonymous_args = 0
 897 041c 80B5     		push	{r7, lr}
 898              		.cfi_def_cfa_offset 8
 899              		.cfi_offset 7, -8
 900              		.cfi_offset 14, -4
 901 041e 84B0     		sub	sp, sp, #16
 902              		.cfi_def_cfa_offset 24
 903 0420 00AF     		add	r7, sp, #0
 904              		.cfi_def_cfa_register 7
 905 0422 7860     		str	r0, [r7, #4]
1480:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
1481:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
1482:FreeRTOS/Source/tasks.c **** 
1483:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 906              		.loc 1 1483 0
 907 0424 FFF7FEFF 		bl	vPortEnterCritical
1484:FreeRTOS/Source/tasks.c **** 		{
1485:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the task
1486:FreeRTOS/Source/tasks.c **** 			that called uxTaskPriorityGet() that is being queried. */
1487:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 908              		.loc 1 1487 0
 909 0428 7B68     		ldr	r3, [r7, #4]
 910 042a 002B     		cmp	r3, #0
 911 042c 02D1     		bne	.L55
 912              		.loc 1 1487 0 is_stmt 0 discriminator 1
 913 042e 074B     		ldr	r3, .L58
 914 0430 1B68     		ldr	r3, [r3]
 915 0432 00E0     		b	.L56
 916              	.L55:
 917              		.loc 1 1487 0 discriminator 2
 918 0434 7B68     		ldr	r3, [r7, #4]
 919              	.L56:
 920              		.loc 1 1487 0 discriminator 4
 921 0436 FB60     		str	r3, [r7, #12]
1488:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 922              		.loc 1 1488 0 is_stmt 1 discriminator 4
 923 0438 FB68     		ldr	r3, [r7, #12]
 924 043a DB6A     		ldr	r3, [r3, #44]
 925 043c BB60     		str	r3, [r7, #8]
1489:FreeRTOS/Source/tasks.c **** 		}
1490:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 926              		.loc 1 1490 0 discriminator 4
 927 043e FFF7FEFF 		bl	vPortExitCritical
1491:FreeRTOS/Source/tasks.c **** 
1492:FreeRTOS/Source/tasks.c **** 		return uxReturn;
 928              		.loc 1 1492 0 discriminator 4
 929 0442 BB68     		ldr	r3, [r7, #8]
1493:FreeRTOS/Source/tasks.c **** 	}
 930              		.loc 1 1493 0 discriminator 4
 931 0444 1846     		mov	r0, r3
 932 0446 1037     		adds	r7, r7, #16
ARM GAS  /tmp/cckqXCjj.s 			page 44


 933              		.cfi_def_cfa_offset 8
 934 0448 BD46     		mov	sp, r7
 935              		.cfi_def_cfa_register 13
 936              		@ sp needed
 937 044a 80BD     		pop	{r7, pc}
 938              	.L59:
 939              		.align	2
 940              	.L58:
 941 044c 00000000 		.word	pxCurrentTCB
 942              		.cfi_endproc
 943              	.LFE11:
 944              		.size	uxTaskPriorityGet, .-uxTaskPriorityGet
 945              		.align	1
 946              		.global	uxTaskPriorityGetFromISR
 947              		.syntax unified
 948              		.thumb
 949              		.thumb_func
 950              		.fpu softvfp
 951              		.type	uxTaskPriorityGetFromISR, %function
 952              	uxTaskPriorityGetFromISR:
 953              	.LFB12:
1494:FreeRTOS/Source/tasks.c **** 
1495:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1496:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1497:FreeRTOS/Source/tasks.c **** 
1498:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1499:FreeRTOS/Source/tasks.c **** 
1500:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
1501:FreeRTOS/Source/tasks.c **** 	{
 954              		.loc 1 1501 0
 955              		.cfi_startproc
 956              		@ args = 0, pretend = 0, frame = 32
 957              		@ frame_needed = 1, uses_anonymous_args = 0
 958              		@ link register save eliminated.
 959 0450 80B4     		push	{r7}
 960              		.cfi_def_cfa_offset 4
 961              		.cfi_offset 7, -4
 962 0452 89B0     		sub	sp, sp, #36
 963              		.cfi_def_cfa_offset 40
 964 0454 00AF     		add	r7, sp, #0
 965              		.cfi_def_cfa_register 7
 966 0456 7860     		str	r0, [r7, #4]
 967              	.LBB28:
 968              	.LBB29:
 969              		.file 2 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h"
   1:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*
   2:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * FreeRTOS Kernel V10.3.1
   3:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
   5:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * this software and associated documentation files (the "Software"), to deal in
   7:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * the Software without restriction, including without limitation the rights to
   8:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * subject to the following conditions:
  11:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  12:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * The above copyright notice and this permission notice shall be included in all
ARM GAS  /tmp/cckqXCjj.s 			page 45


  13:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * copies or substantial portions of the Software.
  14:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  15:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  22:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * http://www.FreeRTOS.org
  23:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * http://aws.amazon.com/freertos
  24:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  25:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * 1 tab == 4 spaces!
  26:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  */
  27:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  28:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  29:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #ifndef PORTMACRO_H
  30:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define PORTMACRO_H
  31:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  32:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #ifdef __cplusplus
  33:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** extern "C" {
  34:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
  35:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  36:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------
  37:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * Port specific definitions.
  38:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  39:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  40:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * given hardware and compiler.
  41:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *
  42:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  * These settings should not be altered.
  43:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  *-----------------------------------------------------------
  44:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h ****  */
  45:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  46:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Type definitions. */
  47:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portCHAR		char
  48:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portFLOAT		float
  49:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portDOUBLE		double
  50:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portLONG		long
  51:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portSHORT		short
  52:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portSTACK_TYPE	uint32_t
  53:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portBASE_TYPE	long
  54:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  55:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  56:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** typedef long BaseType_t;
  57:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** typedef unsigned long UBaseType_t;
  58:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  59:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
  60:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	typedef uint16_t TickType_t;
  61:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
  62:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #else
  63:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	typedef uint32_t TickType_t;
  64:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
  65:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  66:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
  67:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	not need to be guarded with a critical section. */
  68:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
  69:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
ARM GAS  /tmp/cckqXCjj.s 			page 46


  70:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  71:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  72:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Architecture specifics. */
  73:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portSTACK_GROWTH			( -1 )
  74:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
  75:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portBYTE_ALIGNMENT			8
  76:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  77:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  78:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Scheduler utilities. */
  79:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portYIELD() 															\
  80:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** {																				\
  81:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
  82:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
  83:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 																				\
  84:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
  85:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	within the specified behaviour for the architecture. */						\
  86:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile( "dsb" ::: "memory" );										\
  87:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile( "isb" );													\
  88:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
  89:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  90:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
  91:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
  92:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
  93:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
  94:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
  95:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
  96:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Critical section management. */
  97:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** extern void vPortEnterCritical( void );
  98:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** extern void vPortExitCritical( void );
  99:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 100:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 101:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 102:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 103:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 104:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 105:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 106:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 107:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 108:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 109:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 110:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** (which build with all the ports) will build. */
 111:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 112:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 113:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 114:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 115:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Tickless idle/low power functionality. */
 116:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 117:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 118:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 119:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
 120:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 121:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 122:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* Architecture specific optimisations. */
 123:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 124:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 125:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
 126:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
ARM GAS  /tmp/cckqXCjj.s 			page 47


 127:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 128:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 129:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Generic helper function. */
 130:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 131:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	{
 132:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	uint8_t ucReturn;
 133:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 134:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 135:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		return ucReturn;
 136:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	}
 137:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 138:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Check the configuration. */
 139:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 140:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 141:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#endif
 142:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 143:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 144:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 145:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 146:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 147:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/*-----------------------------------------------------------*/
 148:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 149:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 150:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 151:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 152:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 153:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 154:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 155:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #ifdef configASSERT
 156:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 157:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 158:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
 159:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 160:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /* portNOP() is not required by this port. */
 161:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portNOP()
 162:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 163:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #define portINLINE	__inline
 164:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 165:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #ifndef portFORCE_INLINE
 166:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 167:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** #endif
 168:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 169:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 170:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 171:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 172:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** {
 173:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** uint32_t ulCurrentInterrupt;
 174:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** BaseType_t xReturn;
 175:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 176:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 177:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 178:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 179:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 180:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	{
 181:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		xReturn = pdFALSE;
 182:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	}
 183:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	else
ARM GAS  /tmp/cckqXCjj.s 			page 48


 184:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	{
 185:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		xReturn = pdTRUE;
 186:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	}
 187:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 188:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	return xReturn;
 189:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
 190:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 191:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 192:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 193:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 194:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** {
 195:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** uint32_t ulNewBASEPRI;
 196:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 197:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile
 198:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 199:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	mov %0, %1												\n" \
 200:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	msr basepri, %0											\n" \
 201:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	isb														\n" \
 202:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 203:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
 204:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	);
 205:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
 206:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 207:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 208:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 209:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 210:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** {
 211:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 212:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 213:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile
 970              		.loc 2 213 0
 971              		.syntax unified
 972              	@ 213 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 973 0458 EFF31182 			mrs r2, basepri											
 974 045c 4FF0BF03 		mov r3, #191												
 975 0460 83F31188 		msr basepri, r3											
 976 0464 BFF36F8F 		isb														
 977 0468 BFF34F8F 		dsb														
 978              	
 979              	@ 0 "" 2
 980              		.thumb
 981              		.syntax unified
 982 046c 3A61     		str	r2, [r7, #16]
 983 046e FB60     		str	r3, [r7, #12]
 214:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 215:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	mrs %0, basepri											\n" \
 216:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	mov %1, %2												\n" \
 217:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	msr basepri, %1											\n" \
 218:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	isb														\n" \
 219:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 220:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "
 221:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	);
 222:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
 223:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 224:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	warnings. */
 225:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	return ulOriginalBASEPRI;
 984              		.loc 2 225 0
ARM GAS  /tmp/cckqXCjj.s 			page 49


 985 0470 3B69     		ldr	r3, [r7, #16]
 986              	.LBE29:
 987              	.LBE28:
1502:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
1503:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1504:FreeRTOS/Source/tasks.c **** 
1505:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1506:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1507:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1508:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1509:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1510:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1511:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1512:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1513:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1514:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1515:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1516:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1517:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1518:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1519:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1520:FreeRTOS/Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1521:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1522:FreeRTOS/Source/tasks.c **** 
1523:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 988              		.loc 1 1523 0
 989 0472 FB61     		str	r3, [r7, #28]
1524:FreeRTOS/Source/tasks.c **** 		{
1525:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1526:FreeRTOS/Source/tasks.c **** 			task that is being queried. */
1527:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 990              		.loc 1 1527 0
 991 0474 7B68     		ldr	r3, [r7, #4]
 992 0476 002B     		cmp	r3, #0
 993 0478 02D1     		bne	.L62
 994              		.loc 1 1527 0 is_stmt 0 discriminator 1
 995 047a 094B     		ldr	r3, .L65
 996 047c 1B68     		ldr	r3, [r3]
 997 047e 00E0     		b	.L63
 998              	.L62:
 999              		.loc 1 1527 0 discriminator 2
 1000 0480 7B68     		ldr	r3, [r7, #4]
 1001              	.L63:
 1002              		.loc 1 1527 0 discriminator 4
 1003 0482 BB61     		str	r3, [r7, #24]
1528:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1004              		.loc 1 1528 0 is_stmt 1 discriminator 4
 1005 0484 BB69     		ldr	r3, [r7, #24]
 1006 0486 DB6A     		ldr	r3, [r3, #44]
 1007 0488 7B61     		str	r3, [r7, #20]
 1008 048a FB69     		ldr	r3, [r7, #28]
 1009 048c BB60     		str	r3, [r7, #8]
 1010              	.LBB30:
 1011              	.LBB31:
 226:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
 227:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 228:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 
ARM GAS  /tmp/cckqXCjj.s 			page 50


 229:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 230:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** {
 231:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	__asm volatile
 1012              		.loc 2 231 0 discriminator 4
 1013 048e BB68     		ldr	r3, [r7, #8]
 1014              		.syntax unified
 1015              	@ 231 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1016 0490 83F31188 			msr basepri, r3	
 1017              	@ 0 "" 2
 1018              		.thumb
 1019              		.syntax unified
 1020              	.LBE31:
 1021              	.LBE30:
1529:FreeRTOS/Source/tasks.c **** 		}
1530:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1531:FreeRTOS/Source/tasks.c **** 
1532:FreeRTOS/Source/tasks.c **** 		return uxReturn;
 1022              		.loc 1 1532 0 discriminator 4
 1023 0494 7B69     		ldr	r3, [r7, #20]
1533:FreeRTOS/Source/tasks.c **** 	}
 1024              		.loc 1 1533 0 discriminator 4
 1025 0496 1846     		mov	r0, r3
 1026 0498 2437     		adds	r7, r7, #36
 1027              		.cfi_def_cfa_offset 4
 1028 049a BD46     		mov	sp, r7
 1029              		.cfi_def_cfa_register 13
 1030              		@ sp needed
 1031 049c 80BC     		pop	{r7}
 1032              		.cfi_restore 7
 1033              		.cfi_def_cfa_offset 0
 1034 049e 7047     		bx	lr
 1035              	.L66:
 1036              		.align	2
 1037              	.L65:
 1038 04a0 00000000 		.word	pxCurrentTCB
 1039              		.cfi_endproc
 1040              	.LFE12:
 1041              		.size	uxTaskPriorityGetFromISR, .-uxTaskPriorityGetFromISR
 1042              		.align	1
 1043              		.global	vTaskPrioritySet
 1044              		.syntax unified
 1045              		.thumb
 1046              		.thumb_func
 1047              		.fpu softvfp
 1048              		.type	vTaskPrioritySet, %function
 1049              	vTaskPrioritySet:
 1050              	.LFB13:
1534:FreeRTOS/Source/tasks.c **** 
1535:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1536:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1537:FreeRTOS/Source/tasks.c **** 
1538:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1539:FreeRTOS/Source/tasks.c **** 
1540:FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1541:FreeRTOS/Source/tasks.c **** 	{
 1051              		.loc 1 1541 0
 1052              		.cfi_startproc
ARM GAS  /tmp/cckqXCjj.s 			page 51


 1053              		@ args = 0, pretend = 0, frame = 24
 1054              		@ frame_needed = 1, uses_anonymous_args = 0
 1055 04a4 80B5     		push	{r7, lr}
 1056              		.cfi_def_cfa_offset 8
 1057              		.cfi_offset 7, -8
 1058              		.cfi_offset 14, -4
 1059 04a6 86B0     		sub	sp, sp, #24
 1060              		.cfi_def_cfa_offset 32
 1061 04a8 00AF     		add	r7, sp, #0
 1062              		.cfi_def_cfa_register 7
 1063 04aa 7860     		str	r0, [r7, #4]
 1064 04ac 3960     		str	r1, [r7]
1542:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1543:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1544:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1065              		.loc 1 1544 0
 1066 04ae 0023     		movs	r3, #0
 1067 04b0 7B61     		str	r3, [r7, #20]
1545:FreeRTOS/Source/tasks.c **** 
1546:FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1547:FreeRTOS/Source/tasks.c **** 
1548:FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
1549:FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 1068              		.loc 1 1549 0
 1069 04b2 3B68     		ldr	r3, [r7]
 1070 04b4 042B     		cmp	r3, #4
 1071 04b6 01D9     		bls	.L68
1550:FreeRTOS/Source/tasks.c **** 		{
1551:FreeRTOS/Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 1072              		.loc 1 1551 0
 1073 04b8 0423     		movs	r3, #4
 1074 04ba 3B60     		str	r3, [r7]
 1075              	.L68:
1552:FreeRTOS/Source/tasks.c **** 		}
1553:FreeRTOS/Source/tasks.c **** 		else
1554:FreeRTOS/Source/tasks.c **** 		{
1555:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1556:FreeRTOS/Source/tasks.c **** 		}
1557:FreeRTOS/Source/tasks.c **** 
1558:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 1076              		.loc 1 1558 0
 1077 04bc FFF7FEFF 		bl	vPortEnterCritical
1559:FreeRTOS/Source/tasks.c **** 		{
1560:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1561:FreeRTOS/Source/tasks.c **** 			task that is being changed. */
1562:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 1078              		.loc 1 1562 0
 1079 04c0 7B68     		ldr	r3, [r7, #4]
 1080 04c2 002B     		cmp	r3, #0
 1081 04c4 02D1     		bne	.L69
 1082              		.loc 1 1562 0 is_stmt 0 discriminator 1
 1083 04c6 3C4B     		ldr	r3, .L77
 1084 04c8 1B68     		ldr	r3, [r3]
 1085 04ca 00E0     		b	.L70
 1086              	.L69:
 1087              		.loc 1 1562 0 discriminator 2
 1088 04cc 7B68     		ldr	r3, [r7, #4]
ARM GAS  /tmp/cckqXCjj.s 			page 52


 1089              	.L70:
 1090              		.loc 1 1562 0 discriminator 4
 1091 04ce 3B61     		str	r3, [r7, #16]
1563:FreeRTOS/Source/tasks.c **** 
1564:FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1565:FreeRTOS/Source/tasks.c **** 
1566:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1567:FreeRTOS/Source/tasks.c **** 			{
1568:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
1569:FreeRTOS/Source/tasks.c **** 			}
1570:FreeRTOS/Source/tasks.c **** 			#else
1571:FreeRTOS/Source/tasks.c **** 			{
1572:FreeRTOS/Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
 1092              		.loc 1 1572 0 is_stmt 1 discriminator 4
 1093 04d0 3B69     		ldr	r3, [r7, #16]
 1094 04d2 DB6A     		ldr	r3, [r3, #44]
 1095 04d4 FB60     		str	r3, [r7, #12]
1573:FreeRTOS/Source/tasks.c **** 			}
1574:FreeRTOS/Source/tasks.c **** 			#endif
1575:FreeRTOS/Source/tasks.c **** 
1576:FreeRTOS/Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
 1096              		.loc 1 1576 0 discriminator 4
 1097 04d6 FA68     		ldr	r2, [r7, #12]
 1098 04d8 3B68     		ldr	r3, [r7]
 1099 04da 9A42     		cmp	r2, r3
 1100 04dc 66D0     		beq	.L71
1577:FreeRTOS/Source/tasks.c **** 			{
1578:FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
1579:FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
1580:FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
 1101              		.loc 1 1580 0
 1102 04de 3A68     		ldr	r2, [r7]
 1103 04e0 FB68     		ldr	r3, [r7, #12]
 1104 04e2 9A42     		cmp	r2, r3
 1105 04e4 0DD9     		bls	.L72
1581:FreeRTOS/Source/tasks.c **** 				{
1582:FreeRTOS/Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
 1106              		.loc 1 1582 0
 1107 04e6 344B     		ldr	r3, .L77
 1108 04e8 1B68     		ldr	r3, [r3]
 1109 04ea 3A69     		ldr	r2, [r7, #16]
 1110 04ec 9A42     		cmp	r2, r3
 1111 04ee 0FD0     		beq	.L73
1583:FreeRTOS/Source/tasks.c **** 					{
1584:FreeRTOS/Source/tasks.c **** 						/* The priority of a task other than the currently
1585:FreeRTOS/Source/tasks.c **** 						running task is being raised.  Is the priority being
1586:FreeRTOS/Source/tasks.c **** 						raised above that of the running task? */
1587:FreeRTOS/Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 1112              		.loc 1 1587 0
 1113 04f0 314B     		ldr	r3, .L77
 1114 04f2 1B68     		ldr	r3, [r3]
 1115 04f4 DA6A     		ldr	r2, [r3, #44]
 1116 04f6 3B68     		ldr	r3, [r7]
 1117 04f8 9A42     		cmp	r2, r3
 1118 04fa 09D8     		bhi	.L73
1588:FreeRTOS/Source/tasks.c **** 						{
1589:FreeRTOS/Source/tasks.c **** 							xYieldRequired = pdTRUE;
ARM GAS  /tmp/cckqXCjj.s 			page 53


 1119              		.loc 1 1589 0
 1120 04fc 0123     		movs	r3, #1
 1121 04fe 7B61     		str	r3, [r7, #20]
 1122 0500 06E0     		b	.L73
 1123              	.L72:
1590:FreeRTOS/Source/tasks.c **** 						}
1591:FreeRTOS/Source/tasks.c **** 						else
1592:FreeRTOS/Source/tasks.c **** 						{
1593:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1594:FreeRTOS/Source/tasks.c **** 						}
1595:FreeRTOS/Source/tasks.c **** 					}
1596:FreeRTOS/Source/tasks.c **** 					else
1597:FreeRTOS/Source/tasks.c **** 					{
1598:FreeRTOS/Source/tasks.c **** 						/* The priority of the running task is being raised,
1599:FreeRTOS/Source/tasks.c **** 						but the running task must already be the highest
1600:FreeRTOS/Source/tasks.c **** 						priority task able to run so no yield is required. */
1601:FreeRTOS/Source/tasks.c **** 					}
1602:FreeRTOS/Source/tasks.c **** 				}
1603:FreeRTOS/Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
 1124              		.loc 1 1603 0
 1125 0502 2D4B     		ldr	r3, .L77
 1126 0504 1B68     		ldr	r3, [r3]
 1127 0506 3A69     		ldr	r2, [r7, #16]
 1128 0508 9A42     		cmp	r2, r3
 1129 050a 01D1     		bne	.L73
1604:FreeRTOS/Source/tasks.c **** 				{
1605:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of the running task down means
1606:FreeRTOS/Source/tasks.c **** 					there may now be another task of higher priority that
1607:FreeRTOS/Source/tasks.c **** 					is ready to execute. */
1608:FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 1130              		.loc 1 1608 0
 1131 050c 0123     		movs	r3, #1
 1132 050e 7B61     		str	r3, [r7, #20]
 1133              	.L73:
1609:FreeRTOS/Source/tasks.c **** 				}
1610:FreeRTOS/Source/tasks.c **** 				else
1611:FreeRTOS/Source/tasks.c **** 				{
1612:FreeRTOS/Source/tasks.c **** 					/* Setting the priority of any other task down does not
1613:FreeRTOS/Source/tasks.c **** 					require a yield as the running task must be above the
1614:FreeRTOS/Source/tasks.c **** 					new priority of the task being modified. */
1615:FreeRTOS/Source/tasks.c **** 				}
1616:FreeRTOS/Source/tasks.c **** 
1617:FreeRTOS/Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1618:FreeRTOS/Source/tasks.c **** 				before its uxPriority member is changed so the
1619:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1620:FreeRTOS/Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 1134              		.loc 1 1620 0
 1135 0510 3B69     		ldr	r3, [r7, #16]
 1136 0512 DB6A     		ldr	r3, [r3, #44]
 1137 0514 BB60     		str	r3, [r7, #8]
1621:FreeRTOS/Source/tasks.c **** 
1622:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1623:FreeRTOS/Source/tasks.c **** 				{
1624:FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
1625:FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
1626:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
1627:FreeRTOS/Source/tasks.c **** 					{
ARM GAS  /tmp/cckqXCjj.s 			page 54


1628:FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
1629:FreeRTOS/Source/tasks.c **** 					}
1630:FreeRTOS/Source/tasks.c **** 					else
1631:FreeRTOS/Source/tasks.c **** 					{
1632:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1633:FreeRTOS/Source/tasks.c **** 					}
1634:FreeRTOS/Source/tasks.c **** 
1635:FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
1636:FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
1637:FreeRTOS/Source/tasks.c **** 				}
1638:FreeRTOS/Source/tasks.c **** 				#else
1639:FreeRTOS/Source/tasks.c **** 				{
1640:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 1138              		.loc 1 1640 0
 1139 0516 3B69     		ldr	r3, [r7, #16]
 1140 0518 3A68     		ldr	r2, [r7]
 1141 051a DA62     		str	r2, [r3, #44]
1641:FreeRTOS/Source/tasks.c **** 				}
1642:FreeRTOS/Source/tasks.c **** 				#endif
1643:FreeRTOS/Source/tasks.c **** 
1644:FreeRTOS/Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1645:FreeRTOS/Source/tasks.c **** 				being used for anything else. */
1646:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 1142              		.loc 1 1646 0
 1143 051c 3B69     		ldr	r3, [r7, #16]
 1144 051e 9B69     		ldr	r3, [r3, #24]
 1145 0520 002B     		cmp	r3, #0
 1146 0522 04DB     		blt	.L74
1647:FreeRTOS/Source/tasks.c **** 				{
1648:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
 1147              		.loc 1 1648 0
 1148 0524 3B68     		ldr	r3, [r7]
 1149 0526 C3F10502 		rsb	r2, r3, #5
 1150 052a 3B69     		ldr	r3, [r7, #16]
 1151 052c 9A61     		str	r2, [r3, #24]
 1152              	.L74:
1649:FreeRTOS/Source/tasks.c **** 				}
1650:FreeRTOS/Source/tasks.c **** 				else
1651:FreeRTOS/Source/tasks.c **** 				{
1652:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1653:FreeRTOS/Source/tasks.c **** 				}
1654:FreeRTOS/Source/tasks.c **** 
1655:FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1656:FreeRTOS/Source/tasks.c **** 				nothing more than change its priority variable. However, if
1657:FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1658:FreeRTOS/Source/tasks.c **** 				in the list appropriate to its new priority. */
1659:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
 1153              		.loc 1 1659 0
 1154 052e 3B69     		ldr	r3, [r7, #16]
 1155 0530 5969     		ldr	r1, [r3, #20]
 1156 0532 BA68     		ldr	r2, [r7, #8]
 1157 0534 1346     		mov	r3, r2
 1158 0536 9B00     		lsls	r3, r3, #2
 1159 0538 1344     		add	r3, r3, r2
 1160 053a 9B00     		lsls	r3, r3, #2
 1161 053c 1F4A     		ldr	r2, .L77+4
 1162 053e 1344     		add	r3, r3, r2
ARM GAS  /tmp/cckqXCjj.s 			page 55


 1163 0540 9942     		cmp	r1, r3
 1164 0542 28D1     		bne	.L75
1660:FreeRTOS/Source/tasks.c **** 				{
1661:FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before
1662:FreeRTOS/Source/tasks.c **** 					adding it to it's new ready list.  As we are in a critical
1663:FreeRTOS/Source/tasks.c **** 					section we can do this even if the scheduler is suspended. */
1664:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1165              		.loc 1 1664 0
 1166 0544 3B69     		ldr	r3, [r7, #16]
 1167 0546 0433     		adds	r3, r3, #4
 1168 0548 1846     		mov	r0, r3
 1169 054a FFF7FEFF 		bl	uxListRemove
 1170 054e 0346     		mov	r3, r0
 1171 0550 002B     		cmp	r3, #0
 1172 0552 09D1     		bne	.L76
1665:FreeRTOS/Source/tasks.c **** 					{
1666:FreeRTOS/Source/tasks.c **** 						/* It is known that the task is in its ready list so
1667:FreeRTOS/Source/tasks.c **** 						there is no need to check again and the port level
1668:FreeRTOS/Source/tasks.c **** 						reset macro can be called directly. */
1669:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
 1173              		.loc 1 1669 0
 1174 0554 0122     		movs	r2, #1
 1175 0556 BB68     		ldr	r3, [r7, #8]
 1176 0558 02FA03F3 		lsl	r3, r2, r3
 1177 055c DA43     		mvns	r2, r3
 1178 055e 184B     		ldr	r3, .L77+8
 1179 0560 1B68     		ldr	r3, [r3]
 1180 0562 1340     		ands	r3, r3, r2
 1181 0564 164A     		ldr	r2, .L77+8
 1182 0566 1360     		str	r3, [r2]
 1183              	.L76:
1670:FreeRTOS/Source/tasks.c **** 					}
1671:FreeRTOS/Source/tasks.c **** 					else
1672:FreeRTOS/Source/tasks.c **** 					{
1673:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1674:FreeRTOS/Source/tasks.c **** 					}
1675:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1184              		.loc 1 1675 0
 1185 0568 3B69     		ldr	r3, [r7, #16]
 1186 056a DB6A     		ldr	r3, [r3, #44]
 1187 056c 0122     		movs	r2, #1
 1188 056e 9A40     		lsls	r2, r2, r3
 1189 0570 134B     		ldr	r3, .L77+8
 1190 0572 1B68     		ldr	r3, [r3]
 1191 0574 1343     		orrs	r3, r3, r2
 1192 0576 124A     		ldr	r2, .L77+8
 1193 0578 1360     		str	r3, [r2]
 1194 057a 3B69     		ldr	r3, [r7, #16]
 1195 057c DA6A     		ldr	r2, [r3, #44]
 1196 057e 1346     		mov	r3, r2
 1197 0580 9B00     		lsls	r3, r3, #2
 1198 0582 1344     		add	r3, r3, r2
 1199 0584 9B00     		lsls	r3, r3, #2
 1200 0586 0D4A     		ldr	r2, .L77+4
 1201 0588 1A44     		add	r2, r2, r3
 1202 058a 3B69     		ldr	r3, [r7, #16]
 1203 058c 0433     		adds	r3, r3, #4
ARM GAS  /tmp/cckqXCjj.s 			page 56


 1204 058e 1946     		mov	r1, r3
 1205 0590 1046     		mov	r0, r2
 1206 0592 FFF7FEFF 		bl	vListInsertEnd
 1207              	.L75:
1676:FreeRTOS/Source/tasks.c **** 				}
1677:FreeRTOS/Source/tasks.c **** 				else
1678:FreeRTOS/Source/tasks.c **** 				{
1679:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1680:FreeRTOS/Source/tasks.c **** 				}
1681:FreeRTOS/Source/tasks.c **** 
1682:FreeRTOS/Source/tasks.c **** 				if( xYieldRequired != pdFALSE )
 1208              		.loc 1 1682 0
 1209 0596 7B69     		ldr	r3, [r7, #20]
 1210 0598 002B     		cmp	r3, #0
 1211 059a 07D0     		beq	.L71
1683:FreeRTOS/Source/tasks.c **** 				{
1684:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 1212              		.loc 1 1684 0
 1213 059c 094B     		ldr	r3, .L77+12
 1214 059e 4FF08052 		mov	r2, #268435456
 1215 05a2 1A60     		str	r2, [r3]
 1216              		.syntax unified
 1217              	@ 1684 "FreeRTOS/Source/tasks.c" 1
 1218 05a4 BFF34F8F 		dsb
 1219              	@ 0 "" 2
 1220              	@ 1684 "FreeRTOS/Source/tasks.c" 1
 1221 05a8 BFF36F8F 		isb
 1222              	@ 0 "" 2
 1223              		.thumb
 1224              		.syntax unified
 1225              	.L71:
1685:FreeRTOS/Source/tasks.c **** 				}
1686:FreeRTOS/Source/tasks.c **** 				else
1687:FreeRTOS/Source/tasks.c **** 				{
1688:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1689:FreeRTOS/Source/tasks.c **** 				}
1690:FreeRTOS/Source/tasks.c **** 
1691:FreeRTOS/Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1692:FreeRTOS/Source/tasks.c **** 				optimised task selection is not being used. */
1693:FreeRTOS/Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1694:FreeRTOS/Source/tasks.c **** 			}
1695:FreeRTOS/Source/tasks.c **** 		}
1696:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 1226              		.loc 1 1696 0
 1227 05ac FFF7FEFF 		bl	vPortExitCritical
1697:FreeRTOS/Source/tasks.c **** 	}
 1228              		.loc 1 1697 0
 1229 05b0 00BF     		nop
 1230 05b2 1837     		adds	r7, r7, #24
 1231              		.cfi_def_cfa_offset 8
 1232 05b4 BD46     		mov	sp, r7
 1233              		.cfi_def_cfa_register 13
 1234              		@ sp needed
 1235 05b6 80BD     		pop	{r7, pc}
 1236              	.L78:
 1237              		.align	2
 1238              	.L77:
ARM GAS  /tmp/cckqXCjj.s 			page 57


 1239 05b8 00000000 		.word	pxCurrentTCB
 1240 05bc 04000000 		.word	pxReadyTasksLists
 1241 05c0 E0000000 		.word	uxTopReadyPriority
 1242 05c4 04ED00E0 		.word	-536810236
 1243              		.cfi_endproc
 1244              	.LFE13:
 1245              		.size	vTaskPrioritySet, .-vTaskPrioritySet
 1246              		.align	1
 1247              		.global	vTaskSuspend
 1248              		.syntax unified
 1249              		.thumb
 1250              		.thumb_func
 1251              		.fpu softvfp
 1252              		.type	vTaskSuspend, %function
 1253              	vTaskSuspend:
 1254              	.LFB14:
1698:FreeRTOS/Source/tasks.c **** 
1699:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1700:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1701:FreeRTOS/Source/tasks.c **** 
1702:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1703:FreeRTOS/Source/tasks.c **** 
1704:FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1705:FreeRTOS/Source/tasks.c **** 	{
 1255              		.loc 1 1705 0
 1256              		.cfi_startproc
 1257              		@ args = 0, pretend = 0, frame = 16
 1258              		@ frame_needed = 1, uses_anonymous_args = 0
 1259 05c8 80B5     		push	{r7, lr}
 1260              		.cfi_def_cfa_offset 8
 1261              		.cfi_offset 7, -8
 1262              		.cfi_offset 14, -4
 1263 05ca 84B0     		sub	sp, sp, #16
 1264              		.cfi_def_cfa_offset 24
 1265 05cc 00AF     		add	r7, sp, #0
 1266              		.cfi_def_cfa_register 7
 1267 05ce 7860     		str	r0, [r7, #4]
1706:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
1707:FreeRTOS/Source/tasks.c **** 
1708:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 1268              		.loc 1 1708 0
 1269 05d0 FFF7FEFF 		bl	vPortEnterCritical
1709:FreeRTOS/Source/tasks.c **** 		{
1710:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1711:FreeRTOS/Source/tasks.c **** 			being suspended. */
1712:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1270              		.loc 1 1712 0
 1271 05d4 7B68     		ldr	r3, [r7, #4]
 1272 05d6 002B     		cmp	r3, #0
 1273 05d8 02D1     		bne	.L80
 1274              		.loc 1 1712 0 is_stmt 0 discriminator 1
 1275 05da 354B     		ldr	r3, .L92
 1276 05dc 1B68     		ldr	r3, [r3]
 1277 05de 00E0     		b	.L81
 1278              	.L80:
 1279              		.loc 1 1712 0 discriminator 2
 1280 05e0 7B68     		ldr	r3, [r7, #4]
ARM GAS  /tmp/cckqXCjj.s 			page 58


 1281              	.L81:
 1282              		.loc 1 1712 0 discriminator 4
 1283 05e2 FB60     		str	r3, [r7, #12]
1713:FreeRTOS/Source/tasks.c **** 
1714:FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1715:FreeRTOS/Source/tasks.c **** 
1716:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1717:FreeRTOS/Source/tasks.c **** 			suspended list. */
1718:FreeRTOS/Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1284              		.loc 1 1718 0 is_stmt 1 discriminator 4
 1285 05e4 FB68     		ldr	r3, [r7, #12]
 1286 05e6 0433     		adds	r3, r3, #4
 1287 05e8 1846     		mov	r0, r3
 1288 05ea FFF7FEFF 		bl	uxListRemove
 1289 05ee 0346     		mov	r3, r0
 1290 05f0 002B     		cmp	r3, #0
 1291 05f2 15D1     		bne	.L82
1719:FreeRTOS/Source/tasks.c **** 			{
1720:FreeRTOS/Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 1292              		.loc 1 1720 0
 1293 05f4 FB68     		ldr	r3, [r7, #12]
 1294 05f6 DA6A     		ldr	r2, [r3, #44]
 1295 05f8 2E49     		ldr	r1, .L92+4
 1296 05fa 1346     		mov	r3, r2
 1297 05fc 9B00     		lsls	r3, r3, #2
 1298 05fe 1344     		add	r3, r3, r2
 1299 0600 9B00     		lsls	r3, r3, #2
 1300 0602 0B44     		add	r3, r3, r1
 1301 0604 1B68     		ldr	r3, [r3]
 1302 0606 002B     		cmp	r3, #0
 1303 0608 0AD1     		bne	.L82
 1304              		.loc 1 1720 0 is_stmt 0 discriminator 1
 1305 060a FB68     		ldr	r3, [r7, #12]
 1306 060c DB6A     		ldr	r3, [r3, #44]
 1307 060e 0122     		movs	r2, #1
 1308 0610 02FA03F3 		lsl	r3, r2, r3
 1309 0614 DA43     		mvns	r2, r3
 1310 0616 284B     		ldr	r3, .L92+8
 1311 0618 1B68     		ldr	r3, [r3]
 1312 061a 1340     		ands	r3, r3, r2
 1313 061c 264A     		ldr	r2, .L92+8
 1314 061e 1360     		str	r3, [r2]
 1315              	.L82:
1721:FreeRTOS/Source/tasks.c **** 			}
1722:FreeRTOS/Source/tasks.c **** 			else
1723:FreeRTOS/Source/tasks.c **** 			{
1724:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1725:FreeRTOS/Source/tasks.c **** 			}
1726:FreeRTOS/Source/tasks.c **** 
1727:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
1728:FreeRTOS/Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1316              		.loc 1 1728 0 is_stmt 1
 1317 0620 FB68     		ldr	r3, [r7, #12]
 1318 0622 9B6A     		ldr	r3, [r3, #40]
 1319 0624 002B     		cmp	r3, #0
 1320 0626 04D0     		beq	.L84
1729:FreeRTOS/Source/tasks.c **** 			{
ARM GAS  /tmp/cckqXCjj.s 			page 59


1730:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1321              		.loc 1 1730 0
 1322 0628 FB68     		ldr	r3, [r7, #12]
 1323 062a 1833     		adds	r3, r3, #24
 1324 062c 1846     		mov	r0, r3
 1325 062e FFF7FEFF 		bl	uxListRemove
 1326              	.L84:
1731:FreeRTOS/Source/tasks.c **** 			}
1732:FreeRTOS/Source/tasks.c **** 			else
1733:FreeRTOS/Source/tasks.c **** 			{
1734:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1735:FreeRTOS/Source/tasks.c **** 			}
1736:FreeRTOS/Source/tasks.c **** 
1737:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 1327              		.loc 1 1737 0
 1328 0632 FB68     		ldr	r3, [r7, #12]
 1329 0634 0433     		adds	r3, r3, #4
 1330 0636 1946     		mov	r1, r3
 1331 0638 2048     		ldr	r0, .L92+12
 1332 063a FFF7FEFF 		bl	vListInsertEnd
1738:FreeRTOS/Source/tasks.c **** 
1739:FreeRTOS/Source/tasks.c **** 			#if( configUSE_TASK_NOTIFICATIONS == 1 )
1740:FreeRTOS/Source/tasks.c **** 			{
1741:FreeRTOS/Source/tasks.c **** 				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 1333              		.loc 1 1741 0
 1334 063e FB68     		ldr	r3, [r7, #12]
 1335 0640 93F84830 		ldrb	r3, [r3, #72]
 1336 0644 DBB2     		uxtb	r3, r3
 1337 0646 012B     		cmp	r3, #1
 1338 0648 03D1     		bne	.L85
1742:FreeRTOS/Source/tasks.c **** 				{
1743:FreeRTOS/Source/tasks.c **** 					/* The task was blocked to wait for a notification, but is
1744:FreeRTOS/Source/tasks.c **** 					now suspended, so no notification was received. */
1745:FreeRTOS/Source/tasks.c **** 					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1339              		.loc 1 1745 0
 1340 064a FB68     		ldr	r3, [r7, #12]
 1341 064c 0022     		movs	r2, #0
 1342 064e 83F84820 		strb	r2, [r3, #72]
 1343              	.L85:
1746:FreeRTOS/Source/tasks.c **** 				}
1747:FreeRTOS/Source/tasks.c **** 			}
1748:FreeRTOS/Source/tasks.c **** 			#endif
1749:FreeRTOS/Source/tasks.c **** 		}
1750:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 1344              		.loc 1 1750 0
 1345 0652 FFF7FEFF 		bl	vPortExitCritical
1751:FreeRTOS/Source/tasks.c **** 
1752:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 1346              		.loc 1 1752 0
 1347 0656 1A4B     		ldr	r3, .L92+16
 1348 0658 1B68     		ldr	r3, [r3]
 1349 065a 002B     		cmp	r3, #0
 1350 065c 05D0     		beq	.L86
1753:FreeRTOS/Source/tasks.c **** 		{
1754:FreeRTOS/Source/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1755:FreeRTOS/Source/tasks.c **** 			task that is now in the Suspended state. */
1756:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
ARM GAS  /tmp/cckqXCjj.s 			page 60


 1351              		.loc 1 1756 0
 1352 065e FFF7FEFF 		bl	vPortEnterCritical
1757:FreeRTOS/Source/tasks.c **** 			{
1758:FreeRTOS/Source/tasks.c **** 				prvResetNextTaskUnblockTime();
 1353              		.loc 1 1758 0
 1354 0662 00F011FD 		bl	prvResetNextTaskUnblockTime
1759:FreeRTOS/Source/tasks.c **** 			}
1760:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 1355              		.loc 1 1760 0
 1356 0666 FFF7FEFF 		bl	vPortExitCritical
 1357              	.L86:
1761:FreeRTOS/Source/tasks.c **** 		}
1762:FreeRTOS/Source/tasks.c **** 		else
1763:FreeRTOS/Source/tasks.c **** 		{
1764:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1765:FreeRTOS/Source/tasks.c **** 		}
1766:FreeRTOS/Source/tasks.c **** 
1767:FreeRTOS/Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 1358              		.loc 1 1767 0
 1359 066a 114B     		ldr	r3, .L92
 1360 066c 1B68     		ldr	r3, [r3]
 1361 066e FA68     		ldr	r2, [r7, #12]
 1362 0670 9A42     		cmp	r2, r3
 1363 0672 18D1     		bne	.L91
1768:FreeRTOS/Source/tasks.c **** 		{
1769:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1364              		.loc 1 1769 0
 1365 0674 124B     		ldr	r3, .L92+16
 1366 0676 1B68     		ldr	r3, [r3]
 1367 0678 002B     		cmp	r3, #0
 1368 067a 08D0     		beq	.L88
1770:FreeRTOS/Source/tasks.c **** 			{
1771:FreeRTOS/Source/tasks.c **** 				/* The current task has just been suspended. */
1772:FreeRTOS/Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1773:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 1369              		.loc 1 1773 0
 1370 067c 114B     		ldr	r3, .L92+20
 1371 067e 4FF08052 		mov	r2, #268435456
 1372 0682 1A60     		str	r2, [r3]
 1373              		.syntax unified
 1374              	@ 1773 "FreeRTOS/Source/tasks.c" 1
 1375 0684 BFF34F8F 		dsb
 1376              	@ 0 "" 2
 1377              	@ 1773 "FreeRTOS/Source/tasks.c" 1
 1378 0688 BFF36F8F 		isb
 1379              	@ 0 "" 2
1774:FreeRTOS/Source/tasks.c **** 			}
1775:FreeRTOS/Source/tasks.c **** 			else
1776:FreeRTOS/Source/tasks.c **** 			{
1777:FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1778:FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1779:FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
1780:FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Rig
1781:FreeRTOS/Source/tasks.c **** 				{
1782:FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1783:FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1784:FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
ARM GAS  /tmp/cckqXCjj.s 			page 61


1785:FreeRTOS/Source/tasks.c **** 					is. */
1786:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
1787:FreeRTOS/Source/tasks.c **** 				}
1788:FreeRTOS/Source/tasks.c **** 				else
1789:FreeRTOS/Source/tasks.c **** 				{
1790:FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
1791:FreeRTOS/Source/tasks.c **** 				}
1792:FreeRTOS/Source/tasks.c **** 			}
1793:FreeRTOS/Source/tasks.c **** 		}
1794:FreeRTOS/Source/tasks.c **** 		else
1795:FreeRTOS/Source/tasks.c **** 		{
1796:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1797:FreeRTOS/Source/tasks.c **** 		}
1798:FreeRTOS/Source/tasks.c **** 	}
 1380              		.loc 1 1798 0
 1381              		.thumb
 1382              		.syntax unified
 1383 068c 0BE0     		b	.L91
 1384              	.L88:
1780:FreeRTOS/Source/tasks.c **** 				{
 1385              		.loc 1 1780 0
 1386 068e 0B4B     		ldr	r3, .L92+12
 1387 0690 1A68     		ldr	r2, [r3]
 1388 0692 0D4B     		ldr	r3, .L92+24
 1389 0694 1B68     		ldr	r3, [r3]
 1390 0696 9A42     		cmp	r2, r3
 1391 0698 03D1     		bne	.L90
1786:FreeRTOS/Source/tasks.c **** 				}
 1392              		.loc 1 1786 0
 1393 069a 054B     		ldr	r3, .L92
 1394 069c 0022     		movs	r2, #0
 1395 069e 1A60     		str	r2, [r3]
 1396              		.loc 1 1798 0
 1397 06a0 01E0     		b	.L91
 1398              	.L90:
1790:FreeRTOS/Source/tasks.c **** 				}
 1399              		.loc 1 1790 0
 1400 06a2 FFF7FEFF 		bl	vTaskSwitchContext
 1401              	.L91:
 1402              		.loc 1 1798 0
 1403 06a6 00BF     		nop
 1404 06a8 1037     		adds	r7, r7, #16
 1405              		.cfi_def_cfa_offset 8
 1406 06aa BD46     		mov	sp, r7
 1407              		.cfi_def_cfa_register 13
 1408              		@ sp needed
 1409 06ac 80BD     		pop	{r7, pc}
 1410              	.L93:
 1411 06ae 00BF     		.align	2
 1412              	.L92:
 1413 06b0 00000000 		.word	pxCurrentTCB
 1414 06b4 04000000 		.word	pxReadyTasksLists
 1415 06b8 E0000000 		.word	uxTopReadyPriority
 1416 06bc C4000000 		.word	xSuspendedTaskList
 1417 06c0 E4000000 		.word	xSchedulerRunning
 1418 06c4 04ED00E0 		.word	-536810236
 1419 06c8 D8000000 		.word	uxCurrentNumberOfTasks
ARM GAS  /tmp/cckqXCjj.s 			page 62


 1420              		.cfi_endproc
 1421              	.LFE14:
 1422              		.size	vTaskSuspend, .-vTaskSuspend
 1423              		.align	1
 1424              		.syntax unified
 1425              		.thumb
 1426              		.thumb_func
 1427              		.fpu softvfp
 1428              		.type	prvTaskIsTaskSuspended, %function
 1429              	prvTaskIsTaskSuspended:
 1430              	.LFB15:
1799:FreeRTOS/Source/tasks.c **** 
1800:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1801:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1802:FreeRTOS/Source/tasks.c **** 
1803:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1804:FreeRTOS/Source/tasks.c **** 
1805:FreeRTOS/Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1806:FreeRTOS/Source/tasks.c **** 	{
 1431              		.loc 1 1806 0
 1432              		.cfi_startproc
 1433              		@ args = 0, pretend = 0, frame = 16
 1434              		@ frame_needed = 1, uses_anonymous_args = 0
 1435              		@ link register save eliminated.
 1436 06cc 80B4     		push	{r7}
 1437              		.cfi_def_cfa_offset 4
 1438              		.cfi_offset 7, -4
 1439 06ce 85B0     		sub	sp, sp, #20
 1440              		.cfi_def_cfa_offset 24
 1441 06d0 00AF     		add	r7, sp, #0
 1442              		.cfi_def_cfa_register 7
 1443 06d2 7860     		str	r0, [r7, #4]
1807:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 1444              		.loc 1 1807 0
 1445 06d4 0023     		movs	r3, #0
 1446 06d6 FB60     		str	r3, [r7, #12]
1808:FreeRTOS/Source/tasks.c **** 	const TCB_t * const pxTCB = xTask;
 1447              		.loc 1 1808 0
 1448 06d8 7B68     		ldr	r3, [r7, #4]
 1449 06da BB60     		str	r3, [r7, #8]
1809:FreeRTOS/Source/tasks.c **** 
1810:FreeRTOS/Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1811:FreeRTOS/Source/tasks.c **** 		section. */
1812:FreeRTOS/Source/tasks.c **** 
1813:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1814:FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
1815:FreeRTOS/Source/tasks.c **** 
1816:FreeRTOS/Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1817:FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 1450              		.loc 1 1817 0
 1451 06dc BB68     		ldr	r3, [r7, #8]
 1452 06de 5B69     		ldr	r3, [r3, #20]
 1453 06e0 094A     		ldr	r2, .L97
 1454 06e2 9342     		cmp	r3, r2
 1455 06e4 0AD1     		bne	.L95
1818:FreeRTOS/Source/tasks.c **** 		{
1819:FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
ARM GAS  /tmp/cckqXCjj.s 			page 63


1820:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 1456              		.loc 1 1820 0
 1457 06e6 BB68     		ldr	r3, [r7, #8]
 1458 06e8 9B6A     		ldr	r3, [r3, #40]
 1459 06ea 084A     		ldr	r2, .L97+4
 1460 06ec 9342     		cmp	r3, r2
 1461 06ee 05D0     		beq	.L95
1821:FreeRTOS/Source/tasks.c **** 			{
1822:FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1823:FreeRTOS/Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1824:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The
 1462              		.loc 1 1824 0
 1463 06f0 BB68     		ldr	r3, [r7, #8]
 1464 06f2 9B6A     		ldr	r3, [r3, #40]
 1465 06f4 002B     		cmp	r3, #0
 1466 06f6 01D1     		bne	.L95
1825:FreeRTOS/Source/tasks.c **** 				{
1826:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
 1467              		.loc 1 1826 0
 1468 06f8 0123     		movs	r3, #1
 1469 06fa FB60     		str	r3, [r7, #12]
 1470              	.L95:
1827:FreeRTOS/Source/tasks.c **** 				}
1828:FreeRTOS/Source/tasks.c **** 				else
1829:FreeRTOS/Source/tasks.c **** 				{
1830:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1831:FreeRTOS/Source/tasks.c **** 				}
1832:FreeRTOS/Source/tasks.c **** 			}
1833:FreeRTOS/Source/tasks.c **** 			else
1834:FreeRTOS/Source/tasks.c **** 			{
1835:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1836:FreeRTOS/Source/tasks.c **** 			}
1837:FreeRTOS/Source/tasks.c **** 		}
1838:FreeRTOS/Source/tasks.c **** 		else
1839:FreeRTOS/Source/tasks.c **** 		{
1840:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1841:FreeRTOS/Source/tasks.c **** 		}
1842:FreeRTOS/Source/tasks.c **** 
1843:FreeRTOS/Source/tasks.c **** 		return xReturn;
 1471              		.loc 1 1843 0
 1472 06fc FB68     		ldr	r3, [r7, #12]
1844:FreeRTOS/Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1473              		.loc 1 1844 0
 1474 06fe 1846     		mov	r0, r3
 1475 0700 1437     		adds	r7, r7, #20
 1476              		.cfi_def_cfa_offset 4
 1477 0702 BD46     		mov	sp, r7
 1478              		.cfi_def_cfa_register 13
 1479              		@ sp needed
 1480 0704 80BC     		pop	{r7}
 1481              		.cfi_restore 7
 1482              		.cfi_def_cfa_offset 0
 1483 0706 7047     		bx	lr
 1484              	.L98:
 1485              		.align	2
 1486              	.L97:
 1487 0708 C4000000 		.word	xSuspendedTaskList
ARM GAS  /tmp/cckqXCjj.s 			page 64


 1488 070c 98000000 		.word	xPendingReadyList
 1489              		.cfi_endproc
 1490              	.LFE15:
 1491              		.size	prvTaskIsTaskSuspended, .-prvTaskIsTaskSuspended
 1492              		.align	1
 1493              		.global	vTaskResume
 1494              		.syntax unified
 1495              		.thumb
 1496              		.thumb_func
 1497              		.fpu softvfp
 1498              		.type	vTaskResume, %function
 1499              	vTaskResume:
 1500              	.LFB16:
1845:FreeRTOS/Source/tasks.c **** 
1846:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1847:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1848:FreeRTOS/Source/tasks.c **** 
1849:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1850:FreeRTOS/Source/tasks.c **** 
1851:FreeRTOS/Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1852:FreeRTOS/Source/tasks.c **** 	{
 1501              		.loc 1 1852 0
 1502              		.cfi_startproc
 1503              		@ args = 0, pretend = 0, frame = 16
 1504              		@ frame_needed = 1, uses_anonymous_args = 0
 1505 0710 80B5     		push	{r7, lr}
 1506              		.cfi_def_cfa_offset 8
 1507              		.cfi_offset 7, -8
 1508              		.cfi_offset 14, -4
 1509 0712 84B0     		sub	sp, sp, #16
 1510              		.cfi_def_cfa_offset 24
 1511 0714 00AF     		add	r7, sp, #0
 1512              		.cfi_def_cfa_register 7
 1513 0716 7860     		str	r0, [r7, #4]
1853:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1514              		.loc 1 1853 0
 1515 0718 7B68     		ldr	r3, [r7, #4]
 1516 071a FB60     		str	r3, [r7, #12]
1854:FreeRTOS/Source/tasks.c **** 
1855:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1856:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1857:FreeRTOS/Source/tasks.c **** 
1858:FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1859:FreeRTOS/Source/tasks.c **** 		currently executing task. */
1860:FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 1517              		.loc 1 1860 0
 1518 071c 204B     		ldr	r3, .L103
 1519 071e 1B68     		ldr	r3, [r3]
 1520 0720 FA68     		ldr	r2, [r7, #12]
 1521 0722 9A42     		cmp	r2, r3
 1522 0724 37D0     		beq	.L102
 1523              		.loc 1 1860 0 is_stmt 0 discriminator 1
 1524 0726 FB68     		ldr	r3, [r7, #12]
 1525 0728 002B     		cmp	r3, #0
 1526 072a 34D0     		beq	.L102
1861:FreeRTOS/Source/tasks.c **** 		{
1862:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
ARM GAS  /tmp/cckqXCjj.s 			page 65


 1527              		.loc 1 1862 0 is_stmt 1
 1528 072c FFF7FEFF 		bl	vPortEnterCritical
1863:FreeRTOS/Source/tasks.c **** 			{
1864:FreeRTOS/Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1529              		.loc 1 1864 0
 1530 0730 F868     		ldr	r0, [r7, #12]
 1531 0732 FFF7CBFF 		bl	prvTaskIsTaskSuspended
 1532 0736 0346     		mov	r3, r0
 1533 0738 002B     		cmp	r3, #0
 1534 073a 2AD0     		beq	.L101
1865:FreeRTOS/Source/tasks.c **** 				{
1866:FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1867:FreeRTOS/Source/tasks.c **** 
1868:FreeRTOS/Source/tasks.c **** 					/* The ready list can be accessed even if the scheduler is
1869:FreeRTOS/Source/tasks.c **** 					suspended because this is inside a critical section. */
1870:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 1535              		.loc 1 1870 0
 1536 073c FB68     		ldr	r3, [r7, #12]
 1537 073e 0433     		adds	r3, r3, #4
 1538 0740 1846     		mov	r0, r3
 1539 0742 FFF7FEFF 		bl	uxListRemove
1871:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1540              		.loc 1 1871 0
 1541 0746 FB68     		ldr	r3, [r7, #12]
 1542 0748 DB6A     		ldr	r3, [r3, #44]
 1543 074a 0122     		movs	r2, #1
 1544 074c 9A40     		lsls	r2, r2, r3
 1545 074e 154B     		ldr	r3, .L103+4
 1546 0750 1B68     		ldr	r3, [r3]
 1547 0752 1343     		orrs	r3, r3, r2
 1548 0754 134A     		ldr	r2, .L103+4
 1549 0756 1360     		str	r3, [r2]
 1550 0758 FB68     		ldr	r3, [r7, #12]
 1551 075a DA6A     		ldr	r2, [r3, #44]
 1552 075c 1346     		mov	r3, r2
 1553 075e 9B00     		lsls	r3, r3, #2
 1554 0760 1344     		add	r3, r3, r2
 1555 0762 9B00     		lsls	r3, r3, #2
 1556 0764 104A     		ldr	r2, .L103+8
 1557 0766 1A44     		add	r2, r2, r3
 1558 0768 FB68     		ldr	r3, [r7, #12]
 1559 076a 0433     		adds	r3, r3, #4
 1560 076c 1946     		mov	r1, r3
 1561 076e 1046     		mov	r0, r2
 1562 0770 FFF7FEFF 		bl	vListInsertEnd
1872:FreeRTOS/Source/tasks.c **** 
1873:FreeRTOS/Source/tasks.c **** 					/* A higher priority task may have just been resumed. */
1874:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1563              		.loc 1 1874 0
 1564 0774 FB68     		ldr	r3, [r7, #12]
 1565 0776 DA6A     		ldr	r2, [r3, #44]
 1566 0778 094B     		ldr	r3, .L103
 1567 077a 1B68     		ldr	r3, [r3]
 1568 077c DB6A     		ldr	r3, [r3, #44]
 1569 077e 9A42     		cmp	r2, r3
 1570 0780 07D3     		bcc	.L101
1875:FreeRTOS/Source/tasks.c **** 					{
ARM GAS  /tmp/cckqXCjj.s 			page 66


1876:FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1877:FreeRTOS/Source/tasks.c **** 						but will leave the lists in the correct state for the
1878:FreeRTOS/Source/tasks.c **** 						next yield. */
1879:FreeRTOS/Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
 1571              		.loc 1 1879 0
 1572 0782 0A4B     		ldr	r3, .L103+12
 1573 0784 4FF08052 		mov	r2, #268435456
 1574 0788 1A60     		str	r2, [r3]
 1575              		.syntax unified
 1576              	@ 1879 "FreeRTOS/Source/tasks.c" 1
 1577 078a BFF34F8F 		dsb
 1578              	@ 0 "" 2
 1579              	@ 1879 "FreeRTOS/Source/tasks.c" 1
 1580 078e BFF36F8F 		isb
 1581              	@ 0 "" 2
 1582              		.thumb
 1583              		.syntax unified
 1584              	.L101:
1880:FreeRTOS/Source/tasks.c **** 					}
1881:FreeRTOS/Source/tasks.c **** 					else
1882:FreeRTOS/Source/tasks.c **** 					{
1883:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1884:FreeRTOS/Source/tasks.c **** 					}
1885:FreeRTOS/Source/tasks.c **** 				}
1886:FreeRTOS/Source/tasks.c **** 				else
1887:FreeRTOS/Source/tasks.c **** 				{
1888:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1889:FreeRTOS/Source/tasks.c **** 				}
1890:FreeRTOS/Source/tasks.c **** 			}
1891:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 1585              		.loc 1 1891 0
 1586 0792 FFF7FEFF 		bl	vPortExitCritical
 1587              	.L102:
1892:FreeRTOS/Source/tasks.c **** 		}
1893:FreeRTOS/Source/tasks.c **** 		else
1894:FreeRTOS/Source/tasks.c **** 		{
1895:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1896:FreeRTOS/Source/tasks.c **** 		}
1897:FreeRTOS/Source/tasks.c **** 	}
 1588              		.loc 1 1897 0
 1589 0796 00BF     		nop
 1590 0798 1037     		adds	r7, r7, #16
 1591              		.cfi_def_cfa_offset 8
 1592 079a BD46     		mov	sp, r7
 1593              		.cfi_def_cfa_register 13
 1594              		@ sp needed
 1595 079c 80BD     		pop	{r7, pc}
 1596              	.L104:
 1597 079e 00BF     		.align	2
 1598              	.L103:
 1599 07a0 00000000 		.word	pxCurrentTCB
 1600 07a4 E0000000 		.word	uxTopReadyPriority
 1601 07a8 04000000 		.word	pxReadyTasksLists
 1602 07ac 04ED00E0 		.word	-536810236
 1603              		.cfi_endproc
 1604              	.LFE16:
 1605              		.size	vTaskResume, .-vTaskResume
ARM GAS  /tmp/cckqXCjj.s 			page 67


 1606              		.align	1
 1607              		.global	xTaskResumeFromISR
 1608              		.syntax unified
 1609              		.thumb
 1610              		.thumb_func
 1611              		.fpu softvfp
 1612              		.type	xTaskResumeFromISR, %function
 1613              	xTaskResumeFromISR:
 1614              	.LFB17:
1898:FreeRTOS/Source/tasks.c **** 
1899:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1900:FreeRTOS/Source/tasks.c **** 
1901:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1902:FreeRTOS/Source/tasks.c **** 
1903:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1904:FreeRTOS/Source/tasks.c **** 
1905:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1906:FreeRTOS/Source/tasks.c **** 	{
 1615              		.loc 1 1906 0
 1616              		.cfi_startproc
 1617              		@ args = 0, pretend = 0, frame = 32
 1618              		@ frame_needed = 1, uses_anonymous_args = 0
 1619 07b0 80B5     		push	{r7, lr}
 1620              		.cfi_def_cfa_offset 8
 1621              		.cfi_offset 7, -8
 1622              		.cfi_offset 14, -4
 1623 07b2 88B0     		sub	sp, sp, #32
 1624              		.cfi_def_cfa_offset 40
 1625 07b4 00AF     		add	r7, sp, #0
 1626              		.cfi_def_cfa_register 7
 1627 07b6 7860     		str	r0, [r7, #4]
1907:FreeRTOS/Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1628              		.loc 1 1907 0
 1629 07b8 0023     		movs	r3, #0
 1630 07ba FB61     		str	r3, [r7, #28]
1908:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = xTaskToResume;
 1631              		.loc 1 1908 0
 1632 07bc 7B68     		ldr	r3, [r7, #4]
 1633 07be BB61     		str	r3, [r7, #24]
 1634              	.LBB32:
 1635              	.LBB33:
 213:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 1636              		.loc 2 213 0
 1637              		.syntax unified
 1638              	@ 213 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1639 07c0 EFF31182 			mrs r2, basepri											
 1640 07c4 4FF0BF03 		mov r3, #191												
 1641 07c8 83F31188 		msr basepri, r3											
 1642 07cc BFF36F8F 		isb														
 1643 07d0 BFF34F8F 		dsb														
 1644              	
 1645              	@ 0 "" 2
 1646              		.thumb
 1647              		.syntax unified
 1648 07d4 3A61     		str	r2, [r7, #16]
 1649 07d6 FB60     		str	r3, [r7, #12]
 225:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
ARM GAS  /tmp/cckqXCjj.s 			page 68


 1650              		.loc 2 225 0
 1651 07d8 3B69     		ldr	r3, [r7, #16]
 1652              	.LBE33:
 1653              	.LBE32:
1909:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1910:FreeRTOS/Source/tasks.c **** 
1911:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToResume );
1912:FreeRTOS/Source/tasks.c **** 
1913:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1914:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1915:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1916:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1917:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1918:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1919:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1920:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1921:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1922:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1923:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1924:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1925:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1926:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1927:FreeRTOS/Source/tasks.c **** 		provided on the following link:
1928:FreeRTOS/Source/tasks.c **** 		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
1929:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1930:FreeRTOS/Source/tasks.c **** 
1931:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1654              		.loc 1 1931 0
 1655 07da 7B61     		str	r3, [r7, #20]
1932:FreeRTOS/Source/tasks.c **** 		{
1933:FreeRTOS/Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1656              		.loc 1 1933 0
 1657 07dc B869     		ldr	r0, [r7, #24]
 1658 07de FFF775FF 		bl	prvTaskIsTaskSuspended
 1659 07e2 0346     		mov	r3, r0
 1660 07e4 002B     		cmp	r3, #0
 1661 07e6 2FD0     		beq	.L107
1934:FreeRTOS/Source/tasks.c **** 			{
1935:FreeRTOS/Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1936:FreeRTOS/Source/tasks.c **** 
1937:FreeRTOS/Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1938:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1662              		.loc 1 1938 0
 1663 07e8 1C4B     		ldr	r3, .L112
 1664 07ea 1B68     		ldr	r3, [r3]
 1665 07ec 002B     		cmp	r3, #0
 1666 07ee 25D1     		bne	.L108
1939:FreeRTOS/Source/tasks.c **** 				{
1940:FreeRTOS/Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1941:FreeRTOS/Source/tasks.c **** 					suspended list to the ready list directly. */
1942:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1667              		.loc 1 1942 0
 1668 07f0 BB69     		ldr	r3, [r7, #24]
 1669 07f2 DA6A     		ldr	r2, [r3, #44]
 1670 07f4 1A4B     		ldr	r3, .L112+4
 1671 07f6 1B68     		ldr	r3, [r3]
 1672 07f8 DB6A     		ldr	r3, [r3, #44]
ARM GAS  /tmp/cckqXCjj.s 			page 69


 1673 07fa 9A42     		cmp	r2, r3
 1674 07fc 01D3     		bcc	.L109
1943:FreeRTOS/Source/tasks.c **** 					{
1944:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1675              		.loc 1 1944 0
 1676 07fe 0123     		movs	r3, #1
 1677 0800 FB61     		str	r3, [r7, #28]
 1678              	.L109:
1945:FreeRTOS/Source/tasks.c **** 					}
1946:FreeRTOS/Source/tasks.c **** 					else
1947:FreeRTOS/Source/tasks.c **** 					{
1948:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1949:FreeRTOS/Source/tasks.c **** 					}
1950:FreeRTOS/Source/tasks.c **** 
1951:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1679              		.loc 1 1951 0
 1680 0802 BB69     		ldr	r3, [r7, #24]
 1681 0804 0433     		adds	r3, r3, #4
 1682 0806 1846     		mov	r0, r3
 1683 0808 FFF7FEFF 		bl	uxListRemove
1952:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1684              		.loc 1 1952 0
 1685 080c BB69     		ldr	r3, [r7, #24]
 1686 080e DB6A     		ldr	r3, [r3, #44]
 1687 0810 0122     		movs	r2, #1
 1688 0812 9A40     		lsls	r2, r2, r3
 1689 0814 134B     		ldr	r3, .L112+8
 1690 0816 1B68     		ldr	r3, [r3]
 1691 0818 1343     		orrs	r3, r3, r2
 1692 081a 124A     		ldr	r2, .L112+8
 1693 081c 1360     		str	r3, [r2]
 1694 081e BB69     		ldr	r3, [r7, #24]
 1695 0820 DA6A     		ldr	r2, [r3, #44]
 1696 0822 1346     		mov	r3, r2
 1697 0824 9B00     		lsls	r3, r3, #2
 1698 0826 1344     		add	r3, r3, r2
 1699 0828 9B00     		lsls	r3, r3, #2
 1700 082a 0F4A     		ldr	r2, .L112+12
 1701 082c 1A44     		add	r2, r2, r3
 1702 082e BB69     		ldr	r3, [r7, #24]
 1703 0830 0433     		adds	r3, r3, #4
 1704 0832 1946     		mov	r1, r3
 1705 0834 1046     		mov	r0, r2
 1706 0836 FFF7FEFF 		bl	vListInsertEnd
 1707 083a 05E0     		b	.L107
 1708              	.L108:
1953:FreeRTOS/Source/tasks.c **** 				}
1954:FreeRTOS/Source/tasks.c **** 				else
1955:FreeRTOS/Source/tasks.c **** 				{
1956:FreeRTOS/Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1957:FreeRTOS/Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1958:FreeRTOS/Source/tasks.c **** 					unsuspended. */
1959:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1709              		.loc 1 1959 0
 1710 083c BB69     		ldr	r3, [r7, #24]
 1711 083e 1833     		adds	r3, r3, #24
 1712 0840 1946     		mov	r1, r3
ARM GAS  /tmp/cckqXCjj.s 			page 70


 1713 0842 0A48     		ldr	r0, .L112+16
 1714 0844 FFF7FEFF 		bl	vListInsertEnd
 1715              	.L107:
 1716 0848 7B69     		ldr	r3, [r7, #20]
 1717 084a BB60     		str	r3, [r7, #8]
 1718              	.LBB34:
 1719              	.LBB35:
 1720              		.loc 2 231 0
 1721 084c BB68     		ldr	r3, [r7, #8]
 1722              		.syntax unified
 1723              	@ 231 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1724 084e 83F31188 			msr basepri, r3	
 1725              	@ 0 "" 2
 1726              		.thumb
 1727              		.syntax unified
 1728              	.LBE35:
 1729              	.LBE34:
1960:FreeRTOS/Source/tasks.c **** 				}
1961:FreeRTOS/Source/tasks.c **** 			}
1962:FreeRTOS/Source/tasks.c **** 			else
1963:FreeRTOS/Source/tasks.c **** 			{
1964:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1965:FreeRTOS/Source/tasks.c **** 			}
1966:FreeRTOS/Source/tasks.c **** 		}
1967:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1968:FreeRTOS/Source/tasks.c **** 
1969:FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
 1730              		.loc 1 1969 0
 1731 0852 FB69     		ldr	r3, [r7, #28]
1970:FreeRTOS/Source/tasks.c **** 	}
 1732              		.loc 1 1970 0
 1733 0854 1846     		mov	r0, r3
 1734 0856 2037     		adds	r7, r7, #32
 1735              		.cfi_def_cfa_offset 8
 1736 0858 BD46     		mov	sp, r7
 1737              		.cfi_def_cfa_register 13
 1738              		@ sp needed
 1739 085a 80BD     		pop	{r7, pc}
 1740              	.L113:
 1741              		.align	2
 1742              	.L112:
 1743 085c 00010000 		.word	uxSchedulerSuspended
 1744 0860 00000000 		.word	pxCurrentTCB
 1745 0864 E0000000 		.word	uxTopReadyPriority
 1746 0868 04000000 		.word	pxReadyTasksLists
 1747 086c 98000000 		.word	xPendingReadyList
 1748              		.cfi_endproc
 1749              	.LFE17:
 1750              		.size	xTaskResumeFromISR, .-xTaskResumeFromISR
 1751              		.section	.rodata
 1752              		.align	2
 1753              	.LC0:
 1754 0000 49444C45 		.ascii	"IDLE\000"
 1754      00
 1755              		.text
 1756              		.align	1
 1757              		.global	vTaskStartScheduler
ARM GAS  /tmp/cckqXCjj.s 			page 71


 1758              		.syntax unified
 1759              		.thumb
 1760              		.thumb_func
 1761              		.fpu softvfp
 1762              		.type	vTaskStartScheduler, %function
 1763              	vTaskStartScheduler:
 1764              	.LFB18:
1971:FreeRTOS/Source/tasks.c **** 
1972:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1973:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1974:FreeRTOS/Source/tasks.c **** 
1975:FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1976:FreeRTOS/Source/tasks.c **** {
 1765              		.loc 1 1976 0
 1766              		.cfi_startproc
 1767              		@ args = 0, pretend = 0, frame = 8
 1768              		@ frame_needed = 1, uses_anonymous_args = 0
 1769 0870 80B5     		push	{r7, lr}
 1770              		.cfi_def_cfa_offset 8
 1771              		.cfi_offset 7, -8
 1772              		.cfi_offset 14, -4
 1773 0872 84B0     		sub	sp, sp, #16
 1774              		.cfi_def_cfa_offset 24
 1775 0874 02AF     		add	r7, sp, #8
 1776              		.cfi_def_cfa 7, 16
1977:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
1978:FreeRTOS/Source/tasks.c **** 
1979:FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1980:FreeRTOS/Source/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1981:FreeRTOS/Source/tasks.c **** 	{
1982:FreeRTOS/Source/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1983:FreeRTOS/Source/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1984:FreeRTOS/Source/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1985:FreeRTOS/Source/tasks.c **** 
1986:FreeRTOS/Source/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1987:FreeRTOS/Source/tasks.c **** 		address of the RAM then create the idle task. */
1988:FreeRTOS/Source/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1989:FreeRTOS/Source/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1990:FreeRTOS/Source/tasks.c **** 												configIDLE_TASK_NAME,
1991:FreeRTOS/Source/tasks.c **** 												ulIdleTaskStackSize,
1992:FreeRTOS/Source/tasks.c **** 												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
1993:FreeRTOS/Source/tasks.c **** 												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_P
1994:FreeRTOS/Source/tasks.c **** 												pxIdleTaskStackBuffer,
1995:FreeRTOS/Source/tasks.c **** 												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant
1996:FreeRTOS/Source/tasks.c **** 
1997:FreeRTOS/Source/tasks.c **** 		if( xIdleTaskHandle != NULL )
1998:FreeRTOS/Source/tasks.c **** 		{
1999:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
2000:FreeRTOS/Source/tasks.c **** 		}
2001:FreeRTOS/Source/tasks.c **** 		else
2002:FreeRTOS/Source/tasks.c **** 		{
2003:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
2004:FreeRTOS/Source/tasks.c **** 		}
2005:FreeRTOS/Source/tasks.c **** 	}
2006:FreeRTOS/Source/tasks.c **** 	#else
2007:FreeRTOS/Source/tasks.c **** 	{
2008:FreeRTOS/Source/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
ARM GAS  /tmp/cckqXCjj.s 			page 72


2009:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate(	prvIdleTask,
 1777              		.loc 1 2009 0
 1778 0876 134B     		ldr	r3, .L117
 1779 0878 0193     		str	r3, [sp, #4]
 1780 087a 0023     		movs	r3, #0
 1781 087c 0093     		str	r3, [sp]
 1782 087e 0023     		movs	r3, #0
 1783 0880 8022     		movs	r2, #128
 1784 0882 1149     		ldr	r1, .L117+4
 1785 0884 1148     		ldr	r0, .L117+8
 1786 0886 FFF7FEFF 		bl	xTaskCreate
 1787 088a 7860     		str	r0, [r7, #4]
2010:FreeRTOS/Source/tasks.c **** 								configIDLE_TASK_NAME,
2011:FreeRTOS/Source/tasks.c **** 								configMINIMAL_STACK_SIZE,
2012:FreeRTOS/Source/tasks.c **** 								( void * ) NULL,
2013:FreeRTOS/Source/tasks.c **** 								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIOR
2014:FreeRTOS/Source/tasks.c **** 								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explic
2015:FreeRTOS/Source/tasks.c **** 	}
2016:FreeRTOS/Source/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
2017:FreeRTOS/Source/tasks.c **** 
2018:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
2019:FreeRTOS/Source/tasks.c **** 	{
2020:FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
2021:FreeRTOS/Source/tasks.c **** 		{
2022:FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
2023:FreeRTOS/Source/tasks.c **** 		}
2024:FreeRTOS/Source/tasks.c **** 		else
2025:FreeRTOS/Source/tasks.c **** 		{
2026:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2027:FreeRTOS/Source/tasks.c **** 		}
2028:FreeRTOS/Source/tasks.c **** 	}
2029:FreeRTOS/Source/tasks.c **** 	#endif /* configUSE_TIMERS */
2030:FreeRTOS/Source/tasks.c **** 
2031:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 1788              		.loc 1 2031 0
 1789 088c 7B68     		ldr	r3, [r7, #4]
 1790 088e 012B     		cmp	r3, #1
 1791 0890 14D1     		bne	.L116
 1792              	.LBB36:
 1793              	.LBB37:
 197:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 1794              		.loc 2 197 0
 1795              		.syntax unified
 1796              	@ 197 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1797 0892 4FF0BF03 			mov r3, #191												
 1798 0896 83F31188 		msr basepri, r3											
 1799 089a BFF36F8F 		isb														
 1800 089e BFF34F8F 		dsb														
 1801              	
 1802              	@ 0 "" 2
 1803              		.thumb
 1804              		.syntax unified
 1805 08a2 3B60     		str	r3, [r7]
 1806              	.LBE37:
 1807              	.LBE36:
2032:FreeRTOS/Source/tasks.c **** 	{
2033:FreeRTOS/Source/tasks.c **** 		/* freertos_tasks_c_additions_init() should only be called if the user
ARM GAS  /tmp/cckqXCjj.s 			page 73


2034:FreeRTOS/Source/tasks.c **** 		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
2035:FreeRTOS/Source/tasks.c **** 		the only macro called by the function. */
2036:FreeRTOS/Source/tasks.c **** 		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
2037:FreeRTOS/Source/tasks.c **** 		{
2038:FreeRTOS/Source/tasks.c **** 			freertos_tasks_c_additions_init();
2039:FreeRTOS/Source/tasks.c **** 		}
2040:FreeRTOS/Source/tasks.c **** 		#endif
2041:FreeRTOS/Source/tasks.c **** 
2042:FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
2043:FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
2044:FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
2045:FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
2046:FreeRTOS/Source/tasks.c **** 		starts to run. */
2047:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
2048:FreeRTOS/Source/tasks.c **** 
2049:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2050:FreeRTOS/Source/tasks.c **** 		{
2051:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2052:FreeRTOS/Source/tasks.c **** 			structure specific to the task that will run first.
2053:FreeRTOS/Source/tasks.c **** 			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
2054:FreeRTOS/Source/tasks.c **** 			for additional information. */
2055:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2056:FreeRTOS/Source/tasks.c **** 		}
2057:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2058:FreeRTOS/Source/tasks.c **** 
2059:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 1808              		.loc 1 2059 0
 1809 08a4 0A4B     		ldr	r3, .L117+12
 1810 08a6 4FF0FF32 		mov	r2, #-1
 1811 08aa 1A60     		str	r2, [r3]
2060:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1812              		.loc 1 2060 0
 1813 08ac 094B     		ldr	r3, .L117+16
 1814 08ae 0122     		movs	r2, #1
 1815 08b0 1A60     		str	r2, [r3]
2061:FreeRTOS/Source/tasks.c **** 		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 1816              		.loc 1 2061 0
 1817 08b2 094B     		ldr	r3, .L117+20
 1818 08b4 0022     		movs	r2, #0
 1819 08b6 1A60     		str	r2, [r3]
2062:FreeRTOS/Source/tasks.c **** 
2063:FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
2064:FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
2065:FreeRTOS/Source/tasks.c **** 		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2066:FreeRTOS/Source/tasks.c **** 		is set to 0 and the following line fails to build then ensure you do not
2067:FreeRTOS/Source/tasks.c **** 		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2068:FreeRTOS/Source/tasks.c **** 		FreeRTOSConfig.h file. */
2069:FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
2070:FreeRTOS/Source/tasks.c **** 
2071:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2072:FreeRTOS/Source/tasks.c **** 
2073:FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
2074:FreeRTOS/Source/tasks.c **** 		portable interface. */
2075:FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1820              		.loc 1 2075 0
 1821 08b8 FFF7FEFF 		bl	xPortStartScheduler
 1822              	.L116:
ARM GAS  /tmp/cckqXCjj.s 			page 74


2076:FreeRTOS/Source/tasks.c **** 		{
2077:FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
2078:FreeRTOS/Source/tasks.c **** 			function will not return. */
2079:FreeRTOS/Source/tasks.c **** 		}
2080:FreeRTOS/Source/tasks.c **** 		else
2081:FreeRTOS/Source/tasks.c **** 		{
2082:FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
2083:FreeRTOS/Source/tasks.c **** 		}
2084:FreeRTOS/Source/tasks.c **** 	}
2085:FreeRTOS/Source/tasks.c **** 	else
2086:FreeRTOS/Source/tasks.c **** 	{
2087:FreeRTOS/Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
2088:FreeRTOS/Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
2089:FreeRTOS/Source/tasks.c **** 		or the timer task. */
2090:FreeRTOS/Source/tasks.c **** 		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
2091:FreeRTOS/Source/tasks.c **** 	}
2092:FreeRTOS/Source/tasks.c **** 
2093:FreeRTOS/Source/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2094:FreeRTOS/Source/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
2095:FreeRTOS/Source/tasks.c **** 	( void ) xIdleTaskHandle;
2096:FreeRTOS/Source/tasks.c **** }
 1823              		.loc 1 2096 0
 1824 08bc 00BF     		nop
 1825 08be 0837     		adds	r7, r7, #8
 1826              		.cfi_def_cfa_offset 8
 1827 08c0 BD46     		mov	sp, r7
 1828              		.cfi_def_cfa_register 13
 1829              		@ sp needed
 1830 08c2 80BD     		pop	{r7, pc}
 1831              	.L118:
 1832              		.align	2
 1833              	.L117:
 1834 08c4 FC000000 		.word	xIdleTaskHandle
 1835 08c8 00000000 		.word	.LC0
 1836 08cc 00000000 		.word	prvIdleTask
 1837 08d0 F8000000 		.word	xNextTaskUnblockTime
 1838 08d4 E4000000 		.word	xSchedulerRunning
 1839 08d8 DC000000 		.word	xTickCount
 1840              		.cfi_endproc
 1841              	.LFE18:
 1842              		.size	vTaskStartScheduler, .-vTaskStartScheduler
 1843              		.align	1
 1844              		.global	vTaskEndScheduler
 1845              		.syntax unified
 1846              		.thumb
 1847              		.thumb_func
 1848              		.fpu softvfp
 1849              		.type	vTaskEndScheduler, %function
 1850              	vTaskEndScheduler:
 1851              	.LFB19:
2097:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2098:FreeRTOS/Source/tasks.c **** 
2099:FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
2100:FreeRTOS/Source/tasks.c **** {
 1852              		.loc 1 2100 0
 1853              		.cfi_startproc
 1854              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/cckqXCjj.s 			page 75


 1855              		@ frame_needed = 1, uses_anonymous_args = 0
 1856 08dc 80B5     		push	{r7, lr}
 1857              		.cfi_def_cfa_offset 8
 1858              		.cfi_offset 7, -8
 1859              		.cfi_offset 14, -4
 1860 08de 82B0     		sub	sp, sp, #8
 1861              		.cfi_def_cfa_offset 16
 1862 08e0 00AF     		add	r7, sp, #0
 1863              		.cfi_def_cfa_register 7
 1864              	.LBB38:
 1865              	.LBB39:
 197:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 1866              		.loc 2 197 0
 1867              		.syntax unified
 1868              	@ 197 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 1869 08e2 4FF0BF03 			mov r3, #191												
 1870 08e6 83F31188 		msr basepri, r3											
 1871 08ea BFF36F8F 		isb														
 1872 08ee BFF34F8F 		dsb														
 1873              	
 1874              	@ 0 "" 2
 1875              		.thumb
 1876              		.syntax unified
 1877 08f2 7B60     		str	r3, [r7, #4]
 1878              	.LBE39:
 1879              	.LBE38:
2101:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
2102:FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
2103:FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
2104:FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
2105:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1880              		.loc 1 2105 0
 1881 08f4 044B     		ldr	r3, .L120
 1882 08f6 0022     		movs	r2, #0
 1883 08f8 1A60     		str	r2, [r3]
2106:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1884              		.loc 1 2106 0
 1885 08fa FFF7FEFF 		bl	vPortEndScheduler
2107:FreeRTOS/Source/tasks.c **** }
 1886              		.loc 1 2107 0
 1887 08fe 00BF     		nop
 1888 0900 0837     		adds	r7, r7, #8
 1889              		.cfi_def_cfa_offset 8
 1890 0902 BD46     		mov	sp, r7
 1891              		.cfi_def_cfa_register 13
 1892              		@ sp needed
 1893 0904 80BD     		pop	{r7, pc}
 1894              	.L121:
 1895 0906 00BF     		.align	2
 1896              	.L120:
 1897 0908 E4000000 		.word	xSchedulerRunning
 1898              		.cfi_endproc
 1899              	.LFE19:
 1900              		.size	vTaskEndScheduler, .-vTaskEndScheduler
 1901              		.align	1
 1902              		.global	vTaskSuspendAll
 1903              		.syntax unified
ARM GAS  /tmp/cckqXCjj.s 			page 76


 1904              		.thumb
 1905              		.thumb_func
 1906              		.fpu softvfp
 1907              		.type	vTaskSuspendAll, %function
 1908              	vTaskSuspendAll:
 1909              	.LFB20:
2108:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2109:FreeRTOS/Source/tasks.c **** 
2110:FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
2111:FreeRTOS/Source/tasks.c **** {
 1910              		.loc 1 2111 0
 1911              		.cfi_startproc
 1912              		@ args = 0, pretend = 0, frame = 0
 1913              		@ frame_needed = 1, uses_anonymous_args = 0
 1914              		@ link register save eliminated.
 1915 090c 80B4     		push	{r7}
 1916              		.cfi_def_cfa_offset 4
 1917              		.cfi_offset 7, -4
 1918 090e 00AF     		add	r7, sp, #0
 1919              		.cfi_def_cfa_register 7
2112:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
2113:FreeRTOS/Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
2114:FreeRTOS/Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
2115:FreeRTOS/Source/tasks.c **** 	http://goo.gl/wu4acr */
2116:FreeRTOS/Source/tasks.c **** 
2117:FreeRTOS/Source/tasks.c **** 	/* portSOFRWARE_BARRIER() is only implemented for emulated/simulated ports that
2118:FreeRTOS/Source/tasks.c **** 	do not otherwise exhibit real time behaviour. */
2119:FreeRTOS/Source/tasks.c **** 	portSOFTWARE_BARRIER();
2120:FreeRTOS/Source/tasks.c **** 
2121:FreeRTOS/Source/tasks.c **** 	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
2122:FreeRTOS/Source/tasks.c **** 	is used to allow calls to vTaskSuspendAll() to nest. */
2123:FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
 1920              		.loc 1 2123 0
 1921 0910 044B     		ldr	r3, .L123
 1922 0912 1B68     		ldr	r3, [r3]
 1923 0914 0133     		adds	r3, r3, #1
 1924 0916 034A     		ldr	r2, .L123
 1925 0918 1360     		str	r3, [r2]
2124:FreeRTOS/Source/tasks.c **** 
2125:FreeRTOS/Source/tasks.c **** 	/* Enforces ordering for ports and optimised compilers that may otherwise place
2126:FreeRTOS/Source/tasks.c **** 	the above increment elsewhere. */
2127:FreeRTOS/Source/tasks.c **** 	portMEMORY_BARRIER();
 1926              		.loc 1 2127 0
2128:FreeRTOS/Source/tasks.c **** }
 1927              		.loc 1 2128 0
 1928 091a 00BF     		nop
 1929 091c BD46     		mov	sp, r7
 1930              		.cfi_def_cfa_register 13
 1931              		@ sp needed
 1932 091e 80BC     		pop	{r7}
 1933              		.cfi_restore 7
 1934              		.cfi_def_cfa_offset 0
 1935 0920 7047     		bx	lr
 1936              	.L124:
 1937 0922 00BF     		.align	2
 1938              	.L123:
 1939 0924 00010000 		.word	uxSchedulerSuspended
ARM GAS  /tmp/cckqXCjj.s 			page 77


 1940              		.cfi_endproc
 1941              	.LFE20:
 1942              		.size	vTaskSuspendAll, .-vTaskSuspendAll
 1943              		.align	1
 1944              		.global	xTaskResumeAll
 1945              		.syntax unified
 1946              		.thumb
 1947              		.thumb_func
 1948              		.fpu softvfp
 1949              		.type	xTaskResumeAll, %function
 1950              	xTaskResumeAll:
 1951              	.LFB21:
2129:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2130:FreeRTOS/Source/tasks.c **** 
2131:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2132:FreeRTOS/Source/tasks.c **** 
2133:FreeRTOS/Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
2134:FreeRTOS/Source/tasks.c **** 	{
2135:FreeRTOS/Source/tasks.c **** 	TickType_t xReturn;
2136:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2137:FreeRTOS/Source/tasks.c **** 
2138:FreeRTOS/Source/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
2139:FreeRTOS/Source/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2140:FreeRTOS/Source/tasks.c **** 		task that are in the Ready state, even though the idle task is
2141:FreeRTOS/Source/tasks.c **** 		running. */
2142:FreeRTOS/Source/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2143:FreeRTOS/Source/tasks.c **** 		{
2144:FreeRTOS/Source/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
2145:FreeRTOS/Source/tasks.c **** 			{
2146:FreeRTOS/Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2147:FreeRTOS/Source/tasks.c **** 			}
2148:FreeRTOS/Source/tasks.c **** 		}
2149:FreeRTOS/Source/tasks.c **** 		#else
2150:FreeRTOS/Source/tasks.c **** 		{
2151:FreeRTOS/Source/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2152:FreeRTOS/Source/tasks.c **** 
2153:FreeRTOS/Source/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
2154:FreeRTOS/Source/tasks.c **** 			variable is used as a bit map.  If bits other than the least
2155:FreeRTOS/Source/tasks.c **** 			significant bit are set then there are tasks that have a priority
2156:FreeRTOS/Source/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
2157:FreeRTOS/Source/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
2158:FreeRTOS/Source/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
2159:FreeRTOS/Source/tasks.c **** 			{
2160:FreeRTOS/Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
2161:FreeRTOS/Source/tasks.c **** 			}
2162:FreeRTOS/Source/tasks.c **** 		}
2163:FreeRTOS/Source/tasks.c **** 		#endif
2164:FreeRTOS/Source/tasks.c **** 
2165:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2166:FreeRTOS/Source/tasks.c **** 		{
2167:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2168:FreeRTOS/Source/tasks.c **** 		}
2169:FreeRTOS/Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2170:FreeRTOS/Source/tasks.c **** 		{
2171:FreeRTOS/Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
2172:FreeRTOS/Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
2173:FreeRTOS/Source/tasks.c **** 			processed. */
ARM GAS  /tmp/cckqXCjj.s 			page 78


2174:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2175:FreeRTOS/Source/tasks.c **** 		}
2176:FreeRTOS/Source/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
2177:FreeRTOS/Source/tasks.c **** 		{
2178:FreeRTOS/Source/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
2179:FreeRTOS/Source/tasks.c **** 			idle priority.  This path can only be reached if
2180:FreeRTOS/Source/tasks.c **** 			configUSE_PREEMPTION is 0. */
2181:FreeRTOS/Source/tasks.c **** 			xReturn = 0;
2182:FreeRTOS/Source/tasks.c **** 		}
2183:FreeRTOS/Source/tasks.c **** 		else
2184:FreeRTOS/Source/tasks.c **** 		{
2185:FreeRTOS/Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
2186:FreeRTOS/Source/tasks.c **** 		}
2187:FreeRTOS/Source/tasks.c **** 
2188:FreeRTOS/Source/tasks.c **** 		return xReturn;
2189:FreeRTOS/Source/tasks.c **** 	}
2190:FreeRTOS/Source/tasks.c **** 
2191:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2192:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2193:FreeRTOS/Source/tasks.c **** 
2194:FreeRTOS/Source/tasks.c **** BaseType_t xTaskResumeAll( void )
2195:FreeRTOS/Source/tasks.c **** {
 1952              		.loc 1 2195 0
 1953              		.cfi_startproc
 1954              		@ args = 0, pretend = 0, frame = 16
 1955              		@ frame_needed = 1, uses_anonymous_args = 0
 1956 0928 80B5     		push	{r7, lr}
 1957              		.cfi_def_cfa_offset 8
 1958              		.cfi_offset 7, -8
 1959              		.cfi_offset 14, -4
 1960 092a 84B0     		sub	sp, sp, #16
 1961              		.cfi_def_cfa_offset 24
 1962 092c 00AF     		add	r7, sp, #0
 1963              		.cfi_def_cfa_register 7
2196:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB = NULL;
 1964              		.loc 1 2196 0
 1965 092e 0023     		movs	r3, #0
 1966 0930 FB60     		str	r3, [r7, #12]
2197:FreeRTOS/Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
 1967              		.loc 1 2197 0
 1968 0932 0023     		movs	r3, #0
 1969 0934 BB60     		str	r3, [r7, #8]
2198:FreeRTOS/Source/tasks.c **** 
2199:FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
2200:FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
2201:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
2202:FreeRTOS/Source/tasks.c **** 
2203:FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
2204:FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
2205:FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
2206:FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
2207:FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
2208:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1970              		.loc 1 2208 0
 1971 0936 FFF7FEFF 		bl	vPortEnterCritical
2209:FreeRTOS/Source/tasks.c **** 	{
2210:FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
ARM GAS  /tmp/cckqXCjj.s 			page 79


 1972              		.loc 1 2210 0
 1973 093a 394B     		ldr	r3, .L134
 1974 093c 1B68     		ldr	r3, [r3]
 1975 093e 013B     		subs	r3, r3, #1
 1976 0940 374A     		ldr	r2, .L134
 1977 0942 1360     		str	r3, [r2]
2211:FreeRTOS/Source/tasks.c **** 
2212:FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1978              		.loc 1 2212 0
 1979 0944 364B     		ldr	r3, .L134
 1980 0946 1B68     		ldr	r3, [r3]
 1981 0948 002B     		cmp	r3, #0
 1982 094a 61D1     		bne	.L126
2213:FreeRTOS/Source/tasks.c **** 		{
2214:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 1983              		.loc 1 2214 0
 1984 094c 354B     		ldr	r3, .L134+4
 1985 094e 1B68     		ldr	r3, [r3]
 1986 0950 002B     		cmp	r3, #0
 1987 0952 5DD0     		beq	.L126
2215:FreeRTOS/Source/tasks.c **** 			{
2216:FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
2217:FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
2218:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1988              		.loc 1 2218 0
 1989 0954 2EE0     		b	.L127
 1990              	.L128:
2219:FreeRTOS/Source/tasks.c **** 				{
2220:FreeRTOS/Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as
 1991              		.loc 1 2220 0
 1992 0956 344B     		ldr	r3, .L134+8
 1993 0958 DB68     		ldr	r3, [r3, #12]
 1994 095a DB68     		ldr	r3, [r3, #12]
 1995 095c FB60     		str	r3, [r7, #12]
2221:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1996              		.loc 1 2221 0
 1997 095e FB68     		ldr	r3, [r7, #12]
 1998 0960 1833     		adds	r3, r3, #24
 1999 0962 1846     		mov	r0, r3
 2000 0964 FFF7FEFF 		bl	uxListRemove
2222:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2001              		.loc 1 2222 0
 2002 0968 FB68     		ldr	r3, [r7, #12]
 2003 096a 0433     		adds	r3, r3, #4
 2004 096c 1846     		mov	r0, r3
 2005 096e FFF7FEFF 		bl	uxListRemove
2223:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2006              		.loc 1 2223 0
 2007 0972 FB68     		ldr	r3, [r7, #12]
 2008 0974 DB6A     		ldr	r3, [r3, #44]
 2009 0976 0122     		movs	r2, #1
 2010 0978 9A40     		lsls	r2, r2, r3
 2011 097a 2C4B     		ldr	r3, .L134+12
 2012 097c 1B68     		ldr	r3, [r3]
 2013 097e 1343     		orrs	r3, r3, r2
 2014 0980 2A4A     		ldr	r2, .L134+12
 2015 0982 1360     		str	r3, [r2]
ARM GAS  /tmp/cckqXCjj.s 			page 80


 2016 0984 FB68     		ldr	r3, [r7, #12]
 2017 0986 DA6A     		ldr	r2, [r3, #44]
 2018 0988 1346     		mov	r3, r2
 2019 098a 9B00     		lsls	r3, r3, #2
 2020 098c 1344     		add	r3, r3, r2
 2021 098e 9B00     		lsls	r3, r3, #2
 2022 0990 274A     		ldr	r2, .L134+16
 2023 0992 1A44     		add	r2, r2, r3
 2024 0994 FB68     		ldr	r3, [r7, #12]
 2025 0996 0433     		adds	r3, r3, #4
 2026 0998 1946     		mov	r1, r3
 2027 099a 1046     		mov	r0, r2
 2028 099c FFF7FEFF 		bl	vListInsertEnd
2224:FreeRTOS/Source/tasks.c **** 
2225:FreeRTOS/Source/tasks.c **** 					/* If the moved task has a priority higher than the current
2226:FreeRTOS/Source/tasks.c **** 					task then a yield must be performed. */
2227:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2029              		.loc 1 2227 0
 2030 09a0 FB68     		ldr	r3, [r7, #12]
 2031 09a2 DA6A     		ldr	r2, [r3, #44]
 2032 09a4 234B     		ldr	r3, .L134+20
 2033 09a6 1B68     		ldr	r3, [r3]
 2034 09a8 DB6A     		ldr	r3, [r3, #44]
 2035 09aa 9A42     		cmp	r2, r3
 2036 09ac 02D3     		bcc	.L127
2228:FreeRTOS/Source/tasks.c **** 					{
2229:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
 2037              		.loc 1 2229 0
 2038 09ae 224B     		ldr	r3, .L134+24
 2039 09b0 0122     		movs	r2, #1
 2040 09b2 1A60     		str	r2, [r3]
 2041              	.L127:
2218:FreeRTOS/Source/tasks.c **** 				{
 2042              		.loc 1 2218 0
 2043 09b4 1C4B     		ldr	r3, .L134+8
 2044 09b6 1B68     		ldr	r3, [r3]
 2045 09b8 002B     		cmp	r3, #0
 2046 09ba CCD1     		bne	.L128
2230:FreeRTOS/Source/tasks.c **** 					}
2231:FreeRTOS/Source/tasks.c **** 					else
2232:FreeRTOS/Source/tasks.c **** 					{
2233:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2234:FreeRTOS/Source/tasks.c **** 					}
2235:FreeRTOS/Source/tasks.c **** 				}
2236:FreeRTOS/Source/tasks.c **** 
2237:FreeRTOS/Source/tasks.c **** 				if( pxTCB != NULL )
 2047              		.loc 1 2237 0
 2048 09bc FB68     		ldr	r3, [r7, #12]
 2049 09be 002B     		cmp	r3, #0
 2050 09c0 01D0     		beq	.L129
2238:FreeRTOS/Source/tasks.c **** 				{
2239:FreeRTOS/Source/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
2240:FreeRTOS/Source/tasks.c **** 					which may have prevented the next unblock time from being
2241:FreeRTOS/Source/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
2242:FreeRTOS/Source/tasks.c **** 					important for low power tickless implementations, where
2243:FreeRTOS/Source/tasks.c **** 					this can prevent an unnecessary exit from low power
2244:FreeRTOS/Source/tasks.c **** 					state. */
ARM GAS  /tmp/cckqXCjj.s 			page 81


2245:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
 2051              		.loc 1 2245 0
 2052 09c2 00F061FB 		bl	prvResetNextTaskUnblockTime
 2053              	.L129:
 2054              	.LBB40:
2246:FreeRTOS/Source/tasks.c **** 				}
2247:FreeRTOS/Source/tasks.c **** 
2248:FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
2249:FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
2250:FreeRTOS/Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
2251:FreeRTOS/Source/tasks.c **** 				time. */
2252:FreeRTOS/Source/tasks.c **** 				{
2253:FreeRTOS/Source/tasks.c **** 					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 2055              		.loc 1 2253 0
 2056 09c6 1D4B     		ldr	r3, .L134+28
 2057 09c8 1B68     		ldr	r3, [r3]
 2058 09ca 7B60     		str	r3, [r7, #4]
2254:FreeRTOS/Source/tasks.c **** 
2255:FreeRTOS/Source/tasks.c **** 					if( xPendedCounts > ( TickType_t ) 0U )
 2059              		.loc 1 2255 0
 2060 09cc 7B68     		ldr	r3, [r7, #4]
 2061 09ce 002B     		cmp	r3, #0
 2062 09d0 10D0     		beq	.L130
 2063              	.L132:
2256:FreeRTOS/Source/tasks.c **** 					{
2257:FreeRTOS/Source/tasks.c **** 						do
2258:FreeRTOS/Source/tasks.c **** 						{
2259:FreeRTOS/Source/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
 2064              		.loc 1 2259 0
 2065 09d2 FFF7FEFF 		bl	xTaskIncrementTick
 2066 09d6 0346     		mov	r3, r0
 2067 09d8 002B     		cmp	r3, #0
 2068 09da 02D0     		beq	.L131
2260:FreeRTOS/Source/tasks.c **** 							{
2261:FreeRTOS/Source/tasks.c **** 								xYieldPending = pdTRUE;
 2069              		.loc 1 2261 0
 2070 09dc 164B     		ldr	r3, .L134+24
 2071 09de 0122     		movs	r2, #1
 2072 09e0 1A60     		str	r2, [r3]
 2073              	.L131:
2262:FreeRTOS/Source/tasks.c **** 							}
2263:FreeRTOS/Source/tasks.c **** 							else
2264:FreeRTOS/Source/tasks.c **** 							{
2265:FreeRTOS/Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2266:FreeRTOS/Source/tasks.c **** 							}
2267:FreeRTOS/Source/tasks.c **** 							--xPendedCounts;
 2074              		.loc 1 2267 0
 2075 09e2 7B68     		ldr	r3, [r7, #4]
 2076 09e4 013B     		subs	r3, r3, #1
 2077 09e6 7B60     		str	r3, [r7, #4]
2268:FreeRTOS/Source/tasks.c **** 						} while( xPendedCounts > ( TickType_t ) 0U );
 2078              		.loc 1 2268 0
 2079 09e8 7B68     		ldr	r3, [r7, #4]
 2080 09ea 002B     		cmp	r3, #0
 2081 09ec F1D1     		bne	.L132
2269:FreeRTOS/Source/tasks.c **** 
2270:FreeRTOS/Source/tasks.c **** 						xPendedTicks = 0;
ARM GAS  /tmp/cckqXCjj.s 			page 82


 2082              		.loc 1 2270 0
 2083 09ee 134B     		ldr	r3, .L134+28
 2084 09f0 0022     		movs	r2, #0
 2085 09f2 1A60     		str	r2, [r3]
 2086              	.L130:
 2087              	.LBE40:
2271:FreeRTOS/Source/tasks.c **** 					}
2272:FreeRTOS/Source/tasks.c **** 					else
2273:FreeRTOS/Source/tasks.c **** 					{
2274:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2275:FreeRTOS/Source/tasks.c **** 					}
2276:FreeRTOS/Source/tasks.c **** 				}
2277:FreeRTOS/Source/tasks.c **** 
2278:FreeRTOS/Source/tasks.c **** 				if( xYieldPending != pdFALSE )
 2088              		.loc 1 2278 0
 2089 09f4 104B     		ldr	r3, .L134+24
 2090 09f6 1B68     		ldr	r3, [r3]
 2091 09f8 002B     		cmp	r3, #0
 2092 09fa 09D0     		beq	.L126
2279:FreeRTOS/Source/tasks.c **** 				{
2280:FreeRTOS/Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
2281:FreeRTOS/Source/tasks.c **** 					{
2282:FreeRTOS/Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
 2093              		.loc 1 2282 0
 2094 09fc 0123     		movs	r3, #1
 2095 09fe BB60     		str	r3, [r7, #8]
2283:FreeRTOS/Source/tasks.c **** 					}
2284:FreeRTOS/Source/tasks.c **** 					#endif
2285:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 2096              		.loc 1 2285 0
 2097 0a00 0F4B     		ldr	r3, .L134+32
 2098 0a02 4FF08052 		mov	r2, #268435456
 2099 0a06 1A60     		str	r2, [r3]
 2100              		.syntax unified
 2101              	@ 2285 "FreeRTOS/Source/tasks.c" 1
 2102 0a08 BFF34F8F 		dsb
 2103              	@ 0 "" 2
 2104              	@ 2285 "FreeRTOS/Source/tasks.c" 1
 2105 0a0c BFF36F8F 		isb
 2106              	@ 0 "" 2
 2107              		.thumb
 2108              		.syntax unified
 2109              	.L126:
2286:FreeRTOS/Source/tasks.c **** 				}
2287:FreeRTOS/Source/tasks.c **** 				else
2288:FreeRTOS/Source/tasks.c **** 				{
2289:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2290:FreeRTOS/Source/tasks.c **** 				}
2291:FreeRTOS/Source/tasks.c **** 			}
2292:FreeRTOS/Source/tasks.c **** 		}
2293:FreeRTOS/Source/tasks.c **** 		else
2294:FreeRTOS/Source/tasks.c **** 		{
2295:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2296:FreeRTOS/Source/tasks.c **** 		}
2297:FreeRTOS/Source/tasks.c **** 	}
2298:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 2110              		.loc 1 2298 0
ARM GAS  /tmp/cckqXCjj.s 			page 83


 2111 0a10 FFF7FEFF 		bl	vPortExitCritical
2299:FreeRTOS/Source/tasks.c **** 
2300:FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
 2112              		.loc 1 2300 0
 2113 0a14 BB68     		ldr	r3, [r7, #8]
2301:FreeRTOS/Source/tasks.c **** }
 2114              		.loc 1 2301 0
 2115 0a16 1846     		mov	r0, r3
 2116 0a18 1037     		adds	r7, r7, #16
 2117              		.cfi_def_cfa_offset 8
 2118 0a1a BD46     		mov	sp, r7
 2119              		.cfi_def_cfa_register 13
 2120              		@ sp needed
 2121 0a1c 80BD     		pop	{r7, pc}
 2122              	.L135:
 2123 0a1e 00BF     		.align	2
 2124              	.L134:
 2125 0a20 00010000 		.word	uxSchedulerSuspended
 2126 0a24 D8000000 		.word	uxCurrentNumberOfTasks
 2127 0a28 98000000 		.word	xPendingReadyList
 2128 0a2c E0000000 		.word	uxTopReadyPriority
 2129 0a30 04000000 		.word	pxReadyTasksLists
 2130 0a34 00000000 		.word	pxCurrentTCB
 2131 0a38 EC000000 		.word	xYieldPending
 2132 0a3c E8000000 		.word	xPendedTicks
 2133 0a40 04ED00E0 		.word	-536810236
 2134              		.cfi_endproc
 2135              	.LFE21:
 2136              		.size	xTaskResumeAll, .-xTaskResumeAll
 2137              		.align	1
 2138              		.global	xTaskGetTickCount
 2139              		.syntax unified
 2140              		.thumb
 2141              		.thumb_func
 2142              		.fpu softvfp
 2143              		.type	xTaskGetTickCount, %function
 2144              	xTaskGetTickCount:
 2145              	.LFB22:
2302:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2303:FreeRTOS/Source/tasks.c **** 
2304:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCount( void )
2305:FreeRTOS/Source/tasks.c **** {
 2146              		.loc 1 2305 0
 2147              		.cfi_startproc
 2148              		@ args = 0, pretend = 0, frame = 8
 2149              		@ frame_needed = 1, uses_anonymous_args = 0
 2150              		@ link register save eliminated.
 2151 0a44 80B4     		push	{r7}
 2152              		.cfi_def_cfa_offset 4
 2153              		.cfi_offset 7, -4
 2154 0a46 83B0     		sub	sp, sp, #12
 2155              		.cfi_def_cfa_offset 16
 2156 0a48 00AF     		add	r7, sp, #0
 2157              		.cfi_def_cfa_register 7
2306:FreeRTOS/Source/tasks.c **** TickType_t xTicks;
2307:FreeRTOS/Source/tasks.c **** 
2308:FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
ARM GAS  /tmp/cckqXCjj.s 			page 84


2309:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2310:FreeRTOS/Source/tasks.c **** 	{
2311:FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
 2158              		.loc 1 2311 0
 2159 0a4a 044B     		ldr	r3, .L138
 2160 0a4c 1B68     		ldr	r3, [r3]
 2161 0a4e 7B60     		str	r3, [r7, #4]
2312:FreeRTOS/Source/tasks.c **** 	}
2313:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2314:FreeRTOS/Source/tasks.c **** 
2315:FreeRTOS/Source/tasks.c **** 	return xTicks;
 2162              		.loc 1 2315 0
 2163 0a50 7B68     		ldr	r3, [r7, #4]
2316:FreeRTOS/Source/tasks.c **** }
 2164              		.loc 1 2316 0
 2165 0a52 1846     		mov	r0, r3
 2166 0a54 0C37     		adds	r7, r7, #12
 2167              		.cfi_def_cfa_offset 4
 2168 0a56 BD46     		mov	sp, r7
 2169              		.cfi_def_cfa_register 13
 2170              		@ sp needed
 2171 0a58 80BC     		pop	{r7}
 2172              		.cfi_restore 7
 2173              		.cfi_def_cfa_offset 0
 2174 0a5a 7047     		bx	lr
 2175              	.L139:
 2176              		.align	2
 2177              	.L138:
 2178 0a5c DC000000 		.word	xTickCount
 2179              		.cfi_endproc
 2180              	.LFE22:
 2181              		.size	xTaskGetTickCount, .-xTaskGetTickCount
 2182              		.align	1
 2183              		.global	xTaskGetTickCountFromISR
 2184              		.syntax unified
 2185              		.thumb
 2186              		.thumb_func
 2187              		.fpu softvfp
 2188              		.type	xTaskGetTickCountFromISR, %function
 2189              	xTaskGetTickCountFromISR:
 2190              	.LFB23:
2317:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2318:FreeRTOS/Source/tasks.c **** 
2319:FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2320:FreeRTOS/Source/tasks.c **** {
 2191              		.loc 1 2320 0
 2192              		.cfi_startproc
 2193              		@ args = 0, pretend = 0, frame = 8
 2194              		@ frame_needed = 1, uses_anonymous_args = 0
 2195              		@ link register save eliminated.
 2196 0a60 80B4     		push	{r7}
 2197              		.cfi_def_cfa_offset 4
 2198              		.cfi_offset 7, -4
 2199 0a62 83B0     		sub	sp, sp, #12
 2200              		.cfi_def_cfa_offset 16
 2201 0a64 00AF     		add	r7, sp, #0
 2202              		.cfi_def_cfa_register 7
ARM GAS  /tmp/cckqXCjj.s 			page 85


2321:FreeRTOS/Source/tasks.c **** TickType_t xReturn;
2322:FreeRTOS/Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2323:FreeRTOS/Source/tasks.c **** 
2324:FreeRTOS/Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2325:FreeRTOS/Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2326:FreeRTOS/Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2327:FreeRTOS/Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2328:FreeRTOS/Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2329:FreeRTOS/Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2330:FreeRTOS/Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2331:FreeRTOS/Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2332:FreeRTOS/Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2333:FreeRTOS/Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2334:FreeRTOS/Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2335:FreeRTOS/Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2336:FreeRTOS/Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2337:FreeRTOS/Source/tasks.c **** 	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
2338:FreeRTOS/Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2339:FreeRTOS/Source/tasks.c **** 
2340:FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 2203              		.loc 1 2340 0
 2204 0a66 0023     		movs	r3, #0
 2205 0a68 7B60     		str	r3, [r7, #4]
2341:FreeRTOS/Source/tasks.c **** 	{
2342:FreeRTOS/Source/tasks.c **** 		xReturn = xTickCount;
 2206              		.loc 1 2342 0
 2207 0a6a 044B     		ldr	r3, .L142
 2208 0a6c 1B68     		ldr	r3, [r3]
 2209 0a6e 3B60     		str	r3, [r7]
2343:FreeRTOS/Source/tasks.c **** 	}
2344:FreeRTOS/Source/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2345:FreeRTOS/Source/tasks.c **** 
2346:FreeRTOS/Source/tasks.c **** 	return xReturn;
 2210              		.loc 1 2346 0
 2211 0a70 3B68     		ldr	r3, [r7]
2347:FreeRTOS/Source/tasks.c **** }
 2212              		.loc 1 2347 0
 2213 0a72 1846     		mov	r0, r3
 2214 0a74 0C37     		adds	r7, r7, #12
 2215              		.cfi_def_cfa_offset 4
 2216 0a76 BD46     		mov	sp, r7
 2217              		.cfi_def_cfa_register 13
 2218              		@ sp needed
 2219 0a78 80BC     		pop	{r7}
 2220              		.cfi_restore 7
 2221              		.cfi_def_cfa_offset 0
 2222 0a7a 7047     		bx	lr
 2223              	.L143:
 2224              		.align	2
 2225              	.L142:
 2226 0a7c DC000000 		.word	xTickCount
 2227              		.cfi_endproc
 2228              	.LFE23:
 2229              		.size	xTaskGetTickCountFromISR, .-xTaskGetTickCountFromISR
 2230              		.align	1
 2231              		.global	uxTaskGetNumberOfTasks
 2232              		.syntax unified
ARM GAS  /tmp/cckqXCjj.s 			page 86


 2233              		.thumb
 2234              		.thumb_func
 2235              		.fpu softvfp
 2236              		.type	uxTaskGetNumberOfTasks, %function
 2237              	uxTaskGetNumberOfTasks:
 2238              	.LFB24:
2348:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2349:FreeRTOS/Source/tasks.c **** 
2350:FreeRTOS/Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2351:FreeRTOS/Source/tasks.c **** {
 2239              		.loc 1 2351 0
 2240              		.cfi_startproc
 2241              		@ args = 0, pretend = 0, frame = 0
 2242              		@ frame_needed = 1, uses_anonymous_args = 0
 2243              		@ link register save eliminated.
 2244 0a80 80B4     		push	{r7}
 2245              		.cfi_def_cfa_offset 4
 2246              		.cfi_offset 7, -4
 2247 0a82 00AF     		add	r7, sp, #0
 2248              		.cfi_def_cfa_register 7
2352:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
2353:FreeRTOS/Source/tasks.c **** 	BaseType_t. */
2354:FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 2249              		.loc 1 2354 0
 2250 0a84 024B     		ldr	r3, .L146
 2251 0a86 1B68     		ldr	r3, [r3]
2355:FreeRTOS/Source/tasks.c **** }
 2252              		.loc 1 2355 0
 2253 0a88 1846     		mov	r0, r3
 2254 0a8a BD46     		mov	sp, r7
 2255              		.cfi_def_cfa_register 13
 2256              		@ sp needed
 2257 0a8c 80BC     		pop	{r7}
 2258              		.cfi_restore 7
 2259              		.cfi_def_cfa_offset 0
 2260 0a8e 7047     		bx	lr
 2261              	.L147:
 2262              		.align	2
 2263              	.L146:
 2264 0a90 D8000000 		.word	uxCurrentNumberOfTasks
 2265              		.cfi_endproc
 2266              	.LFE24:
 2267              		.size	uxTaskGetNumberOfTasks, .-uxTaskGetNumberOfTasks
 2268              		.align	1
 2269              		.global	pcTaskGetName
 2270              		.syntax unified
 2271              		.thumb
 2272              		.thumb_func
 2273              		.fpu softvfp
 2274              		.type	pcTaskGetName, %function
 2275              	pcTaskGetName:
 2276              	.LFB25:
2356:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2357:FreeRTOS/Source/tasks.c **** 
2358:FreeRTOS/Source/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2359:FreeRTOS/Source/tasks.c **** {
 2277              		.loc 1 2359 0
ARM GAS  /tmp/cckqXCjj.s 			page 87


 2278              		.cfi_startproc
 2279              		@ args = 0, pretend = 0, frame = 16
 2280              		@ frame_needed = 1, uses_anonymous_args = 0
 2281              		@ link register save eliminated.
 2282 0a94 80B4     		push	{r7}
 2283              		.cfi_def_cfa_offset 4
 2284              		.cfi_offset 7, -4
 2285 0a96 85B0     		sub	sp, sp, #20
 2286              		.cfi_def_cfa_offset 24
 2287 0a98 00AF     		add	r7, sp, #0
 2288              		.cfi_def_cfa_register 7
 2289 0a9a 7860     		str	r0, [r7, #4]
2360:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
2361:FreeRTOS/Source/tasks.c **** 
2362:FreeRTOS/Source/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2363:FreeRTOS/Source/tasks.c **** 	queried. */
2364:FreeRTOS/Source/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 2290              		.loc 1 2364 0
 2291 0a9c 7B68     		ldr	r3, [r7, #4]
 2292 0a9e 002B     		cmp	r3, #0
 2293 0aa0 02D1     		bne	.L149
 2294              		.loc 1 2364 0 is_stmt 0 discriminator 1
 2295 0aa2 064B     		ldr	r3, .L152
 2296 0aa4 1B68     		ldr	r3, [r3]
 2297 0aa6 00E0     		b	.L150
 2298              	.L149:
 2299              		.loc 1 2364 0 discriminator 2
 2300 0aa8 7B68     		ldr	r3, [r7, #4]
 2301              	.L150:
 2302              		.loc 1 2364 0 discriminator 4
 2303 0aaa FB60     		str	r3, [r7, #12]
2365:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTCB );
2366:FreeRTOS/Source/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
 2304              		.loc 1 2366 0 is_stmt 1 discriminator 4
 2305 0aac FB68     		ldr	r3, [r7, #12]
 2306 0aae 3433     		adds	r3, r3, #52
2367:FreeRTOS/Source/tasks.c **** }
 2307              		.loc 1 2367 0 discriminator 4
 2308 0ab0 1846     		mov	r0, r3
 2309 0ab2 1437     		adds	r7, r7, #20
 2310              		.cfi_def_cfa_offset 4
 2311 0ab4 BD46     		mov	sp, r7
 2312              		.cfi_def_cfa_register 13
 2313              		@ sp needed
 2314 0ab6 80BC     		pop	{r7}
 2315              		.cfi_restore 7
 2316              		.cfi_def_cfa_offset 0
 2317 0ab8 7047     		bx	lr
 2318              	.L153:
 2319 0aba 00BF     		.align	2
 2320              	.L152:
 2321 0abc 00000000 		.word	pxCurrentTCB
 2322              		.cfi_endproc
 2323              	.LFE25:
 2324              		.size	pcTaskGetName, .-pcTaskGetName
 2325              		.align	1
 2326              		.global	xTaskCatchUpTicks
ARM GAS  /tmp/cckqXCjj.s 			page 88


 2327              		.syntax unified
 2328              		.thumb
 2329              		.thumb_func
 2330              		.fpu softvfp
 2331              		.type	xTaskCatchUpTicks, %function
 2332              	xTaskCatchUpTicks:
 2333              	.LFB26:
2368:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2369:FreeRTOS/Source/tasks.c **** 
2370:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2371:FreeRTOS/Source/tasks.c **** 
2372:FreeRTOS/Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2373:FreeRTOS/Source/tasks.c **** 	{
2374:FreeRTOS/Source/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2375:FreeRTOS/Source/tasks.c **** 	UBaseType_t x;
2376:FreeRTOS/Source/tasks.c **** 	char cNextChar;
2377:FreeRTOS/Source/tasks.c **** 	BaseType_t xBreakLoop;
2378:FreeRTOS/Source/tasks.c **** 
2379:FreeRTOS/Source/tasks.c **** 		/* This function is called with the scheduler suspended. */
2380:FreeRTOS/Source/tasks.c **** 
2381:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2382:FreeRTOS/Source/tasks.c **** 		{
2383:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro i
2384:FreeRTOS/Source/tasks.c **** 
2385:FreeRTOS/Source/tasks.c **** 			do
2386:FreeRTOS/Source/tasks.c **** 			{
2387:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
2388:FreeRTOS/Source/tasks.c **** 
2389:FreeRTOS/Source/tasks.c **** 				/* Check each character in the name looking for a match or
2390:FreeRTOS/Source/tasks.c **** 				mismatch. */
2391:FreeRTOS/Source/tasks.c **** 				xBreakLoop = pdFALSE;
2392:FreeRTOS/Source/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2393:FreeRTOS/Source/tasks.c **** 				{
2394:FreeRTOS/Source/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2395:FreeRTOS/Source/tasks.c **** 
2396:FreeRTOS/Source/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2397:FreeRTOS/Source/tasks.c **** 					{
2398:FreeRTOS/Source/tasks.c **** 						/* Characters didn't match. */
2399:FreeRTOS/Source/tasks.c **** 						xBreakLoop = pdTRUE;
2400:FreeRTOS/Source/tasks.c **** 					}
2401:FreeRTOS/Source/tasks.c **** 					else if( cNextChar == ( char ) 0x00 )
2402:FreeRTOS/Source/tasks.c **** 					{
2403:FreeRTOS/Source/tasks.c **** 						/* Both strings terminated, a match must have been
2404:FreeRTOS/Source/tasks.c **** 						found. */
2405:FreeRTOS/Source/tasks.c **** 						pxReturn = pxNextTCB;
2406:FreeRTOS/Source/tasks.c **** 						xBreakLoop = pdTRUE;
2407:FreeRTOS/Source/tasks.c **** 					}
2408:FreeRTOS/Source/tasks.c **** 					else
2409:FreeRTOS/Source/tasks.c **** 					{
2410:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2411:FreeRTOS/Source/tasks.c **** 					}
2412:FreeRTOS/Source/tasks.c **** 
2413:FreeRTOS/Source/tasks.c **** 					if( xBreakLoop != pdFALSE )
2414:FreeRTOS/Source/tasks.c **** 					{
2415:FreeRTOS/Source/tasks.c **** 						break;
2416:FreeRTOS/Source/tasks.c **** 					}
2417:FreeRTOS/Source/tasks.c **** 				}
ARM GAS  /tmp/cckqXCjj.s 			page 89


2418:FreeRTOS/Source/tasks.c **** 
2419:FreeRTOS/Source/tasks.c **** 				if( pxReturn != NULL )
2420:FreeRTOS/Source/tasks.c **** 				{
2421:FreeRTOS/Source/tasks.c **** 					/* The handle has been found. */
2422:FreeRTOS/Source/tasks.c **** 					break;
2423:FreeRTOS/Source/tasks.c **** 				}
2424:FreeRTOS/Source/tasks.c **** 
2425:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2426:FreeRTOS/Source/tasks.c **** 		}
2427:FreeRTOS/Source/tasks.c **** 		else
2428:FreeRTOS/Source/tasks.c **** 		{
2429:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2430:FreeRTOS/Source/tasks.c **** 		}
2431:FreeRTOS/Source/tasks.c **** 
2432:FreeRTOS/Source/tasks.c **** 		return pxReturn;
2433:FreeRTOS/Source/tasks.c **** 	}
2434:FreeRTOS/Source/tasks.c **** 
2435:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2436:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2437:FreeRTOS/Source/tasks.c **** 
2438:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2439:FreeRTOS/Source/tasks.c **** 
2440:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2441:FreeRTOS/Source/tasks.c **** 	{
2442:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2443:FreeRTOS/Source/tasks.c **** 	TCB_t* pxTCB;
2444:FreeRTOS/Source/tasks.c **** 
2445:FreeRTOS/Source/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2446:FreeRTOS/Source/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2447:FreeRTOS/Source/tasks.c **** 
2448:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2449:FreeRTOS/Source/tasks.c **** 		{
2450:FreeRTOS/Source/tasks.c **** 			/* Search the ready lists. */
2451:FreeRTOS/Source/tasks.c **** 			do
2452:FreeRTOS/Source/tasks.c **** 			{
2453:FreeRTOS/Source/tasks.c **** 				uxQueue--;
2454:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2455:FreeRTOS/Source/tasks.c **** 
2456:FreeRTOS/Source/tasks.c **** 				if( pxTCB != NULL )
2457:FreeRTOS/Source/tasks.c **** 				{
2458:FreeRTOS/Source/tasks.c **** 					/* Found the handle. */
2459:FreeRTOS/Source/tasks.c **** 					break;
2460:FreeRTOS/Source/tasks.c **** 				}
2461:FreeRTOS/Source/tasks.c **** 
2462:FreeRTOS/Source/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2463:FreeRTOS/Source/tasks.c **** 
2464:FreeRTOS/Source/tasks.c **** 			/* Search the delayed lists. */
2465:FreeRTOS/Source/tasks.c **** 			if( pxTCB == NULL )
2466:FreeRTOS/Source/tasks.c **** 			{
2467:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2468:FreeRTOS/Source/tasks.c **** 			}
2469:FreeRTOS/Source/tasks.c **** 
2470:FreeRTOS/Source/tasks.c **** 			if( pxTCB == NULL )
2471:FreeRTOS/Source/tasks.c **** 			{
2472:FreeRTOS/Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2473:FreeRTOS/Source/tasks.c **** 			}
2474:FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/cckqXCjj.s 			page 90


2475:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2476:FreeRTOS/Source/tasks.c **** 			{
2477:FreeRTOS/Source/tasks.c **** 				if( pxTCB == NULL )
2478:FreeRTOS/Source/tasks.c **** 				{
2479:FreeRTOS/Source/tasks.c **** 					/* Search the suspended list. */
2480:FreeRTOS/Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2481:FreeRTOS/Source/tasks.c **** 				}
2482:FreeRTOS/Source/tasks.c **** 			}
2483:FreeRTOS/Source/tasks.c **** 			#endif
2484:FreeRTOS/Source/tasks.c **** 
2485:FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2486:FreeRTOS/Source/tasks.c **** 			{
2487:FreeRTOS/Source/tasks.c **** 				if( pxTCB == NULL )
2488:FreeRTOS/Source/tasks.c **** 				{
2489:FreeRTOS/Source/tasks.c **** 					/* Search the deleted list. */
2490:FreeRTOS/Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2491:FreeRTOS/Source/tasks.c **** 				}
2492:FreeRTOS/Source/tasks.c **** 			}
2493:FreeRTOS/Source/tasks.c **** 			#endif
2494:FreeRTOS/Source/tasks.c **** 		}
2495:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2496:FreeRTOS/Source/tasks.c **** 
2497:FreeRTOS/Source/tasks.c **** 		return pxTCB;
2498:FreeRTOS/Source/tasks.c **** 	}
2499:FreeRTOS/Source/tasks.c **** 
2500:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2501:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2502:FreeRTOS/Source/tasks.c **** 
2503:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2504:FreeRTOS/Source/tasks.c **** 
2505:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2506:FreeRTOS/Source/tasks.c **** 	{
2507:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2508:FreeRTOS/Source/tasks.c **** 
2509:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2510:FreeRTOS/Source/tasks.c **** 		{
2511:FreeRTOS/Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2512:FreeRTOS/Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2513:FreeRTOS/Source/tasks.c **** 			{
2514:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2515:FreeRTOS/Source/tasks.c **** 				task in the Ready state. */
2516:FreeRTOS/Source/tasks.c **** 				do
2517:FreeRTOS/Source/tasks.c **** 				{
2518:FreeRTOS/Source/tasks.c **** 					uxQueue--;
2519:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2520:FreeRTOS/Source/tasks.c **** 
2521:FreeRTOS/Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2522:FreeRTOS/Source/tasks.c **** 
2523:FreeRTOS/Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2524:FreeRTOS/Source/tasks.c **** 				task in the Blocked state. */
2525:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2526:FreeRTOS/Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2527:FreeRTOS/Source/tasks.c **** 
2528:FreeRTOS/Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2529:FreeRTOS/Source/tasks.c **** 				{
2530:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2531:FreeRTOS/Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
ARM GAS  /tmp/cckqXCjj.s 			page 91


2532:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2533:FreeRTOS/Source/tasks.c **** 				}
2534:FreeRTOS/Source/tasks.c **** 				#endif
2535:FreeRTOS/Source/tasks.c **** 
2536:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2537:FreeRTOS/Source/tasks.c **** 				{
2538:FreeRTOS/Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2539:FreeRTOS/Source/tasks.c **** 					each task in the Suspended state. */
2540:FreeRTOS/Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
2541:FreeRTOS/Source/tasks.c **** 				}
2542:FreeRTOS/Source/tasks.c **** 				#endif
2543:FreeRTOS/Source/tasks.c **** 
2544:FreeRTOS/Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2545:FreeRTOS/Source/tasks.c **** 				{
2546:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2547:FreeRTOS/Source/tasks.c **** 					{
2548:FreeRTOS/Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2549:FreeRTOS/Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2550:FreeRTOS/Source/tasks.c **** 						#else
2551:FreeRTOS/Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2552:FreeRTOS/Source/tasks.c **** 						#endif
2553:FreeRTOS/Source/tasks.c **** 					}
2554:FreeRTOS/Source/tasks.c **** 				}
2555:FreeRTOS/Source/tasks.c **** 				#else
2556:FreeRTOS/Source/tasks.c **** 				{
2557:FreeRTOS/Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2558:FreeRTOS/Source/tasks.c **** 					{
2559:FreeRTOS/Source/tasks.c **** 						*pulTotalRunTime = 0;
2560:FreeRTOS/Source/tasks.c **** 					}
2561:FreeRTOS/Source/tasks.c **** 				}
2562:FreeRTOS/Source/tasks.c **** 				#endif
2563:FreeRTOS/Source/tasks.c **** 			}
2564:FreeRTOS/Source/tasks.c **** 			else
2565:FreeRTOS/Source/tasks.c **** 			{
2566:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2567:FreeRTOS/Source/tasks.c **** 			}
2568:FreeRTOS/Source/tasks.c **** 		}
2569:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2570:FreeRTOS/Source/tasks.c **** 
2571:FreeRTOS/Source/tasks.c **** 		return uxTask;
2572:FreeRTOS/Source/tasks.c **** 	}
2573:FreeRTOS/Source/tasks.c **** 
2574:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2575:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2576:FreeRTOS/Source/tasks.c **** 
2577:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2578:FreeRTOS/Source/tasks.c **** 
2579:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2580:FreeRTOS/Source/tasks.c **** 	{
2581:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2582:FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2583:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2584:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
2585:FreeRTOS/Source/tasks.c **** 	}
2586:FreeRTOS/Source/tasks.c **** 
2587:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2588:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
ARM GAS  /tmp/cckqXCjj.s 			page 92


2589:FreeRTOS/Source/tasks.c **** 
2590:FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2591:FreeRTOS/Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2592:FreeRTOS/Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2593:FreeRTOS/Source/tasks.c **** 1. */
2594:FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2595:FreeRTOS/Source/tasks.c **** 
2596:FreeRTOS/Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2597:FreeRTOS/Source/tasks.c **** 	{
2598:FreeRTOS/Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2599:FreeRTOS/Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2600:FreeRTOS/Source/tasks.c **** 		each stepped tick. */
2601:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2602:FreeRTOS/Source/tasks.c **** 		xTickCount += xTicksToJump;
2603:FreeRTOS/Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2604:FreeRTOS/Source/tasks.c **** 	}
2605:FreeRTOS/Source/tasks.c **** 
2606:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2607:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2608:FreeRTOS/Source/tasks.c **** 
2609:FreeRTOS/Source/tasks.c **** BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
2610:FreeRTOS/Source/tasks.c **** {
 2334              		.loc 1 2610 0
 2335              		.cfi_startproc
 2336              		@ args = 0, pretend = 0, frame = 16
 2337              		@ frame_needed = 1, uses_anonymous_args = 0
 2338 0ac0 80B5     		push	{r7, lr}
 2339              		.cfi_def_cfa_offset 8
 2340              		.cfi_offset 7, -8
 2341              		.cfi_offset 14, -4
 2342 0ac2 84B0     		sub	sp, sp, #16
 2343              		.cfi_def_cfa_offset 24
 2344 0ac4 00AF     		add	r7, sp, #0
 2345              		.cfi_def_cfa_register 7
 2346 0ac6 7860     		str	r0, [r7, #4]
2611:FreeRTOS/Source/tasks.c **** BaseType_t xYieldRequired = pdFALSE;
 2347              		.loc 1 2611 0
 2348 0ac8 0023     		movs	r3, #0
 2349 0aca FB60     		str	r3, [r7, #12]
2612:FreeRTOS/Source/tasks.c **** 
2613:FreeRTOS/Source/tasks.c **** 	/* Must not be called with the scheduler suspended as the implementation
2614:FreeRTOS/Source/tasks.c **** 	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
2615:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended == 0 );
2616:FreeRTOS/Source/tasks.c **** 
2617:FreeRTOS/Source/tasks.c **** 	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
2618:FreeRTOS/Source/tasks.c **** 	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
2619:FreeRTOS/Source/tasks.c **** 	vTaskSuspendAll();
 2350              		.loc 1 2619 0
 2351 0acc FFF7FEFF 		bl	vTaskSuspendAll
2620:FreeRTOS/Source/tasks.c **** 	xPendedTicks += xTicksToCatchUp;
 2352              		.loc 1 2620 0
 2353 0ad0 064B     		ldr	r3, .L156
 2354 0ad2 1A68     		ldr	r2, [r3]
 2355 0ad4 7B68     		ldr	r3, [r7, #4]
 2356 0ad6 1344     		add	r3, r3, r2
 2357 0ad8 044A     		ldr	r2, .L156
 2358 0ada 1360     		str	r3, [r2]
ARM GAS  /tmp/cckqXCjj.s 			page 93


2621:FreeRTOS/Source/tasks.c **** 	xYieldRequired = xTaskResumeAll();
 2359              		.loc 1 2621 0
 2360 0adc FFF7FEFF 		bl	xTaskResumeAll
 2361 0ae0 F860     		str	r0, [r7, #12]
2622:FreeRTOS/Source/tasks.c **** 
2623:FreeRTOS/Source/tasks.c **** 	return xYieldRequired;
 2362              		.loc 1 2623 0
 2363 0ae2 FB68     		ldr	r3, [r7, #12]
2624:FreeRTOS/Source/tasks.c **** }
 2364              		.loc 1 2624 0
 2365 0ae4 1846     		mov	r0, r3
 2366 0ae6 1037     		adds	r7, r7, #16
 2367              		.cfi_def_cfa_offset 8
 2368 0ae8 BD46     		mov	sp, r7
 2369              		.cfi_def_cfa_register 13
 2370              		@ sp needed
 2371 0aea 80BD     		pop	{r7, pc}
 2372              	.L157:
 2373              		.align	2
 2374              	.L156:
 2375 0aec E8000000 		.word	xPendedTicks
 2376              		.cfi_endproc
 2377              	.LFE26:
 2378              		.size	xTaskCatchUpTicks, .-xTaskCatchUpTicks
 2379              		.align	1
 2380              		.global	xTaskIncrementTick
 2381              		.syntax unified
 2382              		.thumb
 2383              		.thumb_func
 2384              		.fpu softvfp
 2385              		.type	xTaskIncrementTick, %function
 2386              	xTaskIncrementTick:
 2387              	.LFB27:
2625:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2626:FreeRTOS/Source/tasks.c **** 
2627:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2628:FreeRTOS/Source/tasks.c **** 
2629:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2630:FreeRTOS/Source/tasks.c **** 	{
2631:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB = xTask;
2632:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2633:FreeRTOS/Source/tasks.c **** 
2634:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
2635:FreeRTOS/Source/tasks.c **** 
2636:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
2637:FreeRTOS/Source/tasks.c **** 		{
2638:FreeRTOS/Source/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2639:FreeRTOS/Source/tasks.c **** 			it is actually in the Blocked state. */
2640:FreeRTOS/Source/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2641:FreeRTOS/Source/tasks.c **** 			{
2642:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
2643:FreeRTOS/Source/tasks.c **** 
2644:FreeRTOS/Source/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2645:FreeRTOS/Source/tasks.c **** 				interrupt won't touch the xStateListItem because the
2646:FreeRTOS/Source/tasks.c **** 				scheduler is suspended. */
2647:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2648:FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/cckqXCjj.s 			page 94


2649:FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2650:FreeRTOS/Source/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2651:FreeRTOS/Source/tasks.c **** 				even though the scheduler is suspended, so a critical section
2652:FreeRTOS/Source/tasks.c **** 				is used. */
2653:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
2654:FreeRTOS/Source/tasks.c **** 				{
2655:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2656:FreeRTOS/Source/tasks.c **** 					{
2657:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2658:FreeRTOS/Source/tasks.c **** 
2659:FreeRTOS/Source/tasks.c **** 						/* This lets the task know it was forcibly removed from the
2660:FreeRTOS/Source/tasks.c **** 						blocked state so it should not re-evaluate its block time and
2661:FreeRTOS/Source/tasks.c **** 						then block again. */
2662:FreeRTOS/Source/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2663:FreeRTOS/Source/tasks.c **** 					}
2664:FreeRTOS/Source/tasks.c **** 					else
2665:FreeRTOS/Source/tasks.c **** 					{
2666:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2667:FreeRTOS/Source/tasks.c **** 					}
2668:FreeRTOS/Source/tasks.c **** 				}
2669:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
2670:FreeRTOS/Source/tasks.c **** 
2671:FreeRTOS/Source/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2672:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2673:FreeRTOS/Source/tasks.c **** 
2674:FreeRTOS/Source/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2675:FreeRTOS/Source/tasks.c **** 				switch if preemption is turned off. */
2676:FreeRTOS/Source/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2677:FreeRTOS/Source/tasks.c **** 				{
2678:FreeRTOS/Source/tasks.c **** 					/* Preemption is on, but a context switch should only be
2679:FreeRTOS/Source/tasks.c **** 					performed if the unblocked task has a priority that is
2680:FreeRTOS/Source/tasks.c **** 					equal to or higher than the currently executing task. */
2681:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2682:FreeRTOS/Source/tasks.c **** 					{
2683:FreeRTOS/Source/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2684:FreeRTOS/Source/tasks.c **** 						is unsuspended. */
2685:FreeRTOS/Source/tasks.c **** 						xYieldPending = pdTRUE;
2686:FreeRTOS/Source/tasks.c **** 					}
2687:FreeRTOS/Source/tasks.c **** 					else
2688:FreeRTOS/Source/tasks.c **** 					{
2689:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2690:FreeRTOS/Source/tasks.c **** 					}
2691:FreeRTOS/Source/tasks.c **** 				}
2692:FreeRTOS/Source/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2693:FreeRTOS/Source/tasks.c **** 			}
2694:FreeRTOS/Source/tasks.c **** 			else
2695:FreeRTOS/Source/tasks.c **** 			{
2696:FreeRTOS/Source/tasks.c **** 				xReturn = pdFAIL;
2697:FreeRTOS/Source/tasks.c **** 			}
2698:FreeRTOS/Source/tasks.c **** 		}
2699:FreeRTOS/Source/tasks.c **** 		( void ) xTaskResumeAll();
2700:FreeRTOS/Source/tasks.c **** 
2701:FreeRTOS/Source/tasks.c **** 		return xReturn;
2702:FreeRTOS/Source/tasks.c **** 	}
2703:FreeRTOS/Source/tasks.c **** 
2704:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2705:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
ARM GAS  /tmp/cckqXCjj.s 			page 95


2706:FreeRTOS/Source/tasks.c **** 
2707:FreeRTOS/Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
2708:FreeRTOS/Source/tasks.c **** {
 2388              		.loc 1 2708 0
 2389              		.cfi_startproc
 2390              		@ args = 0, pretend = 0, frame = 24
 2391              		@ frame_needed = 1, uses_anonymous_args = 0
 2392 0af0 80B5     		push	{r7, lr}
 2393              		.cfi_def_cfa_offset 8
 2394              		.cfi_offset 7, -8
 2395              		.cfi_offset 14, -4
 2396 0af2 86B0     		sub	sp, sp, #24
 2397              		.cfi_def_cfa_offset 32
 2398 0af4 00AF     		add	r7, sp, #0
 2399              		.cfi_def_cfa_register 7
2709:FreeRTOS/Source/tasks.c **** TCB_t * pxTCB;
2710:FreeRTOS/Source/tasks.c **** TickType_t xItemValue;
2711:FreeRTOS/Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
 2400              		.loc 1 2711 0
 2401 0af6 0023     		movs	r3, #0
 2402 0af8 7B61     		str	r3, [r7, #20]
2712:FreeRTOS/Source/tasks.c **** 
2713:FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2714:FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2715:FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
2716:FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2717:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2403              		.loc 1 2717 0
 2404 0afa 464B     		ldr	r3, .L171
 2405 0afc 1B68     		ldr	r3, [r3]
 2406 0afe 002B     		cmp	r3, #0
 2407 0b00 7DD1     		bne	.L159
 2408              	.LBB41:
2718:FreeRTOS/Source/tasks.c **** 	{
2719:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2720:FreeRTOS/Source/tasks.c **** 		block. */
2721:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 2409              		.loc 1 2721 0
 2410 0b02 454B     		ldr	r3, .L171+4
 2411 0b04 1B68     		ldr	r3, [r3]
 2412 0b06 0133     		adds	r3, r3, #1
 2413 0b08 3B61     		str	r3, [r7, #16]
2722:FreeRTOS/Source/tasks.c **** 
2723:FreeRTOS/Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2724:FreeRTOS/Source/tasks.c **** 		delayed lists if it wraps to 0. */
2725:FreeRTOS/Source/tasks.c **** 		xTickCount = xConstTickCount;
 2414              		.loc 1 2725 0
 2415 0b0a 434A     		ldr	r2, .L171+4
 2416 0b0c 3B69     		ldr	r3, [r7, #16]
 2417 0b0e 1360     		str	r3, [r2]
2726:FreeRTOS/Source/tasks.c **** 
2727:FreeRTOS/Source/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as
 2418              		.loc 1 2727 0
 2419 0b10 3B69     		ldr	r3, [r7, #16]
 2420 0b12 002B     		cmp	r3, #0
 2421 0b14 10D1     		bne	.L160
 2422              	.LBB42:
ARM GAS  /tmp/cckqXCjj.s 			page 96


2728:FreeRTOS/Source/tasks.c **** 		{
2729:FreeRTOS/Source/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
 2423              		.loc 1 2729 0
 2424 0b16 414B     		ldr	r3, .L171+8
 2425 0b18 1B68     		ldr	r3, [r3]
 2426 0b1a FB60     		str	r3, [r7, #12]
 2427 0b1c 404B     		ldr	r3, .L171+12
 2428 0b1e 1B68     		ldr	r3, [r3]
 2429 0b20 3E4A     		ldr	r2, .L171+8
 2430 0b22 1360     		str	r3, [r2]
 2431 0b24 3E4A     		ldr	r2, .L171+12
 2432 0b26 FB68     		ldr	r3, [r7, #12]
 2433 0b28 1360     		str	r3, [r2]
 2434 0b2a 3E4B     		ldr	r3, .L171+16
 2435 0b2c 1B68     		ldr	r3, [r3]
 2436 0b2e 0133     		adds	r3, r3, #1
 2437 0b30 3C4A     		ldr	r2, .L171+16
 2438 0b32 1360     		str	r3, [r2]
 2439 0b34 00F0A8FA 		bl	prvResetNextTaskUnblockTime
 2440              	.L160:
 2441              	.LBE42:
2730:FreeRTOS/Source/tasks.c **** 		}
2731:FreeRTOS/Source/tasks.c **** 		else
2732:FreeRTOS/Source/tasks.c **** 		{
2733:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2734:FreeRTOS/Source/tasks.c **** 		}
2735:FreeRTOS/Source/tasks.c **** 
2736:FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2737:FreeRTOS/Source/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2738:FreeRTOS/Source/tasks.c **** 		has been found whose block time has not expired there is no need to
2739:FreeRTOS/Source/tasks.c **** 		look any further down the list. */
2740:FreeRTOS/Source/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
 2442              		.loc 1 2740 0
 2443 0b38 3B4B     		ldr	r3, .L171+20
 2444 0b3a 1B68     		ldr	r3, [r3]
 2445 0b3c 3A69     		ldr	r2, [r7, #16]
 2446 0b3e 9A42     		cmp	r2, r3
 2447 0b40 48D3     		bcc	.L161
 2448              	.L166:
2741:FreeRTOS/Source/tasks.c **** 		{
2742:FreeRTOS/Source/tasks.c **** 			for( ;; )
2743:FreeRTOS/Source/tasks.c **** 			{
2744:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2449              		.loc 1 2744 0
 2450 0b42 364B     		ldr	r3, .L171+8
 2451 0b44 1B68     		ldr	r3, [r3]
 2452 0b46 1B68     		ldr	r3, [r3]
 2453 0b48 002B     		cmp	r3, #0
 2454 0b4a 04D1     		bne	.L162
2745:FreeRTOS/Source/tasks.c **** 				{
2746:FreeRTOS/Source/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2747:FreeRTOS/Source/tasks.c **** 					to the maximum possible value so it is extremely
2748:FreeRTOS/Source/tasks.c **** 					unlikely that the
2749:FreeRTOS/Source/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2750:FreeRTOS/Source/tasks.c **** 					next time through. */
2751:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
 2455              		.loc 1 2751 0
ARM GAS  /tmp/cckqXCjj.s 			page 97


 2456 0b4c 364B     		ldr	r3, .L171+20
 2457 0b4e 4FF0FF32 		mov	r2, #-1
 2458 0b52 1A60     		str	r2, [r3]
2752:FreeRTOS/Source/tasks.c **** 					break;
 2459              		.loc 1 2752 0
 2460 0b54 3EE0     		b	.L161
 2461              	.L162:
2753:FreeRTOS/Source/tasks.c **** 				}
2754:FreeRTOS/Source/tasks.c **** 				else
2755:FreeRTOS/Source/tasks.c **** 				{
2756:FreeRTOS/Source/tasks.c **** 					/* The delayed list is not empty, get the value of the
2757:FreeRTOS/Source/tasks.c **** 					item at the head of the delayed list.  This is the time
2758:FreeRTOS/Source/tasks.c **** 					at which the task at the head of the delayed list must
2759:FreeRTOS/Source/tasks.c **** 					be removed from the Blocked state. */
2760:FreeRTOS/Source/tasks.c **** 					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this
 2462              		.loc 1 2760 0
 2463 0b56 314B     		ldr	r3, .L171+8
 2464 0b58 1B68     		ldr	r3, [r3]
 2465 0b5a DB68     		ldr	r3, [r3, #12]
 2466 0b5c DB68     		ldr	r3, [r3, #12]
 2467 0b5e BB60     		str	r3, [r7, #8]
2761:FreeRTOS/Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 2468              		.loc 1 2761 0
 2469 0b60 BB68     		ldr	r3, [r7, #8]
 2470 0b62 5B68     		ldr	r3, [r3, #4]
 2471 0b64 7B60     		str	r3, [r7, #4]
2762:FreeRTOS/Source/tasks.c **** 
2763:FreeRTOS/Source/tasks.c **** 					if( xConstTickCount < xItemValue )
 2472              		.loc 1 2763 0
 2473 0b66 3A69     		ldr	r2, [r7, #16]
 2474 0b68 7B68     		ldr	r3, [r7, #4]
 2475 0b6a 9A42     		cmp	r2, r3
 2476 0b6c 03D2     		bcs	.L163
2764:FreeRTOS/Source/tasks.c **** 					{
2765:FreeRTOS/Source/tasks.c **** 						/* It is not time to unblock this item yet, but the
2766:FreeRTOS/Source/tasks.c **** 						item value is the time at which the task at the head
2767:FreeRTOS/Source/tasks.c **** 						of the blocked list must be removed from the Blocked
2768:FreeRTOS/Source/tasks.c **** 						state -	so record the item value in
2769:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime. */
2770:FreeRTOS/Source/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
 2477              		.loc 1 2770 0
 2478 0b6e 2E4A     		ldr	r2, .L171+20
 2479 0b70 7B68     		ldr	r3, [r7, #4]
 2480 0b72 1360     		str	r3, [r2]
2771:FreeRTOS/Source/tasks.c **** 						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks
 2481              		.loc 1 2771 0
 2482 0b74 2EE0     		b	.L161
 2483              	.L163:
2772:FreeRTOS/Source/tasks.c **** 					}
2773:FreeRTOS/Source/tasks.c **** 					else
2774:FreeRTOS/Source/tasks.c **** 					{
2775:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2776:FreeRTOS/Source/tasks.c **** 					}
2777:FreeRTOS/Source/tasks.c **** 
2778:FreeRTOS/Source/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2779:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2484              		.loc 1 2779 0
ARM GAS  /tmp/cckqXCjj.s 			page 98


 2485 0b76 BB68     		ldr	r3, [r7, #8]
 2486 0b78 0433     		adds	r3, r3, #4
 2487 0b7a 1846     		mov	r0, r3
 2488 0b7c FFF7FEFF 		bl	uxListRemove
2780:FreeRTOS/Source/tasks.c **** 
2781:FreeRTOS/Source/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2782:FreeRTOS/Source/tasks.c **** 					it from the event list. */
2783:FreeRTOS/Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2489              		.loc 1 2783 0
 2490 0b80 BB68     		ldr	r3, [r7, #8]
 2491 0b82 9B6A     		ldr	r3, [r3, #40]
 2492 0b84 002B     		cmp	r3, #0
 2493 0b86 04D0     		beq	.L164
2784:FreeRTOS/Source/tasks.c **** 					{
2785:FreeRTOS/Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2494              		.loc 1 2785 0
 2495 0b88 BB68     		ldr	r3, [r7, #8]
 2496 0b8a 1833     		adds	r3, r3, #24
 2497 0b8c 1846     		mov	r0, r3
 2498 0b8e FFF7FEFF 		bl	uxListRemove
 2499              	.L164:
2786:FreeRTOS/Source/tasks.c **** 					}
2787:FreeRTOS/Source/tasks.c **** 					else
2788:FreeRTOS/Source/tasks.c **** 					{
2789:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2790:FreeRTOS/Source/tasks.c **** 					}
2791:FreeRTOS/Source/tasks.c **** 
2792:FreeRTOS/Source/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2793:FreeRTOS/Source/tasks.c **** 					list. */
2794:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2500              		.loc 1 2794 0
 2501 0b92 BB68     		ldr	r3, [r7, #8]
 2502 0b94 DB6A     		ldr	r3, [r3, #44]
 2503 0b96 0122     		movs	r2, #1
 2504 0b98 9A40     		lsls	r2, r2, r3
 2505 0b9a 244B     		ldr	r3, .L171+24
 2506 0b9c 1B68     		ldr	r3, [r3]
 2507 0b9e 1343     		orrs	r3, r3, r2
 2508 0ba0 224A     		ldr	r2, .L171+24
 2509 0ba2 1360     		str	r3, [r2]
 2510 0ba4 BB68     		ldr	r3, [r7, #8]
 2511 0ba6 DA6A     		ldr	r2, [r3, #44]
 2512 0ba8 1346     		mov	r3, r2
 2513 0baa 9B00     		lsls	r3, r3, #2
 2514 0bac 1344     		add	r3, r3, r2
 2515 0bae 9B00     		lsls	r3, r3, #2
 2516 0bb0 1F4A     		ldr	r2, .L171+28
 2517 0bb2 1A44     		add	r2, r2, r3
 2518 0bb4 BB68     		ldr	r3, [r7, #8]
 2519 0bb6 0433     		adds	r3, r3, #4
 2520 0bb8 1946     		mov	r1, r3
 2521 0bba 1046     		mov	r0, r2
 2522 0bbc FFF7FEFF 		bl	vListInsertEnd
2795:FreeRTOS/Source/tasks.c **** 
2796:FreeRTOS/Source/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2797:FreeRTOS/Source/tasks.c **** 					context switch if preemption is turned off. */
2798:FreeRTOS/Source/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
ARM GAS  /tmp/cckqXCjj.s 			page 99


2799:FreeRTOS/Source/tasks.c **** 					{
2800:FreeRTOS/Source/tasks.c **** 						/* Preemption is on, but a context switch should
2801:FreeRTOS/Source/tasks.c **** 						only be performed if the unblocked task has a
2802:FreeRTOS/Source/tasks.c **** 						priority that is equal to or higher than the
2803:FreeRTOS/Source/tasks.c **** 						currently executing task. */
2804:FreeRTOS/Source/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2523              		.loc 1 2804 0
 2524 0bc0 BB68     		ldr	r3, [r7, #8]
 2525 0bc2 DA6A     		ldr	r2, [r3, #44]
 2526 0bc4 1B4B     		ldr	r3, .L171+32
 2527 0bc6 1B68     		ldr	r3, [r3]
 2528 0bc8 DB6A     		ldr	r3, [r3, #44]
 2529 0bca 9A42     		cmp	r2, r3
 2530 0bcc B9D3     		bcc	.L166
2805:FreeRTOS/Source/tasks.c **** 						{
2806:FreeRTOS/Source/tasks.c **** 							xSwitchRequired = pdTRUE;
 2531              		.loc 1 2806 0
 2532 0bce 0123     		movs	r3, #1
 2533 0bd0 7B61     		str	r3, [r7, #20]
2744:FreeRTOS/Source/tasks.c **** 				{
 2534              		.loc 1 2744 0
 2535 0bd2 B6E7     		b	.L166
 2536              	.L161:
2807:FreeRTOS/Source/tasks.c **** 						}
2808:FreeRTOS/Source/tasks.c **** 						else
2809:FreeRTOS/Source/tasks.c **** 						{
2810:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2811:FreeRTOS/Source/tasks.c **** 						}
2812:FreeRTOS/Source/tasks.c **** 					}
2813:FreeRTOS/Source/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2814:FreeRTOS/Source/tasks.c **** 				}
2815:FreeRTOS/Source/tasks.c **** 			}
2816:FreeRTOS/Source/tasks.c **** 		}
2817:FreeRTOS/Source/tasks.c **** 
2818:FreeRTOS/Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2819:FreeRTOS/Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2820:FreeRTOS/Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
2821:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2822:FreeRTOS/Source/tasks.c **** 		{
2823:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
 2537              		.loc 1 2823 0
 2538 0bd4 174B     		ldr	r3, .L171+32
 2539 0bd6 1B68     		ldr	r3, [r3]
 2540 0bd8 DA6A     		ldr	r2, [r3, #44]
 2541 0bda 1549     		ldr	r1, .L171+28
 2542 0bdc 1346     		mov	r3, r2
 2543 0bde 9B00     		lsls	r3, r3, #2
 2544 0be0 1344     		add	r3, r3, r2
 2545 0be2 9B00     		lsls	r3, r3, #2
 2546 0be4 0B44     		add	r3, r3, r1
 2547 0be6 1B68     		ldr	r3, [r3]
 2548 0be8 012B     		cmp	r3, #1
 2549 0bea 01D9     		bls	.L167
2824:FreeRTOS/Source/tasks.c **** 			{
2825:FreeRTOS/Source/tasks.c **** 				xSwitchRequired = pdTRUE;
 2550              		.loc 1 2825 0
 2551 0bec 0123     		movs	r3, #1
ARM GAS  /tmp/cckqXCjj.s 			page 100


 2552 0bee 7B61     		str	r3, [r7, #20]
 2553              	.L167:
2826:FreeRTOS/Source/tasks.c **** 			}
2827:FreeRTOS/Source/tasks.c **** 			else
2828:FreeRTOS/Source/tasks.c **** 			{
2829:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2830:FreeRTOS/Source/tasks.c **** 			}
2831:FreeRTOS/Source/tasks.c **** 		}
2832:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2833:FreeRTOS/Source/tasks.c **** 
2834:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2835:FreeRTOS/Source/tasks.c **** 		{
2836:FreeRTOS/Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2837:FreeRTOS/Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2838:FreeRTOS/Source/tasks.c **** 			if( xPendedTicks == ( TickType_t ) 0 )
2839:FreeRTOS/Source/tasks.c **** 			{
2840:FreeRTOS/Source/tasks.c **** 				vApplicationTickHook();
2841:FreeRTOS/Source/tasks.c **** 			}
2842:FreeRTOS/Source/tasks.c **** 			else
2843:FreeRTOS/Source/tasks.c **** 			{
2844:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2845:FreeRTOS/Source/tasks.c **** 			}
2846:FreeRTOS/Source/tasks.c **** 		}
2847:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2848:FreeRTOS/Source/tasks.c **** 
2849:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 1 )
2850:FreeRTOS/Source/tasks.c **** 		{
2851:FreeRTOS/Source/tasks.c **** 			if( xYieldPending != pdFALSE )
 2554              		.loc 1 2851 0
 2555 0bf0 114B     		ldr	r3, .L171+36
 2556 0bf2 1B68     		ldr	r3, [r3]
 2557 0bf4 002B     		cmp	r3, #0
 2558 0bf6 07D0     		beq	.L169
2852:FreeRTOS/Source/tasks.c **** 			{
2853:FreeRTOS/Source/tasks.c **** 				xSwitchRequired = pdTRUE;
 2559              		.loc 1 2853 0
 2560 0bf8 0123     		movs	r3, #1
 2561 0bfa 7B61     		str	r3, [r7, #20]
 2562 0bfc 04E0     		b	.L169
 2563              	.L159:
 2564              	.LBE41:
2854:FreeRTOS/Source/tasks.c **** 			}
2855:FreeRTOS/Source/tasks.c **** 			else
2856:FreeRTOS/Source/tasks.c **** 			{
2857:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2858:FreeRTOS/Source/tasks.c **** 			}
2859:FreeRTOS/Source/tasks.c **** 		}
2860:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
2861:FreeRTOS/Source/tasks.c **** 	}
2862:FreeRTOS/Source/tasks.c **** 	else
2863:FreeRTOS/Source/tasks.c **** 	{
2864:FreeRTOS/Source/tasks.c **** 		++xPendedTicks;
 2565              		.loc 1 2864 0
 2566 0bfe 0F4B     		ldr	r3, .L171+40
 2567 0c00 1B68     		ldr	r3, [r3]
 2568 0c02 0133     		adds	r3, r3, #1
 2569 0c04 0D4A     		ldr	r2, .L171+40
ARM GAS  /tmp/cckqXCjj.s 			page 101


 2570 0c06 1360     		str	r3, [r2]
 2571              	.L169:
2865:FreeRTOS/Source/tasks.c **** 
2866:FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2867:FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
2868:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2869:FreeRTOS/Source/tasks.c **** 		{
2870:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
2871:FreeRTOS/Source/tasks.c **** 		}
2872:FreeRTOS/Source/tasks.c **** 		#endif
2873:FreeRTOS/Source/tasks.c **** 	}
2874:FreeRTOS/Source/tasks.c **** 
2875:FreeRTOS/Source/tasks.c **** 	return xSwitchRequired;
 2572              		.loc 1 2875 0
 2573 0c08 7B69     		ldr	r3, [r7, #20]
2876:FreeRTOS/Source/tasks.c **** }
 2574              		.loc 1 2876 0
 2575 0c0a 1846     		mov	r0, r3
 2576 0c0c 1837     		adds	r7, r7, #24
 2577              		.cfi_def_cfa_offset 8
 2578 0c0e BD46     		mov	sp, r7
 2579              		.cfi_def_cfa_register 13
 2580              		@ sp needed
 2581 0c10 80BD     		pop	{r7, pc}
 2582              	.L172:
 2583 0c12 00BF     		.align	2
 2584              	.L171:
 2585 0c14 00010000 		.word	uxSchedulerSuspended
 2586 0c18 DC000000 		.word	xTickCount
 2587 0c1c 90000000 		.word	pxDelayedTaskList
 2588 0c20 94000000 		.word	pxOverflowDelayedTaskList
 2589 0c24 F0000000 		.word	xNumOfOverflows
 2590 0c28 F8000000 		.word	xNextTaskUnblockTime
 2591 0c2c E0000000 		.word	uxTopReadyPriority
 2592 0c30 04000000 		.word	pxReadyTasksLists
 2593 0c34 00000000 		.word	pxCurrentTCB
 2594 0c38 EC000000 		.word	xYieldPending
 2595 0c3c E8000000 		.word	xPendedTicks
 2596              		.cfi_endproc
 2597              	.LFE27:
 2598              		.size	xTaskIncrementTick, .-xTaskIncrementTick
 2599              		.align	1
 2600              		.global	vTaskSwitchContext
 2601              		.syntax unified
 2602              		.thumb
 2603              		.thumb_func
 2604              		.fpu softvfp
 2605              		.type	vTaskSwitchContext, %function
 2606              	vTaskSwitchContext:
 2607              	.LFB28:
2877:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2878:FreeRTOS/Source/tasks.c **** 
2879:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2880:FreeRTOS/Source/tasks.c **** 
2881:FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2882:FreeRTOS/Source/tasks.c **** 	{
2883:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
ARM GAS  /tmp/cckqXCjj.s 			page 102


2884:FreeRTOS/Source/tasks.c **** 
2885:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2886:FreeRTOS/Source/tasks.c **** 		getting set. */
2887:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2888:FreeRTOS/Source/tasks.c **** 		{
2889:FreeRTOS/Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2890:FreeRTOS/Source/tasks.c **** 		}
2891:FreeRTOS/Source/tasks.c **** 		else
2892:FreeRTOS/Source/tasks.c **** 		{
2893:FreeRTOS/Source/tasks.c **** 			xTCB = xTask;
2894:FreeRTOS/Source/tasks.c **** 		}
2895:FreeRTOS/Source/tasks.c **** 
2896:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2897:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2898:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2899:FreeRTOS/Source/tasks.c **** 		{
2900:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2901:FreeRTOS/Source/tasks.c **** 		}
2902:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2903:FreeRTOS/Source/tasks.c **** 	}
2904:FreeRTOS/Source/tasks.c **** 
2905:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2906:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2907:FreeRTOS/Source/tasks.c **** 
2908:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2909:FreeRTOS/Source/tasks.c **** 
2910:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2911:FreeRTOS/Source/tasks.c **** 	{
2912:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2913:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xReturn;
2914:FreeRTOS/Source/tasks.c **** 
2915:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then set the calling task's hook. */
2916:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2917:FreeRTOS/Source/tasks.c **** 
2918:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2919:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2920:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
2921:FreeRTOS/Source/tasks.c **** 		{
2922:FreeRTOS/Source/tasks.c **** 			xReturn = pxTCB->pxTaskTag;
2923:FreeRTOS/Source/tasks.c **** 		}
2924:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
2925:FreeRTOS/Source/tasks.c **** 
2926:FreeRTOS/Source/tasks.c **** 		return xReturn;
2927:FreeRTOS/Source/tasks.c **** 	}
2928:FreeRTOS/Source/tasks.c **** 
2929:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2930:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2931:FreeRTOS/Source/tasks.c **** 
2932:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2933:FreeRTOS/Source/tasks.c **** 
2934:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )
2935:FreeRTOS/Source/tasks.c **** 	{
2936:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
2937:FreeRTOS/Source/tasks.c **** 	TaskHookFunction_t xReturn;
2938:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
2939:FreeRTOS/Source/tasks.c **** 
2940:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then set the calling task's hook. */
ARM GAS  /tmp/cckqXCjj.s 			page 103


2941:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2942:FreeRTOS/Source/tasks.c **** 
2943:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2944:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
2945:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2946:FreeRTOS/Source/tasks.c **** 		{
2947:FreeRTOS/Source/tasks.c **** 			xReturn = pxTCB->pxTaskTag;
2948:FreeRTOS/Source/tasks.c **** 		}
2949:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2950:FreeRTOS/Source/tasks.c **** 
2951:FreeRTOS/Source/tasks.c **** 		return xReturn;
2952:FreeRTOS/Source/tasks.c **** 	}
2953:FreeRTOS/Source/tasks.c **** 
2954:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2955:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2956:FreeRTOS/Source/tasks.c **** 
2957:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2958:FreeRTOS/Source/tasks.c **** 
2959:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2960:FreeRTOS/Source/tasks.c **** 	{
2961:FreeRTOS/Source/tasks.c **** 	TCB_t *xTCB;
2962:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
2963:FreeRTOS/Source/tasks.c **** 
2964:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2965:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
2966:FreeRTOS/Source/tasks.c **** 		{
2967:FreeRTOS/Source/tasks.c **** 			xTCB = pxCurrentTCB;
2968:FreeRTOS/Source/tasks.c **** 		}
2969:FreeRTOS/Source/tasks.c **** 		else
2970:FreeRTOS/Source/tasks.c **** 		{
2971:FreeRTOS/Source/tasks.c **** 			xTCB = xTask;
2972:FreeRTOS/Source/tasks.c **** 		}
2973:FreeRTOS/Source/tasks.c **** 
2974:FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2975:FreeRTOS/Source/tasks.c **** 		{
2976:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2977:FreeRTOS/Source/tasks.c **** 		}
2978:FreeRTOS/Source/tasks.c **** 		else
2979:FreeRTOS/Source/tasks.c **** 		{
2980:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
2981:FreeRTOS/Source/tasks.c **** 		}
2982:FreeRTOS/Source/tasks.c **** 
2983:FreeRTOS/Source/tasks.c **** 		return xReturn;
2984:FreeRTOS/Source/tasks.c **** 	}
2985:FreeRTOS/Source/tasks.c **** 
2986:FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2987:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2988:FreeRTOS/Source/tasks.c **** 
2989:FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
2990:FreeRTOS/Source/tasks.c **** {
 2608              		.loc 1 2990 0
 2609              		.cfi_startproc
 2610              		@ args = 0, pretend = 0, frame = 16
 2611              		@ frame_needed = 1, uses_anonymous_args = 0
 2612              		@ link register save eliminated.
 2613 0c40 80B4     		push	{r7}
 2614              		.cfi_def_cfa_offset 4
ARM GAS  /tmp/cckqXCjj.s 			page 104


 2615              		.cfi_offset 7, -4
 2616 0c42 85B0     		sub	sp, sp, #20
 2617              		.cfi_def_cfa_offset 24
 2618 0c44 00AF     		add	r7, sp, #0
 2619              		.cfi_def_cfa_register 7
2991:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2620              		.loc 1 2991 0
 2621 0c46 1C4B     		ldr	r3, .L179
 2622 0c48 1B68     		ldr	r3, [r3]
 2623 0c4a 002B     		cmp	r3, #0
 2624 0c4c 03D0     		beq	.L174
2992:FreeRTOS/Source/tasks.c **** 	{
2993:FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2994:FreeRTOS/Source/tasks.c **** 		switch. */
2995:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
 2625              		.loc 1 2995 0
 2626 0c4e 1B4B     		ldr	r3, .L179+4
 2627 0c50 0122     		movs	r2, #1
 2628 0c52 1A60     		str	r2, [r3]
2996:FreeRTOS/Source/tasks.c **** 	}
2997:FreeRTOS/Source/tasks.c **** 	else
2998:FreeRTOS/Source/tasks.c **** 	{
2999:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdFALSE;
3000:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
3001:FreeRTOS/Source/tasks.c **** 
3002:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3003:FreeRTOS/Source/tasks.c **** 		{
3004:FreeRTOS/Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
3005:FreeRTOS/Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
3006:FreeRTOS/Source/tasks.c **** 			#else
3007:FreeRTOS/Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
3008:FreeRTOS/Source/tasks.c **** 			#endif
3009:FreeRTOS/Source/tasks.c **** 
3010:FreeRTOS/Source/tasks.c **** 			/* Add the amount of time the task has been running to the
3011:FreeRTOS/Source/tasks.c **** 			accumulated time so far.  The time the task started running was
3012:FreeRTOS/Source/tasks.c **** 			stored in ulTaskSwitchedInTime.  Note that there is no overflow
3013:FreeRTOS/Source/tasks.c **** 			protection here so count values are only valid until the timer
3014:FreeRTOS/Source/tasks.c **** 			overflows.  The guard against negative values is to protect
3015:FreeRTOS/Source/tasks.c **** 			against suspect run time stat counter implementations - which
3016:FreeRTOS/Source/tasks.c **** 			are provided by the application, not the kernel. */
3017:FreeRTOS/Source/tasks.c **** 			if( ulTotalRunTime > ulTaskSwitchedInTime )
3018:FreeRTOS/Source/tasks.c **** 			{
3019:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
3020:FreeRTOS/Source/tasks.c **** 			}
3021:FreeRTOS/Source/tasks.c **** 			else
3022:FreeRTOS/Source/tasks.c **** 			{
3023:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3024:FreeRTOS/Source/tasks.c **** 			}
3025:FreeRTOS/Source/tasks.c **** 			ulTaskSwitchedInTime = ulTotalRunTime;
3026:FreeRTOS/Source/tasks.c **** 		}
3027:FreeRTOS/Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
3028:FreeRTOS/Source/tasks.c **** 
3029:FreeRTOS/Source/tasks.c **** 		/* Check for stack overflow, if configured. */
3030:FreeRTOS/Source/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
3031:FreeRTOS/Source/tasks.c **** 
3032:FreeRTOS/Source/tasks.c **** 		/* Before the currently running task is switched out, save its errno. */
3033:FreeRTOS/Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
ARM GAS  /tmp/cckqXCjj.s 			page 105


3034:FreeRTOS/Source/tasks.c **** 		{
3035:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
3036:FreeRTOS/Source/tasks.c **** 		}
3037:FreeRTOS/Source/tasks.c **** 		#endif
3038:FreeRTOS/Source/tasks.c **** 
3039:FreeRTOS/Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
3040:FreeRTOS/Source/tasks.c **** 		optimised asm code. */
3041:FreeRTOS/Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timer
3042:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
3043:FreeRTOS/Source/tasks.c **** 
3044:FreeRTOS/Source/tasks.c **** 		/* After the new task is switched in, update the global errno. */
3045:FreeRTOS/Source/tasks.c **** 		#if( configUSE_POSIX_ERRNO == 1 )
3046:FreeRTOS/Source/tasks.c **** 		{
3047:FreeRTOS/Source/tasks.c **** 			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
3048:FreeRTOS/Source/tasks.c **** 		}
3049:FreeRTOS/Source/tasks.c **** 		#endif
3050:FreeRTOS/Source/tasks.c **** 
3051:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3052:FreeRTOS/Source/tasks.c **** 		{
3053:FreeRTOS/Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
3054:FreeRTOS/Source/tasks.c **** 			structure specific to this task.
3055:FreeRTOS/Source/tasks.c **** 			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
3056:FreeRTOS/Source/tasks.c **** 			for additional information. */
3057:FreeRTOS/Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
3058:FreeRTOS/Source/tasks.c **** 		}
3059:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3060:FreeRTOS/Source/tasks.c **** 	}
3061:FreeRTOS/Source/tasks.c **** }
 2629              		.loc 1 3061 0
 2630 0c54 2AE0     		b	.L178
 2631              	.L174:
2999:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
 2632              		.loc 1 2999 0
 2633 0c56 194B     		ldr	r3, .L179+4
 2634 0c58 0022     		movs	r2, #0
 2635 0c5a 1A60     		str	r2, [r3]
 2636              	.LBB43:
3041:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2637              		.loc 1 3041 0
 2638 0c5c 184B     		ldr	r3, .L179+8
 2639 0c5e 1B68     		ldr	r3, [r3]
 2640 0c60 7B60     		str	r3, [r7, #4]
 2641              	.LBB44:
 2642              	.LBB45:
 134:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 		return ucReturn;
 2643              		.loc 2 134 0
 2644 0c62 7B68     		ldr	r3, [r7, #4]
 2645              		.syntax unified
 2646              	@ 134 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 2647 0c64 B3FA83F3 		clz r3, r3
 2648              	@ 0 "" 2
 2649              		.thumb
 2650              		.syntax unified
 2651 0c68 FB70     		strb	r3, [r7, #3]
 135:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	}
 2652              		.loc 2 135 0
 2653 0c6a FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
ARM GAS  /tmp/cckqXCjj.s 			page 106


 2654              	.LBE45:
 2655              	.LBE44:
3041:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2656              		.loc 1 3041 0
 2657 0c6c C3F11F03 		rsb	r3, r3, #31
 2658 0c70 FB60     		str	r3, [r7, #12]
 2659              	.LBB46:
 2660 0c72 FA68     		ldr	r2, [r7, #12]
 2661 0c74 1346     		mov	r3, r2
 2662 0c76 9B00     		lsls	r3, r3, #2
 2663 0c78 1344     		add	r3, r3, r2
 2664 0c7a 9B00     		lsls	r3, r3, #2
 2665 0c7c 114A     		ldr	r2, .L179+12
 2666 0c7e 1344     		add	r3, r3, r2
 2667 0c80 BB60     		str	r3, [r7, #8]
 2668 0c82 BB68     		ldr	r3, [r7, #8]
 2669 0c84 5B68     		ldr	r3, [r3, #4]
 2670 0c86 5A68     		ldr	r2, [r3, #4]
 2671 0c88 BB68     		ldr	r3, [r7, #8]
 2672 0c8a 5A60     		str	r2, [r3, #4]
 2673 0c8c BB68     		ldr	r3, [r7, #8]
 2674 0c8e 5A68     		ldr	r2, [r3, #4]
 2675 0c90 BB68     		ldr	r3, [r7, #8]
 2676 0c92 0833     		adds	r3, r3, #8
 2677 0c94 9A42     		cmp	r2, r3
 2678 0c96 04D1     		bne	.L177
3041:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2679              		.loc 1 3041 0 is_stmt 0 discriminator 1
 2680 0c98 BB68     		ldr	r3, [r7, #8]
 2681 0c9a 5B68     		ldr	r3, [r3, #4]
 2682 0c9c 5A68     		ldr	r2, [r3, #4]
 2683 0c9e BB68     		ldr	r3, [r7, #8]
 2684 0ca0 5A60     		str	r2, [r3, #4]
 2685              	.L177:
3041:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2686              		.loc 1 3041 0 discriminator 3
 2687 0ca2 BB68     		ldr	r3, [r7, #8]
 2688 0ca4 5B68     		ldr	r3, [r3, #4]
 2689 0ca6 DB68     		ldr	r3, [r3, #12]
 2690 0ca8 074A     		ldr	r2, .L179+16
 2691 0caa 1360     		str	r3, [r2]
 2692              	.L178:
 2693              	.LBE46:
 2694              	.LBE43:
 2695              		.loc 1 3061 0 is_stmt 1
 2696 0cac 00BF     		nop
 2697 0cae 1437     		adds	r7, r7, #20
 2698              		.cfi_def_cfa_offset 4
 2699 0cb0 BD46     		mov	sp, r7
 2700              		.cfi_def_cfa_register 13
 2701              		@ sp needed
 2702 0cb2 80BC     		pop	{r7}
 2703              		.cfi_restore 7
 2704              		.cfi_def_cfa_offset 0
 2705 0cb4 7047     		bx	lr
 2706              	.L180:
 2707 0cb6 00BF     		.align	2
ARM GAS  /tmp/cckqXCjj.s 			page 107


 2708              	.L179:
 2709 0cb8 00010000 		.word	uxSchedulerSuspended
 2710 0cbc EC000000 		.word	xYieldPending
 2711 0cc0 E0000000 		.word	uxTopReadyPriority
 2712 0cc4 04000000 		.word	pxReadyTasksLists
 2713 0cc8 00000000 		.word	pxCurrentTCB
 2714              		.cfi_endproc
 2715              	.LFE28:
 2716              		.size	vTaskSwitchContext, .-vTaskSwitchContext
 2717              		.align	1
 2718              		.global	vTaskPlaceOnEventList
 2719              		.syntax unified
 2720              		.thumb
 2721              		.thumb_func
 2722              		.fpu softvfp
 2723              		.type	vTaskPlaceOnEventList, %function
 2724              	vTaskPlaceOnEventList:
 2725              	.LFB29:
3062:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3063:FreeRTOS/Source/tasks.c **** 
3064:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
3065:FreeRTOS/Source/tasks.c **** {
 2726              		.loc 1 3065 0
 2727              		.cfi_startproc
 2728              		@ args = 0, pretend = 0, frame = 8
 2729              		@ frame_needed = 1, uses_anonymous_args = 0
 2730 0ccc 80B5     		push	{r7, lr}
 2731              		.cfi_def_cfa_offset 8
 2732              		.cfi_offset 7, -8
 2733              		.cfi_offset 14, -4
 2734 0cce 82B0     		sub	sp, sp, #8
 2735              		.cfi_def_cfa_offset 16
 2736 0cd0 00AF     		add	r7, sp, #0
 2737              		.cfi_def_cfa_register 7
 2738 0cd2 7860     		str	r0, [r7, #4]
 2739 0cd4 3960     		str	r1, [r7]
3066:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
3067:FreeRTOS/Source/tasks.c **** 
3068:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
3069:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
3070:FreeRTOS/Source/tasks.c **** 
3071:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
3072:FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
3073:FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
3074:FreeRTOS/Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
3075:FreeRTOS/Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2740              		.loc 1 3075 0
 2741 0cd6 074B     		ldr	r3, .L182
 2742 0cd8 1B68     		ldr	r3, [r3]
 2743 0cda 1833     		adds	r3, r3, #24
 2744 0cdc 1946     		mov	r1, r3
 2745 0cde 7868     		ldr	r0, [r7, #4]
 2746 0ce0 FFF7FEFF 		bl	vListInsert
3076:FreeRTOS/Source/tasks.c **** 
3077:FreeRTOS/Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2747              		.loc 1 3077 0
 2748 0ce4 0121     		movs	r1, #1
ARM GAS  /tmp/cckqXCjj.s 			page 108


 2749 0ce6 3868     		ldr	r0, [r7]
 2750 0ce8 00F0B2FC 		bl	prvAddCurrentTaskToDelayedList
3078:FreeRTOS/Source/tasks.c **** }
 2751              		.loc 1 3078 0
 2752 0cec 00BF     		nop
 2753 0cee 0837     		adds	r7, r7, #8
 2754              		.cfi_def_cfa_offset 8
 2755 0cf0 BD46     		mov	sp, r7
 2756              		.cfi_def_cfa_register 13
 2757              		@ sp needed
 2758 0cf2 80BD     		pop	{r7, pc}
 2759              	.L183:
 2760              		.align	2
 2761              	.L182:
 2762 0cf4 00000000 		.word	pxCurrentTCB
 2763              		.cfi_endproc
 2764              	.LFE29:
 2765              		.size	vTaskPlaceOnEventList, .-vTaskPlaceOnEventList
 2766              		.align	1
 2767              		.global	vTaskPlaceOnUnorderedEventList
 2768              		.syntax unified
 2769              		.thumb
 2770              		.thumb_func
 2771              		.fpu softvfp
 2772              		.type	vTaskPlaceOnUnorderedEventList, %function
 2773              	vTaskPlaceOnUnorderedEventList:
 2774              	.LFB30:
3079:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3080:FreeRTOS/Source/tasks.c **** 
3081:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
3082:FreeRTOS/Source/tasks.c **** {
 2775              		.loc 1 3082 0
 2776              		.cfi_startproc
 2777              		@ args = 0, pretend = 0, frame = 16
 2778              		@ frame_needed = 1, uses_anonymous_args = 0
 2779 0cf8 80B5     		push	{r7, lr}
 2780              		.cfi_def_cfa_offset 8
 2781              		.cfi_offset 7, -8
 2782              		.cfi_offset 14, -4
 2783 0cfa 84B0     		sub	sp, sp, #16
 2784              		.cfi_def_cfa_offset 24
 2785 0cfc 00AF     		add	r7, sp, #0
 2786              		.cfi_def_cfa_register 7
 2787 0cfe F860     		str	r0, [r7, #12]
 2788 0d00 B960     		str	r1, [r7, #8]
 2789 0d02 7A60     		str	r2, [r7, #4]
3083:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
3084:FreeRTOS/Source/tasks.c **** 
3085:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3086:FreeRTOS/Source/tasks.c **** 	the event groups implementation. */
3087:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
3088:FreeRTOS/Source/tasks.c **** 
3089:FreeRTOS/Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
3090:FreeRTOS/Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
3091:FreeRTOS/Source/tasks.c **** 	task that is not in the Blocked state. */
3092:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
 2790              		.loc 1 3092 0
ARM GAS  /tmp/cckqXCjj.s 			page 109


 2791 0d04 0A4B     		ldr	r3, .L185
 2792 0d06 1B68     		ldr	r3, [r3]
 2793 0d08 BA68     		ldr	r2, [r7, #8]
 2794 0d0a 42F00042 		orr	r2, r2, #-2147483648
 2795 0d0e 9A61     		str	r2, [r3, #24]
3093:FreeRTOS/Source/tasks.c **** 
3094:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
3095:FreeRTOS/Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
3096:FreeRTOS/Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
3097:FreeRTOS/Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
3098:FreeRTOS/Source/tasks.c **** 	the task level). */
3099:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2796              		.loc 1 3099 0
 2797 0d10 074B     		ldr	r3, .L185
 2798 0d12 1B68     		ldr	r3, [r3]
 2799 0d14 1833     		adds	r3, r3, #24
 2800 0d16 1946     		mov	r1, r3
 2801 0d18 F868     		ldr	r0, [r7, #12]
 2802 0d1a FFF7FEFF 		bl	vListInsertEnd
3100:FreeRTOS/Source/tasks.c **** 
3101:FreeRTOS/Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2803              		.loc 1 3101 0
 2804 0d1e 0121     		movs	r1, #1
 2805 0d20 7868     		ldr	r0, [r7, #4]
 2806 0d22 00F095FC 		bl	prvAddCurrentTaskToDelayedList
3102:FreeRTOS/Source/tasks.c **** }
 2807              		.loc 1 3102 0
 2808 0d26 00BF     		nop
 2809 0d28 1037     		adds	r7, r7, #16
 2810              		.cfi_def_cfa_offset 8
 2811 0d2a BD46     		mov	sp, r7
 2812              		.cfi_def_cfa_register 13
 2813              		@ sp needed
 2814 0d2c 80BD     		pop	{r7, pc}
 2815              	.L186:
 2816 0d2e 00BF     		.align	2
 2817              	.L185:
 2818 0d30 00000000 		.word	pxCurrentTCB
 2819              		.cfi_endproc
 2820              	.LFE30:
 2821              		.size	vTaskPlaceOnUnorderedEventList, .-vTaskPlaceOnUnorderedEventList
 2822              		.align	1
 2823              		.global	xTaskRemoveFromEventList
 2824              		.syntax unified
 2825              		.thumb
 2826              		.thumb_func
 2827              		.fpu softvfp
 2828              		.type	xTaskRemoveFromEventList, %function
 2829              	xTaskRemoveFromEventList:
 2830              	.LFB31:
3103:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3104:FreeRTOS/Source/tasks.c **** 
3105:FreeRTOS/Source/tasks.c **** #if( configUSE_TIMERS == 1 )
3106:FreeRTOS/Source/tasks.c **** 
3107:FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
3108:FreeRTOS/Source/tasks.c **** 	{
3109:FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
ARM GAS  /tmp/cckqXCjj.s 			page 110


3110:FreeRTOS/Source/tasks.c **** 
3111:FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
3112:FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
3113:FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
3114:FreeRTOS/Source/tasks.c **** 		it should be called with the scheduler suspended. */
3115:FreeRTOS/Source/tasks.c **** 
3116:FreeRTOS/Source/tasks.c **** 
3117:FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
3118:FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
3119:FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
3120:FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
3121:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
3122:FreeRTOS/Source/tasks.c **** 
3123:FreeRTOS/Source/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
3124:FreeRTOS/Source/tasks.c **** 		value that will be recognised as an indefinite delay inside the
3125:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
3126:FreeRTOS/Source/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
3127:FreeRTOS/Source/tasks.c **** 		{
3128:FreeRTOS/Source/tasks.c **** 			xTicksToWait = portMAX_DELAY;
3129:FreeRTOS/Source/tasks.c **** 		}
3130:FreeRTOS/Source/tasks.c **** 
3131:FreeRTOS/Source/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3132:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
3133:FreeRTOS/Source/tasks.c **** 	}
3134:FreeRTOS/Source/tasks.c **** 
3135:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
3136:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3137:FreeRTOS/Source/tasks.c **** 
3138:FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3139:FreeRTOS/Source/tasks.c **** {
 2831              		.loc 1 3139 0
 2832              		.cfi_startproc
 2833              		@ args = 0, pretend = 0, frame = 16
 2834              		@ frame_needed = 1, uses_anonymous_args = 0
 2835 0d34 80B5     		push	{r7, lr}
 2836              		.cfi_def_cfa_offset 8
 2837              		.cfi_offset 7, -8
 2838              		.cfi_offset 14, -4
 2839 0d36 84B0     		sub	sp, sp, #16
 2840              		.cfi_def_cfa_offset 24
 2841 0d38 00AF     		add	r7, sp, #0
 2842              		.cfi_def_cfa_register 7
 2843 0d3a 7860     		str	r0, [r7, #4]
3140:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
3141:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
3142:FreeRTOS/Source/tasks.c **** 
3143:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3144:FreeRTOS/Source/tasks.c **** 	called from a critical section within an ISR. */
3145:FreeRTOS/Source/tasks.c **** 
3146:FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
3147:FreeRTOS/Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
3148:FreeRTOS/Source/tasks.c **** 	the delayed list, and add it to the ready list.
3149:FreeRTOS/Source/tasks.c **** 
3150:FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
3151:FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
3152:FreeRTOS/Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
3153:FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/cckqXCjj.s 			page 111


3154:FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
3155:FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
3156:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this 
 2844              		.loc 1 3156 0
 2845 0d3c 7B68     		ldr	r3, [r7, #4]
 2846 0d3e DB68     		ldr	r3, [r3, #12]
 2847 0d40 DB68     		ldr	r3, [r3, #12]
 2848 0d42 BB60     		str	r3, [r7, #8]
3157:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3158:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2849              		.loc 1 3158 0
 2850 0d44 BB68     		ldr	r3, [r7, #8]
 2851 0d46 1833     		adds	r3, r3, #24
 2852 0d48 1846     		mov	r0, r3
 2853 0d4a FFF7FEFF 		bl	uxListRemove
3159:FreeRTOS/Source/tasks.c **** 
3160:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2854              		.loc 1 3160 0
 2855 0d4e 1D4B     		ldr	r3, .L193
 2856 0d50 1B68     		ldr	r3, [r3]
 2857 0d52 002B     		cmp	r3, #0
 2858 0d54 1CD1     		bne	.L188
3161:FreeRTOS/Source/tasks.c **** 	{
3162:FreeRTOS/Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 2859              		.loc 1 3162 0
 2860 0d56 BB68     		ldr	r3, [r7, #8]
 2861 0d58 0433     		adds	r3, r3, #4
 2862 0d5a 1846     		mov	r0, r3
 2863 0d5c FFF7FEFF 		bl	uxListRemove
3163:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2864              		.loc 1 3163 0
 2865 0d60 BB68     		ldr	r3, [r7, #8]
 2866 0d62 DB6A     		ldr	r3, [r3, #44]
 2867 0d64 0122     		movs	r2, #1
 2868 0d66 9A40     		lsls	r2, r2, r3
 2869 0d68 174B     		ldr	r3, .L193+4
 2870 0d6a 1B68     		ldr	r3, [r3]
 2871 0d6c 1343     		orrs	r3, r3, r2
 2872 0d6e 164A     		ldr	r2, .L193+4
 2873 0d70 1360     		str	r3, [r2]
 2874 0d72 BB68     		ldr	r3, [r7, #8]
 2875 0d74 DA6A     		ldr	r2, [r3, #44]
 2876 0d76 1346     		mov	r3, r2
 2877 0d78 9B00     		lsls	r3, r3, #2
 2878 0d7a 1344     		add	r3, r3, r2
 2879 0d7c 9B00     		lsls	r3, r3, #2
 2880 0d7e 134A     		ldr	r2, .L193+8
 2881 0d80 1A44     		add	r2, r2, r3
 2882 0d82 BB68     		ldr	r3, [r7, #8]
 2883 0d84 0433     		adds	r3, r3, #4
 2884 0d86 1946     		mov	r1, r3
 2885 0d88 1046     		mov	r0, r2
 2886 0d8a FFF7FEFF 		bl	vListInsertEnd
 2887 0d8e 05E0     		b	.L189
 2888              	.L188:
3164:FreeRTOS/Source/tasks.c **** 
3165:FreeRTOS/Source/tasks.c **** 		#if( configUSE_TICKLESS_IDLE != 0 )
ARM GAS  /tmp/cckqXCjj.s 			page 112


3166:FreeRTOS/Source/tasks.c **** 		{
3167:FreeRTOS/Source/tasks.c **** 			/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3168:FreeRTOS/Source/tasks.c **** 			might be set to the blocked task's time out time.  If the task is
3169:FreeRTOS/Source/tasks.c **** 			unblocked for a reason other than a timeout xNextTaskUnblockTime is
3170:FreeRTOS/Source/tasks.c **** 			normally left unchanged, because it is automatically reset to a new
3171:FreeRTOS/Source/tasks.c **** 			value when the tick count equals xNextTaskUnblockTime.  However if
3172:FreeRTOS/Source/tasks.c **** 			tickless idling is used it might be more important to enter sleep mode
3173:FreeRTOS/Source/tasks.c **** 			at the earliest possible time - so reset xNextTaskUnblockTime here to
3174:FreeRTOS/Source/tasks.c **** 			ensure it is updated at the earliest possible time. */
3175:FreeRTOS/Source/tasks.c **** 			prvResetNextTaskUnblockTime();
3176:FreeRTOS/Source/tasks.c **** 		}
3177:FreeRTOS/Source/tasks.c **** 		#endif
3178:FreeRTOS/Source/tasks.c **** 	}
3179:FreeRTOS/Source/tasks.c **** 	else
3180:FreeRTOS/Source/tasks.c **** 	{
3181:FreeRTOS/Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
3182:FreeRTOS/Source/tasks.c **** 		pending until the scheduler is resumed. */
3183:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2889              		.loc 1 3183 0
 2890 0d90 BB68     		ldr	r3, [r7, #8]
 2891 0d92 1833     		adds	r3, r3, #24
 2892 0d94 1946     		mov	r1, r3
 2893 0d96 0E48     		ldr	r0, .L193+12
 2894 0d98 FFF7FEFF 		bl	vListInsertEnd
 2895              	.L189:
3184:FreeRTOS/Source/tasks.c **** 	}
3185:FreeRTOS/Source/tasks.c **** 
3186:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2896              		.loc 1 3186 0
 2897 0d9c BB68     		ldr	r3, [r7, #8]
 2898 0d9e DA6A     		ldr	r2, [r3, #44]
 2899 0da0 0C4B     		ldr	r3, .L193+16
 2900 0da2 1B68     		ldr	r3, [r3]
 2901 0da4 DB6A     		ldr	r3, [r3, #44]
 2902 0da6 9A42     		cmp	r2, r3
 2903 0da8 05D9     		bls	.L190
3187:FreeRTOS/Source/tasks.c **** 	{
3188:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
3189:FreeRTOS/Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
3190:FreeRTOS/Source/tasks.c **** 		it should force a context switch now. */
3191:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
 2904              		.loc 1 3191 0
 2905 0daa 0123     		movs	r3, #1
 2906 0dac FB60     		str	r3, [r7, #12]
3192:FreeRTOS/Source/tasks.c **** 
3193:FreeRTOS/Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
3194:FreeRTOS/Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3195:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
 2907              		.loc 1 3195 0
 2908 0dae 0A4B     		ldr	r3, .L193+20
 2909 0db0 0122     		movs	r2, #1
 2910 0db2 1A60     		str	r2, [r3]
 2911 0db4 01E0     		b	.L191
 2912              	.L190:
3196:FreeRTOS/Source/tasks.c **** 	}
3197:FreeRTOS/Source/tasks.c **** 	else
3198:FreeRTOS/Source/tasks.c **** 	{
ARM GAS  /tmp/cckqXCjj.s 			page 113


3199:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
 2913              		.loc 1 3199 0
 2914 0db6 0023     		movs	r3, #0
 2915 0db8 FB60     		str	r3, [r7, #12]
 2916              	.L191:
3200:FreeRTOS/Source/tasks.c **** 	}
3201:FreeRTOS/Source/tasks.c **** 
3202:FreeRTOS/Source/tasks.c **** 	return xReturn;
 2917              		.loc 1 3202 0
 2918 0dba FB68     		ldr	r3, [r7, #12]
3203:FreeRTOS/Source/tasks.c **** }
 2919              		.loc 1 3203 0
 2920 0dbc 1846     		mov	r0, r3
 2921 0dbe 1037     		adds	r7, r7, #16
 2922              		.cfi_def_cfa_offset 8
 2923 0dc0 BD46     		mov	sp, r7
 2924              		.cfi_def_cfa_register 13
 2925              		@ sp needed
 2926 0dc2 80BD     		pop	{r7, pc}
 2927              	.L194:
 2928              		.align	2
 2929              	.L193:
 2930 0dc4 00010000 		.word	uxSchedulerSuspended
 2931 0dc8 E0000000 		.word	uxTopReadyPriority
 2932 0dcc 04000000 		.word	pxReadyTasksLists
 2933 0dd0 98000000 		.word	xPendingReadyList
 2934 0dd4 00000000 		.word	pxCurrentTCB
 2935 0dd8 EC000000 		.word	xYieldPending
 2936              		.cfi_endproc
 2937              	.LFE31:
 2938              		.size	xTaskRemoveFromEventList, .-xTaskRemoveFromEventList
 2939              		.align	1
 2940              		.global	vTaskRemoveFromUnorderedEventList
 2941              		.syntax unified
 2942              		.thumb
 2943              		.thumb_func
 2944              		.fpu softvfp
 2945              		.type	vTaskRemoveFromUnorderedEventList, %function
 2946              	vTaskRemoveFromUnorderedEventList:
 2947              	.LFB32:
3204:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3205:FreeRTOS/Source/tasks.c **** 
3206:FreeRTOS/Source/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
3207:FreeRTOS/Source/tasks.c **** {
 2948              		.loc 1 3207 0
 2949              		.cfi_startproc
 2950              		@ args = 0, pretend = 0, frame = 16
 2951              		@ frame_needed = 1, uses_anonymous_args = 0
 2952 0ddc 80B5     		push	{r7, lr}
 2953              		.cfi_def_cfa_offset 8
 2954              		.cfi_offset 7, -8
 2955              		.cfi_offset 14, -4
 2956 0dde 84B0     		sub	sp, sp, #16
 2957              		.cfi_def_cfa_offset 24
 2958 0de0 00AF     		add	r7, sp, #0
 2959              		.cfi_def_cfa_register 7
 2960 0de2 7860     		str	r0, [r7, #4]
ARM GAS  /tmp/cckqXCjj.s 			page 114


 2961 0de4 3960     		str	r1, [r7]
3208:FreeRTOS/Source/tasks.c **** TCB_t *pxUnblockedTCB;
3209:FreeRTOS/Source/tasks.c **** 
3210:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3211:FreeRTOS/Source/tasks.c **** 	the event flags implementation. */
3212:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
3213:FreeRTOS/Source/tasks.c **** 
3214:FreeRTOS/Source/tasks.c **** 	/* Store the new item value in the event list. */
3215:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 2962              		.loc 1 3215 0
 2963 0de6 3B68     		ldr	r3, [r7]
 2964 0de8 43F00042 		orr	r2, r3, #-2147483648
 2965 0dec 7B68     		ldr	r3, [r7, #4]
 2966 0dee 1A60     		str	r2, [r3]
3216:FreeRTOS/Source/tasks.c **** 
3217:FreeRTOS/Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
3218:FreeRTOS/Source/tasks.c **** 	event flags. */
3219:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this 
 2967              		.loc 1 3219 0
 2968 0df0 7B68     		ldr	r3, [r7, #4]
 2969 0df2 DB68     		ldr	r3, [r3, #12]
 2970 0df4 FB60     		str	r3, [r7, #12]
3220:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
3221:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 2971              		.loc 1 3221 0
 2972 0df6 7868     		ldr	r0, [r7, #4]
 2973 0df8 FFF7FEFF 		bl	uxListRemove
3222:FreeRTOS/Source/tasks.c **** 
3223:FreeRTOS/Source/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
3224:FreeRTOS/Source/tasks.c **** 	{
3225:FreeRTOS/Source/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
3226:FreeRTOS/Source/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
3227:FreeRTOS/Source/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
3228:FreeRTOS/Source/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
3229:FreeRTOS/Source/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
3230:FreeRTOS/Source/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
3231:FreeRTOS/Source/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
3232:FreeRTOS/Source/tasks.c **** 		ensure it is updated at the earliest possible time. */
3233:FreeRTOS/Source/tasks.c **** 		prvResetNextTaskUnblockTime();
3234:FreeRTOS/Source/tasks.c **** 	}
3235:FreeRTOS/Source/tasks.c **** 	#endif
3236:FreeRTOS/Source/tasks.c **** 
3237:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
3238:FreeRTOS/Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
3239:FreeRTOS/Source/tasks.c **** 	lists. */
3240:FreeRTOS/Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 2974              		.loc 1 3240 0
 2975 0dfc FB68     		ldr	r3, [r7, #12]
 2976 0dfe 0433     		adds	r3, r3, #4
 2977 0e00 1846     		mov	r0, r3
 2978 0e02 FFF7FEFF 		bl	uxListRemove
3241:FreeRTOS/Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 2979              		.loc 1 3241 0
 2980 0e06 FB68     		ldr	r3, [r7, #12]
 2981 0e08 DB6A     		ldr	r3, [r3, #44]
 2982 0e0a 0122     		movs	r2, #1
 2983 0e0c 9A40     		lsls	r2, r2, r3
ARM GAS  /tmp/cckqXCjj.s 			page 115


 2984 0e0e 104B     		ldr	r3, .L198
 2985 0e10 1B68     		ldr	r3, [r3]
 2986 0e12 1343     		orrs	r3, r3, r2
 2987 0e14 0E4A     		ldr	r2, .L198
 2988 0e16 1360     		str	r3, [r2]
 2989 0e18 FB68     		ldr	r3, [r7, #12]
 2990 0e1a DA6A     		ldr	r2, [r3, #44]
 2991 0e1c 1346     		mov	r3, r2
 2992 0e1e 9B00     		lsls	r3, r3, #2
 2993 0e20 1344     		add	r3, r3, r2
 2994 0e22 9B00     		lsls	r3, r3, #2
 2995 0e24 0B4A     		ldr	r2, .L198+4
 2996 0e26 1A44     		add	r2, r2, r3
 2997 0e28 FB68     		ldr	r3, [r7, #12]
 2998 0e2a 0433     		adds	r3, r3, #4
 2999 0e2c 1946     		mov	r1, r3
 3000 0e2e 1046     		mov	r0, r2
 3001 0e30 FFF7FEFF 		bl	vListInsertEnd
3242:FreeRTOS/Source/tasks.c **** 
3243:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3002              		.loc 1 3243 0
 3003 0e34 FB68     		ldr	r3, [r7, #12]
 3004 0e36 DA6A     		ldr	r2, [r3, #44]
 3005 0e38 074B     		ldr	r3, .L198+8
 3006 0e3a 1B68     		ldr	r3, [r3]
 3007 0e3c DB6A     		ldr	r3, [r3, #44]
 3008 0e3e 9A42     		cmp	r2, r3
 3009 0e40 02D9     		bls	.L197
3244:FreeRTOS/Source/tasks.c **** 	{
3245:FreeRTOS/Source/tasks.c **** 		/* The unblocked task has a priority above that of the calling task, so
3246:FreeRTOS/Source/tasks.c **** 		a context switch is required.  This function is called with the
3247:FreeRTOS/Source/tasks.c **** 		scheduler suspended so xYieldPending is set so the context switch
3248:FreeRTOS/Source/tasks.c **** 		occurs immediately that the scheduler is resumed (unsuspended). */
3249:FreeRTOS/Source/tasks.c **** 		xYieldPending = pdTRUE;
 3010              		.loc 1 3249 0
 3011 0e42 064B     		ldr	r3, .L198+12
 3012 0e44 0122     		movs	r2, #1
 3013 0e46 1A60     		str	r2, [r3]
 3014              	.L197:
3250:FreeRTOS/Source/tasks.c **** 	}
3251:FreeRTOS/Source/tasks.c **** }
 3015              		.loc 1 3251 0
 3016 0e48 00BF     		nop
 3017 0e4a 1037     		adds	r7, r7, #16
 3018              		.cfi_def_cfa_offset 8
 3019 0e4c BD46     		mov	sp, r7
 3020              		.cfi_def_cfa_register 13
 3021              		@ sp needed
 3022 0e4e 80BD     		pop	{r7, pc}
 3023              	.L199:
 3024              		.align	2
 3025              	.L198:
 3026 0e50 E0000000 		.word	uxTopReadyPriority
 3027 0e54 04000000 		.word	pxReadyTasksLists
 3028 0e58 00000000 		.word	pxCurrentTCB
 3029 0e5c EC000000 		.word	xYieldPending
 3030              		.cfi_endproc
ARM GAS  /tmp/cckqXCjj.s 			page 116


 3031              	.LFE32:
 3032              		.size	vTaskRemoveFromUnorderedEventList, .-vTaskRemoveFromUnorderedEventList
 3033              		.align	1
 3034              		.global	vTaskSetTimeOutState
 3035              		.syntax unified
 3036              		.thumb
 3037              		.thumb_func
 3038              		.fpu softvfp
 3039              		.type	vTaskSetTimeOutState, %function
 3040              	vTaskSetTimeOutState:
 3041              	.LFB33:
3252:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3253:FreeRTOS/Source/tasks.c **** 
3254:FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3255:FreeRTOS/Source/tasks.c **** {
 3042              		.loc 1 3255 0
 3043              		.cfi_startproc
 3044              		@ args = 0, pretend = 0, frame = 8
 3045              		@ frame_needed = 1, uses_anonymous_args = 0
 3046 0e60 80B5     		push	{r7, lr}
 3047              		.cfi_def_cfa_offset 8
 3048              		.cfi_offset 7, -8
 3049              		.cfi_offset 14, -4
 3050 0e62 82B0     		sub	sp, sp, #8
 3051              		.cfi_def_cfa_offset 16
 3052 0e64 00AF     		add	r7, sp, #0
 3053              		.cfi_def_cfa_register 7
 3054 0e66 7860     		str	r0, [r7, #4]
3256:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
3257:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 3055              		.loc 1 3257 0
 3056 0e68 FFF7FEFF 		bl	vPortEnterCritical
3258:FreeRTOS/Source/tasks.c **** 	{
3259:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xOverflowCount = xNumOfOverflows;
 3057              		.loc 1 3259 0
 3058 0e6c 064B     		ldr	r3, .L201
 3059 0e6e 1A68     		ldr	r2, [r3]
 3060 0e70 7B68     		ldr	r3, [r7, #4]
 3061 0e72 1A60     		str	r2, [r3]
3260:FreeRTOS/Source/tasks.c **** 		pxTimeOut->xTimeOnEntering = xTickCount;
 3062              		.loc 1 3260 0
 3063 0e74 054B     		ldr	r3, .L201+4
 3064 0e76 1A68     		ldr	r2, [r3]
 3065 0e78 7B68     		ldr	r3, [r7, #4]
 3066 0e7a 5A60     		str	r2, [r3, #4]
3261:FreeRTOS/Source/tasks.c **** 	}
3262:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 3067              		.loc 1 3262 0
 3068 0e7c FFF7FEFF 		bl	vPortExitCritical
3263:FreeRTOS/Source/tasks.c **** }
 3069              		.loc 1 3263 0
 3070 0e80 00BF     		nop
 3071 0e82 0837     		adds	r7, r7, #8
 3072              		.cfi_def_cfa_offset 8
 3073 0e84 BD46     		mov	sp, r7
 3074              		.cfi_def_cfa_register 13
 3075              		@ sp needed
ARM GAS  /tmp/cckqXCjj.s 			page 117


 3076 0e86 80BD     		pop	{r7, pc}
 3077              	.L202:
 3078              		.align	2
 3079              	.L201:
 3080 0e88 F0000000 		.word	xNumOfOverflows
 3081 0e8c DC000000 		.word	xTickCount
 3082              		.cfi_endproc
 3083              	.LFE33:
 3084              		.size	vTaskSetTimeOutState, .-vTaskSetTimeOutState
 3085              		.align	1
 3086              		.global	vTaskInternalSetTimeOutState
 3087              		.syntax unified
 3088              		.thumb
 3089              		.thumb_func
 3090              		.fpu softvfp
 3091              		.type	vTaskInternalSetTimeOutState, %function
 3092              	vTaskInternalSetTimeOutState:
 3093              	.LFB34:
3264:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3265:FreeRTOS/Source/tasks.c **** 
3266:FreeRTOS/Source/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3267:FreeRTOS/Source/tasks.c **** {
 3094              		.loc 1 3267 0
 3095              		.cfi_startproc
 3096              		@ args = 0, pretend = 0, frame = 8
 3097              		@ frame_needed = 1, uses_anonymous_args = 0
 3098              		@ link register save eliminated.
 3099 0e90 80B4     		push	{r7}
 3100              		.cfi_def_cfa_offset 4
 3101              		.cfi_offset 7, -4
 3102 0e92 83B0     		sub	sp, sp, #12
 3103              		.cfi_def_cfa_offset 16
 3104 0e94 00AF     		add	r7, sp, #0
 3105              		.cfi_def_cfa_register 7
 3106 0e96 7860     		str	r0, [r7, #4]
3268:FreeRTOS/Source/tasks.c **** 	/* For internal use only as it does not use a critical section. */
3269:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 3107              		.loc 1 3269 0
 3108 0e98 064B     		ldr	r3, .L204
 3109 0e9a 1A68     		ldr	r2, [r3]
 3110 0e9c 7B68     		ldr	r3, [r7, #4]
 3111 0e9e 1A60     		str	r2, [r3]
3270:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3112              		.loc 1 3270 0
 3113 0ea0 054B     		ldr	r3, .L204+4
 3114 0ea2 1A68     		ldr	r2, [r3]
 3115 0ea4 7B68     		ldr	r3, [r7, #4]
 3116 0ea6 5A60     		str	r2, [r3, #4]
3271:FreeRTOS/Source/tasks.c **** }
 3117              		.loc 1 3271 0
 3118 0ea8 00BF     		nop
 3119 0eaa 0C37     		adds	r7, r7, #12
 3120              		.cfi_def_cfa_offset 4
 3121 0eac BD46     		mov	sp, r7
 3122              		.cfi_def_cfa_register 13
 3123              		@ sp needed
 3124 0eae 80BC     		pop	{r7}
ARM GAS  /tmp/cckqXCjj.s 			page 118


 3125              		.cfi_restore 7
 3126              		.cfi_def_cfa_offset 0
 3127 0eb0 7047     		bx	lr
 3128              	.L205:
 3129 0eb2 00BF     		.align	2
 3130              	.L204:
 3131 0eb4 F0000000 		.word	xNumOfOverflows
 3132 0eb8 DC000000 		.word	xTickCount
 3133              		.cfi_endproc
 3134              	.LFE34:
 3135              		.size	vTaskInternalSetTimeOutState, .-vTaskInternalSetTimeOutState
 3136              		.align	1
 3137              		.global	xTaskCheckForTimeOut
 3138              		.syntax unified
 3139              		.thumb
 3140              		.thumb_func
 3141              		.fpu softvfp
 3142              		.type	xTaskCheckForTimeOut, %function
 3143              	xTaskCheckForTimeOut:
 3144              	.LFB35:
3272:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3273:FreeRTOS/Source/tasks.c **** 
3274:FreeRTOS/Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3275:FreeRTOS/Source/tasks.c **** {
 3145              		.loc 1 3275 0
 3146              		.cfi_startproc
 3147              		@ args = 0, pretend = 0, frame = 24
 3148              		@ frame_needed = 1, uses_anonymous_args = 0
 3149 0ebc 80B5     		push	{r7, lr}
 3150              		.cfi_def_cfa_offset 8
 3151              		.cfi_offset 7, -8
 3152              		.cfi_offset 14, -4
 3153 0ebe 86B0     		sub	sp, sp, #24
 3154              		.cfi_def_cfa_offset 32
 3155 0ec0 00AF     		add	r7, sp, #0
 3156              		.cfi_def_cfa_register 7
 3157 0ec2 7860     		str	r0, [r7, #4]
 3158 0ec4 3960     		str	r1, [r7]
3276:FreeRTOS/Source/tasks.c **** BaseType_t xReturn;
3277:FreeRTOS/Source/tasks.c **** 
3278:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
3279:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
3280:FreeRTOS/Source/tasks.c **** 
3281:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 3159              		.loc 1 3281 0
 3160 0ec6 FFF7FEFF 		bl	vPortEnterCritical
 3161              	.LBB47:
3282:FreeRTOS/Source/tasks.c **** 	{
3283:FreeRTOS/Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
3284:FreeRTOS/Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
 3162              		.loc 1 3284 0
 3163 0eca 1D4B     		ldr	r3, .L212
 3164 0ecc 1B68     		ldr	r3, [r3]
 3165 0ece 3B61     		str	r3, [r7, #16]
3285:FreeRTOS/Source/tasks.c **** 		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 3166              		.loc 1 3285 0
 3167 0ed0 7B68     		ldr	r3, [r7, #4]
ARM GAS  /tmp/cckqXCjj.s 			page 119


 3168 0ed2 5B68     		ldr	r3, [r3, #4]
 3169 0ed4 3A69     		ldr	r2, [r7, #16]
 3170 0ed6 D31A     		subs	r3, r2, r3
 3171 0ed8 FB60     		str	r3, [r7, #12]
3286:FreeRTOS/Source/tasks.c **** 
3287:FreeRTOS/Source/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
3288:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
3289:FreeRTOS/Source/tasks.c **** 			{
3290:FreeRTOS/Source/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
3291:FreeRTOS/Source/tasks.c **** 				but has the same result. */
3292:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
3293:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
3294:FreeRTOS/Source/tasks.c **** 			}
3295:FreeRTOS/Source/tasks.c **** 			else
3296:FreeRTOS/Source/tasks.c **** 		#endif
3297:FreeRTOS/Source/tasks.c **** 
3298:FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3299:FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 3172              		.loc 1 3299 0
 3173 0eda 3B68     		ldr	r3, [r7]
 3174 0edc 1B68     		ldr	r3, [r3]
 3175 0ede B3F1FF3F 		cmp	r3, #-1
 3176 0ee2 02D1     		bne	.L207
3300:FreeRTOS/Source/tasks.c **** 			{
3301:FreeRTOS/Source/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3302:FreeRTOS/Source/tasks.c **** 				specified is the maximum block time then the task should block
3303:FreeRTOS/Source/tasks.c **** 				indefinitely, and therefore never time out. */
3304:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
 3177              		.loc 1 3304 0
 3178 0ee4 0023     		movs	r3, #0
 3179 0ee6 7B61     		str	r3, [r7, #20]
 3180 0ee8 23E0     		b	.L208
 3181              	.L207:
3305:FreeRTOS/Source/tasks.c **** 			}
3306:FreeRTOS/Source/tasks.c **** 			else
3307:FreeRTOS/Source/tasks.c **** 		#endif
3308:FreeRTOS/Source/tasks.c **** 
3309:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 3182              		.loc 1 3309 0
 3183 0eea 7B68     		ldr	r3, [r7, #4]
 3184 0eec 1A68     		ldr	r2, [r3]
 3185 0eee 154B     		ldr	r3, .L212+4
 3186 0ef0 1B68     		ldr	r3, [r3]
 3187 0ef2 9A42     		cmp	r2, r3
 3188 0ef4 07D0     		beq	.L209
 3189              		.loc 1 3309 0 is_stmt 0 discriminator 1
 3190 0ef6 7B68     		ldr	r3, [r7, #4]
 3191 0ef8 5A68     		ldr	r2, [r3, #4]
 3192 0efa 3B69     		ldr	r3, [r7, #16]
 3193 0efc 9A42     		cmp	r2, r3
 3194 0efe 02D8     		bhi	.L209
3310:FreeRTOS/Source/tasks.c **** 		{
3311:FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which
3312:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
3313:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
3314:FreeRTOS/Source/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
3315:FreeRTOS/Source/tasks.c **** 			was called. */
ARM GAS  /tmp/cckqXCjj.s 			page 120


3316:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 3195              		.loc 1 3316 0 is_stmt 1
 3196 0f00 0123     		movs	r3, #1
 3197 0f02 7B61     		str	r3, [r7, #20]
 3198 0f04 15E0     		b	.L208
 3199              	.L209:
3317:FreeRTOS/Source/tasks.c **** 		}
3318:FreeRTOS/Source/tasks.c **** 		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with som
 3200              		.loc 1 3318 0
 3201 0f06 3B68     		ldr	r3, [r7]
 3202 0f08 1A68     		ldr	r2, [r3]
 3203 0f0a FB68     		ldr	r3, [r7, #12]
 3204 0f0c 9A42     		cmp	r2, r3
 3205 0f0e 0BD9     		bls	.L210
3319:FreeRTOS/Source/tasks.c **** 		{
3320:FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
3321:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= xElapsedTime;
 3206              		.loc 1 3321 0
 3207 0f10 3B68     		ldr	r3, [r7]
 3208 0f12 1A68     		ldr	r2, [r3]
 3209 0f14 FB68     		ldr	r3, [r7, #12]
 3210 0f16 D21A     		subs	r2, r2, r3
 3211 0f18 3B68     		ldr	r3, [r7]
 3212 0f1a 1A60     		str	r2, [r3]
3322:FreeRTOS/Source/tasks.c **** 			vTaskInternalSetTimeOutState( pxTimeOut );
 3213              		.loc 1 3322 0
 3214 0f1c 7868     		ldr	r0, [r7, #4]
 3215 0f1e FFF7FEFF 		bl	vTaskInternalSetTimeOutState
3323:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 3216              		.loc 1 3323 0
 3217 0f22 0023     		movs	r3, #0
 3218 0f24 7B61     		str	r3, [r7, #20]
 3219 0f26 04E0     		b	.L208
 3220              	.L210:
3324:FreeRTOS/Source/tasks.c **** 		}
3325:FreeRTOS/Source/tasks.c **** 		else
3326:FreeRTOS/Source/tasks.c **** 		{
3327:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait = 0;
 3221              		.loc 1 3327 0
 3222 0f28 3B68     		ldr	r3, [r7]
 3223 0f2a 0022     		movs	r2, #0
 3224 0f2c 1A60     		str	r2, [r3]
3328:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 3225              		.loc 1 3328 0
 3226 0f2e 0123     		movs	r3, #1
 3227 0f30 7B61     		str	r3, [r7, #20]
 3228              	.L208:
 3229              	.LBE47:
3329:FreeRTOS/Source/tasks.c **** 		}
3330:FreeRTOS/Source/tasks.c **** 	}
3331:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 3230              		.loc 1 3331 0
 3231 0f32 FFF7FEFF 		bl	vPortExitCritical
3332:FreeRTOS/Source/tasks.c **** 
3333:FreeRTOS/Source/tasks.c **** 	return xReturn;
 3232              		.loc 1 3333 0
 3233 0f36 7B69     		ldr	r3, [r7, #20]
ARM GAS  /tmp/cckqXCjj.s 			page 121


3334:FreeRTOS/Source/tasks.c **** }
 3234              		.loc 1 3334 0
 3235 0f38 1846     		mov	r0, r3
 3236 0f3a 1837     		adds	r7, r7, #24
 3237              		.cfi_def_cfa_offset 8
 3238 0f3c BD46     		mov	sp, r7
 3239              		.cfi_def_cfa_register 13
 3240              		@ sp needed
 3241 0f3e 80BD     		pop	{r7, pc}
 3242              	.L213:
 3243              		.align	2
 3244              	.L212:
 3245 0f40 DC000000 		.word	xTickCount
 3246 0f44 F0000000 		.word	xNumOfOverflows
 3247              		.cfi_endproc
 3248              	.LFE35:
 3249              		.size	xTaskCheckForTimeOut, .-xTaskCheckForTimeOut
 3250              		.align	1
 3251              		.global	vTaskMissedYield
 3252              		.syntax unified
 3253              		.thumb
 3254              		.thumb_func
 3255              		.fpu softvfp
 3256              		.type	vTaskMissedYield, %function
 3257              	vTaskMissedYield:
 3258              	.LFB36:
3335:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3336:FreeRTOS/Source/tasks.c **** 
3337:FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
3338:FreeRTOS/Source/tasks.c **** {
 3259              		.loc 1 3338 0
 3260              		.cfi_startproc
 3261              		@ args = 0, pretend = 0, frame = 0
 3262              		@ frame_needed = 1, uses_anonymous_args = 0
 3263              		@ link register save eliminated.
 3264 0f48 80B4     		push	{r7}
 3265              		.cfi_def_cfa_offset 4
 3266              		.cfi_offset 7, -4
 3267 0f4a 00AF     		add	r7, sp, #0
 3268              		.cfi_def_cfa_register 7
3339:FreeRTOS/Source/tasks.c **** 	xYieldPending = pdTRUE;
 3269              		.loc 1 3339 0
 3270 0f4c 034B     		ldr	r3, .L215
 3271 0f4e 0122     		movs	r2, #1
 3272 0f50 1A60     		str	r2, [r3]
3340:FreeRTOS/Source/tasks.c **** }
 3273              		.loc 1 3340 0
 3274 0f52 00BF     		nop
 3275 0f54 BD46     		mov	sp, r7
 3276              		.cfi_def_cfa_register 13
 3277              		@ sp needed
 3278 0f56 80BC     		pop	{r7}
 3279              		.cfi_restore 7
 3280              		.cfi_def_cfa_offset 0
 3281 0f58 7047     		bx	lr
 3282              	.L216:
 3283 0f5a 00BF     		.align	2
ARM GAS  /tmp/cckqXCjj.s 			page 122


 3284              	.L215:
 3285 0f5c EC000000 		.word	xYieldPending
 3286              		.cfi_endproc
 3287              	.LFE36:
 3288              		.size	vTaskMissedYield, .-vTaskMissedYield
 3289              		.align	1
 3290              		.syntax unified
 3291              		.thumb
 3292              		.thumb_func
 3293              		.fpu softvfp
 3294              		.type	prvIdleTask, %function
 3295              	prvIdleTask:
 3296              	.LFB37:
3341:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3342:FreeRTOS/Source/tasks.c **** 
3343:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3344:FreeRTOS/Source/tasks.c **** 
3345:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3346:FreeRTOS/Source/tasks.c **** 	{
3347:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3348:FreeRTOS/Source/tasks.c **** 	TCB_t const *pxTCB;
3349:FreeRTOS/Source/tasks.c **** 
3350:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
3351:FreeRTOS/Source/tasks.c **** 		{
3352:FreeRTOS/Source/tasks.c **** 			pxTCB = xTask;
3353:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
3354:FreeRTOS/Source/tasks.c **** 		}
3355:FreeRTOS/Source/tasks.c **** 		else
3356:FreeRTOS/Source/tasks.c **** 		{
3357:FreeRTOS/Source/tasks.c **** 			uxReturn = 0U;
3358:FreeRTOS/Source/tasks.c **** 		}
3359:FreeRTOS/Source/tasks.c **** 
3360:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3361:FreeRTOS/Source/tasks.c **** 	}
3362:FreeRTOS/Source/tasks.c **** 
3363:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3364:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3365:FreeRTOS/Source/tasks.c **** 
3366:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3367:FreeRTOS/Source/tasks.c **** 
3368:FreeRTOS/Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3369:FreeRTOS/Source/tasks.c **** 	{
3370:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
3371:FreeRTOS/Source/tasks.c **** 
3372:FreeRTOS/Source/tasks.c **** 		if( xTask != NULL )
3373:FreeRTOS/Source/tasks.c **** 		{
3374:FreeRTOS/Source/tasks.c **** 			pxTCB = xTask;
3375:FreeRTOS/Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3376:FreeRTOS/Source/tasks.c **** 		}
3377:FreeRTOS/Source/tasks.c **** 	}
3378:FreeRTOS/Source/tasks.c **** 
3379:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3380:FreeRTOS/Source/tasks.c **** 
3381:FreeRTOS/Source/tasks.c **** /*
3382:FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
3383:FreeRTOS/Source/tasks.c ****  * The Idle task.
3384:FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
ARM GAS  /tmp/cckqXCjj.s 			page 123


3385:FreeRTOS/Source/tasks.c ****  *
3386:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3387:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3388:FreeRTOS/Source/tasks.c ****  *
3389:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
3390:FreeRTOS/Source/tasks.c ****  *
3391:FreeRTOS/Source/tasks.c ****  */
3392:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3393:FreeRTOS/Source/tasks.c **** {
 3297              		.loc 1 3393 0
 3298              		.cfi_startproc
 3299              		@ args = 0, pretend = 0, frame = 8
 3300              		@ frame_needed = 1, uses_anonymous_args = 0
 3301 0f60 80B5     		push	{r7, lr}
 3302              		.cfi_def_cfa_offset 8
 3303              		.cfi_offset 7, -8
 3304              		.cfi_offset 14, -4
 3305 0f62 82B0     		sub	sp, sp, #8
 3306              		.cfi_def_cfa_offset 16
 3307 0f64 00AF     		add	r7, sp, #0
 3308              		.cfi_def_cfa_register 7
 3309 0f66 7860     		str	r0, [r7, #4]
 3310              	.L219:
3394:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
3395:FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
3396:FreeRTOS/Source/tasks.c **** 
3397:FreeRTOS/Source/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3398:FreeRTOS/Source/tasks.c **** 	SCHEDULER IS STARTED. **/
3399:FreeRTOS/Source/tasks.c **** 
3400:FreeRTOS/Source/tasks.c **** 	/* In case a task that has a secure context deletes itself, in which case
3401:FreeRTOS/Source/tasks.c **** 	the idle task is responsible for deleting the task's secure context, if
3402:FreeRTOS/Source/tasks.c **** 	any. */
3403:FreeRTOS/Source/tasks.c **** 	portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
3404:FreeRTOS/Source/tasks.c **** 
3405:FreeRTOS/Source/tasks.c **** 	for( ;; )
3406:FreeRTOS/Source/tasks.c **** 	{
3407:FreeRTOS/Source/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3408:FreeRTOS/Source/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3409:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 3311              		.loc 1 3409 0
 3312 0f68 00F052F8 		bl	prvCheckTasksWaitingTermination
3410:FreeRTOS/Source/tasks.c **** 
3411:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3412:FreeRTOS/Source/tasks.c **** 		{
3413:FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3414:FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
3415:FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
3416:FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
3417:FreeRTOS/Source/tasks.c **** 			taskYIELD();
3418:FreeRTOS/Source/tasks.c **** 		}
3419:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3420:FreeRTOS/Source/tasks.c **** 
3421:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3422:FreeRTOS/Source/tasks.c **** 		{
3423:FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
3424:FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3425:FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
ARM GAS  /tmp/cckqXCjj.s 			page 124


3426:FreeRTOS/Source/tasks.c **** 			timeslice.
3427:FreeRTOS/Source/tasks.c **** 
3428:FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
3429:FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3430:FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
3431:FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
3432:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 3313              		.loc 1 3432 0
 3314 0f6c 064B     		ldr	r3, .L220
 3315 0f6e 1B68     		ldr	r3, [r3]
 3316 0f70 012B     		cmp	r3, #1
 3317 0f72 F9D9     		bls	.L219
3433:FreeRTOS/Source/tasks.c **** 			{
3434:FreeRTOS/Source/tasks.c **** 				taskYIELD();
 3318              		.loc 1 3434 0
 3319 0f74 054B     		ldr	r3, .L220+4
 3320 0f76 4FF08052 		mov	r2, #268435456
 3321 0f7a 1A60     		str	r2, [r3]
 3322              		.syntax unified
 3323              	@ 3434 "FreeRTOS/Source/tasks.c" 1
 3324 0f7c BFF34F8F 		dsb
 3325              	@ 0 "" 2
 3326              	@ 3434 "FreeRTOS/Source/tasks.c" 1
 3327 0f80 BFF36F8F 		isb
 3328              	@ 0 "" 2
3409:FreeRTOS/Source/tasks.c **** 
 3329              		.loc 1 3409 0
 3330              		.thumb
 3331              		.syntax unified
 3332 0f84 F0E7     		b	.L219
 3333              	.L221:
 3334 0f86 00BF     		.align	2
 3335              	.L220:
 3336 0f88 04000000 		.word	pxReadyTasksLists
 3337 0f8c 04ED00E0 		.word	-536810236
 3338              		.cfi_endproc
 3339              	.LFE37:
 3340              		.size	prvIdleTask, .-prvIdleTask
 3341              		.align	1
 3342              		.syntax unified
 3343              		.thumb
 3344              		.thumb_func
 3345              		.fpu softvfp
 3346              		.type	prvInitialiseTaskLists, %function
 3347              	prvInitialiseTaskLists:
 3348              	.LFB38:
3435:FreeRTOS/Source/tasks.c **** 			}
3436:FreeRTOS/Source/tasks.c **** 			else
3437:FreeRTOS/Source/tasks.c **** 			{
3438:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3439:FreeRTOS/Source/tasks.c **** 			}
3440:FreeRTOS/Source/tasks.c **** 		}
3441:FreeRTOS/Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3442:FreeRTOS/Source/tasks.c **** 
3443:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3444:FreeRTOS/Source/tasks.c **** 		{
3445:FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
ARM GAS  /tmp/cckqXCjj.s 			page 125


3446:FreeRTOS/Source/tasks.c **** 
3447:FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3448:FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
3449:FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
3450:FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3451:FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3452:FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
3453:FreeRTOS/Source/tasks.c **** 		}
3454:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3455:FreeRTOS/Source/tasks.c **** 
3456:FreeRTOS/Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3457:FreeRTOS/Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3458:FreeRTOS/Source/tasks.c **** 		user defined low power mode	implementations require
3459:FreeRTOS/Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3460:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3461:FreeRTOS/Source/tasks.c **** 		{
3462:FreeRTOS/Source/tasks.c **** 		TickType_t xExpectedIdleTime;
3463:FreeRTOS/Source/tasks.c **** 
3464:FreeRTOS/Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3465:FreeRTOS/Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3466:FreeRTOS/Source/tasks.c **** 			test of the expected idle time is performed without the
3467:FreeRTOS/Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
3468:FreeRTOS/Source/tasks.c **** 			valid. */
3469:FreeRTOS/Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3470:FreeRTOS/Source/tasks.c **** 
3471:FreeRTOS/Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3472:FreeRTOS/Source/tasks.c **** 			{
3473:FreeRTOS/Source/tasks.c **** 				vTaskSuspendAll();
3474:FreeRTOS/Source/tasks.c **** 				{
3475:FreeRTOS/Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3476:FreeRTOS/Source/tasks.c **** 					time can be sampled again, and this time its value can
3477:FreeRTOS/Source/tasks.c **** 					be used. */
3478:FreeRTOS/Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3479:FreeRTOS/Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3480:FreeRTOS/Source/tasks.c **** 
3481:FreeRTOS/Source/tasks.c **** 					/* Define the following macro to set xExpectedIdleTime to 0
3482:FreeRTOS/Source/tasks.c **** 					if the application does not want
3483:FreeRTOS/Source/tasks.c **** 					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3484:FreeRTOS/Source/tasks.c **** 					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3485:FreeRTOS/Source/tasks.c **** 
3486:FreeRTOS/Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3487:FreeRTOS/Source/tasks.c **** 					{
3488:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3489:FreeRTOS/Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3490:FreeRTOS/Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
3491:FreeRTOS/Source/tasks.c **** 					}
3492:FreeRTOS/Source/tasks.c **** 					else
3493:FreeRTOS/Source/tasks.c **** 					{
3494:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3495:FreeRTOS/Source/tasks.c **** 					}
3496:FreeRTOS/Source/tasks.c **** 				}
3497:FreeRTOS/Source/tasks.c **** 				( void ) xTaskResumeAll();
3498:FreeRTOS/Source/tasks.c **** 			}
3499:FreeRTOS/Source/tasks.c **** 			else
3500:FreeRTOS/Source/tasks.c **** 			{
3501:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3502:FreeRTOS/Source/tasks.c **** 			}
ARM GAS  /tmp/cckqXCjj.s 			page 126


3503:FreeRTOS/Source/tasks.c **** 		}
3504:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3505:FreeRTOS/Source/tasks.c **** 	}
3506:FreeRTOS/Source/tasks.c **** }
3507:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3508:FreeRTOS/Source/tasks.c **** 
3509:FreeRTOS/Source/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3510:FreeRTOS/Source/tasks.c **** 
3511:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3512:FreeRTOS/Source/tasks.c **** 	{
3513:FreeRTOS/Source/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3514:FreeRTOS/Source/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3515:FreeRTOS/Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3516:FreeRTOS/Source/tasks.c **** 
3517:FreeRTOS/Source/tasks.c **** 		/* This function must be called from a critical section. */
3518:FreeRTOS/Source/tasks.c **** 
3519:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3520:FreeRTOS/Source/tasks.c **** 		{
3521:FreeRTOS/Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3522:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
3523:FreeRTOS/Source/tasks.c **** 		}
3524:FreeRTOS/Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
3525:FreeRTOS/Source/tasks.c **** 		{
3526:FreeRTOS/Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3527:FreeRTOS/Source/tasks.c **** 			eReturn = eAbortSleep;
3528:FreeRTOS/Source/tasks.c **** 		}
3529:FreeRTOS/Source/tasks.c **** 		else
3530:FreeRTOS/Source/tasks.c **** 		{
3531:FreeRTOS/Source/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3532:FreeRTOS/Source/tasks.c **** 			have an infinite block time rather than actually being suspended)
3533:FreeRTOS/Source/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3534:FreeRTOS/Source/tasks.c **** 			interrupts. */
3535:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3536:FreeRTOS/Source/tasks.c **** 			{
3537:FreeRTOS/Source/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3538:FreeRTOS/Source/tasks.c **** 			}
3539:FreeRTOS/Source/tasks.c **** 			else
3540:FreeRTOS/Source/tasks.c **** 			{
3541:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3542:FreeRTOS/Source/tasks.c **** 			}
3543:FreeRTOS/Source/tasks.c **** 		}
3544:FreeRTOS/Source/tasks.c **** 
3545:FreeRTOS/Source/tasks.c **** 		return eReturn;
3546:FreeRTOS/Source/tasks.c **** 	}
3547:FreeRTOS/Source/tasks.c **** 
3548:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3549:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3550:FreeRTOS/Source/tasks.c **** 
3551:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3552:FreeRTOS/Source/tasks.c **** 
3553:FreeRTOS/Source/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3554:FreeRTOS/Source/tasks.c **** 	{
3555:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3556:FreeRTOS/Source/tasks.c **** 
3557:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3558:FreeRTOS/Source/tasks.c **** 		{
3559:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
ARM GAS  /tmp/cckqXCjj.s 			page 127


3560:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB != NULL );
3561:FreeRTOS/Source/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3562:FreeRTOS/Source/tasks.c **** 		}
3563:FreeRTOS/Source/tasks.c **** 	}
3564:FreeRTOS/Source/tasks.c **** 
3565:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3566:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3567:FreeRTOS/Source/tasks.c **** 
3568:FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3569:FreeRTOS/Source/tasks.c **** 
3570:FreeRTOS/Source/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3571:FreeRTOS/Source/tasks.c **** 	{
3572:FreeRTOS/Source/tasks.c **** 	void *pvReturn = NULL;
3573:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3574:FreeRTOS/Source/tasks.c **** 
3575:FreeRTOS/Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3576:FreeRTOS/Source/tasks.c **** 		{
3577:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3578:FreeRTOS/Source/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3579:FreeRTOS/Source/tasks.c **** 		}
3580:FreeRTOS/Source/tasks.c **** 		else
3581:FreeRTOS/Source/tasks.c **** 		{
3582:FreeRTOS/Source/tasks.c **** 			pvReturn = NULL;
3583:FreeRTOS/Source/tasks.c **** 		}
3584:FreeRTOS/Source/tasks.c **** 
3585:FreeRTOS/Source/tasks.c **** 		return pvReturn;
3586:FreeRTOS/Source/tasks.c **** 	}
3587:FreeRTOS/Source/tasks.c **** 
3588:FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3589:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3590:FreeRTOS/Source/tasks.c **** 
3591:FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3592:FreeRTOS/Source/tasks.c **** 
3593:FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3594:FreeRTOS/Source/tasks.c **** 	{
3595:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3596:FreeRTOS/Source/tasks.c **** 
3597:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3598:FreeRTOS/Source/tasks.c **** 		the calling task. */
3599:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3600:FreeRTOS/Source/tasks.c **** 
3601:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3602:FreeRTOS/Source/tasks.c **** 	}
3603:FreeRTOS/Source/tasks.c **** 
3604:FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3605:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3606:FreeRTOS/Source/tasks.c **** 
3607:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
3608:FreeRTOS/Source/tasks.c **** {
 3349              		.loc 1 3608 0
 3350              		.cfi_startproc
 3351              		@ args = 0, pretend = 0, frame = 8
 3352              		@ frame_needed = 1, uses_anonymous_args = 0
 3353 0f90 80B5     		push	{r7, lr}
 3354              		.cfi_def_cfa_offset 8
 3355              		.cfi_offset 7, -8
 3356              		.cfi_offset 14, -4
ARM GAS  /tmp/cckqXCjj.s 			page 128


 3357 0f92 82B0     		sub	sp, sp, #8
 3358              		.cfi_def_cfa_offset 16
 3359 0f94 00AF     		add	r7, sp, #0
 3360              		.cfi_def_cfa_register 7
3609:FreeRTOS/Source/tasks.c **** UBaseType_t uxPriority;
3610:FreeRTOS/Source/tasks.c **** 
3611:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
 3361              		.loc 1 3611 0
 3362 0f96 0023     		movs	r3, #0
 3363 0f98 7B60     		str	r3, [r7, #4]
 3364 0f9a 0CE0     		b	.L223
 3365              	.L224:
3612:FreeRTOS/Source/tasks.c **** 	{
3613:FreeRTOS/Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 3366              		.loc 1 3613 0 discriminator 3
 3367 0f9c 7A68     		ldr	r2, [r7, #4]
 3368 0f9e 1346     		mov	r3, r2
 3369 0fa0 9B00     		lsls	r3, r3, #2
 3370 0fa2 1344     		add	r3, r3, r2
 3371 0fa4 9B00     		lsls	r3, r3, #2
 3372 0fa6 124A     		ldr	r2, .L225
 3373 0fa8 1344     		add	r3, r3, r2
 3374 0faa 1846     		mov	r0, r3
 3375 0fac FFF7FEFF 		bl	vListInitialise
3611:FreeRTOS/Source/tasks.c **** 	{
 3376              		.loc 1 3611 0 discriminator 3
 3377 0fb0 7B68     		ldr	r3, [r7, #4]
 3378 0fb2 0133     		adds	r3, r3, #1
 3379 0fb4 7B60     		str	r3, [r7, #4]
 3380              	.L223:
3611:FreeRTOS/Source/tasks.c **** 	{
 3381              		.loc 1 3611 0 is_stmt 0 discriminator 1
 3382 0fb6 7B68     		ldr	r3, [r7, #4]
 3383 0fb8 042B     		cmp	r3, #4
 3384 0fba EFD9     		bls	.L224
3614:FreeRTOS/Source/tasks.c **** 	}
3615:FreeRTOS/Source/tasks.c **** 
3616:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 3385              		.loc 1 3616 0 is_stmt 1
 3386 0fbc 0D48     		ldr	r0, .L225+4
 3387 0fbe FFF7FEFF 		bl	vListInitialise
3617:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 3388              		.loc 1 3617 0
 3389 0fc2 0D48     		ldr	r0, .L225+8
 3390 0fc4 FFF7FEFF 		bl	vListInitialise
3618:FreeRTOS/Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 3391              		.loc 1 3618 0
 3392 0fc8 0C48     		ldr	r0, .L225+12
 3393 0fca FFF7FEFF 		bl	vListInitialise
3619:FreeRTOS/Source/tasks.c **** 
3620:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3621:FreeRTOS/Source/tasks.c **** 	{
3622:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
 3394              		.loc 1 3622 0
 3395 0fce 0C48     		ldr	r0, .L225+16
 3396 0fd0 FFF7FEFF 		bl	vListInitialise
3623:FreeRTOS/Source/tasks.c **** 	}
ARM GAS  /tmp/cckqXCjj.s 			page 129


3624:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3625:FreeRTOS/Source/tasks.c **** 
3626:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3627:FreeRTOS/Source/tasks.c **** 	{
3628:FreeRTOS/Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
 3397              		.loc 1 3628 0
 3398 0fd4 0B48     		ldr	r0, .L225+20
 3399 0fd6 FFF7FEFF 		bl	vListInitialise
3629:FreeRTOS/Source/tasks.c **** 	}
3630:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3631:FreeRTOS/Source/tasks.c **** 
3632:FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3633:FreeRTOS/Source/tasks.c **** 	using list2. */
3634:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3400              		.loc 1 3634 0
 3401 0fda 0B4B     		ldr	r3, .L225+24
 3402 0fdc 054A     		ldr	r2, .L225+4
 3403 0fde 1A60     		str	r2, [r3]
3635:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3404              		.loc 1 3635 0
 3405 0fe0 0A4B     		ldr	r3, .L225+28
 3406 0fe2 054A     		ldr	r2, .L225+8
 3407 0fe4 1A60     		str	r2, [r3]
3636:FreeRTOS/Source/tasks.c **** }
 3408              		.loc 1 3636 0
 3409 0fe6 00BF     		nop
 3410 0fe8 0837     		adds	r7, r7, #8
 3411              		.cfi_def_cfa_offset 8
 3412 0fea BD46     		mov	sp, r7
 3413              		.cfi_def_cfa_register 13
 3414              		@ sp needed
 3415 0fec 80BD     		pop	{r7, pc}
 3416              	.L226:
 3417 0fee 00BF     		.align	2
 3418              	.L225:
 3419 0ff0 04000000 		.word	pxReadyTasksLists
 3420 0ff4 68000000 		.word	xDelayedTaskList1
 3421 0ff8 7C000000 		.word	xDelayedTaskList2
 3422 0ffc 98000000 		.word	xPendingReadyList
 3423 1000 AC000000 		.word	xTasksWaitingTermination
 3424 1004 C4000000 		.word	xSuspendedTaskList
 3425 1008 90000000 		.word	pxDelayedTaskList
 3426 100c 94000000 		.word	pxOverflowDelayedTaskList
 3427              		.cfi_endproc
 3428              	.LFE38:
 3429              		.size	prvInitialiseTaskLists, .-prvInitialiseTaskLists
 3430              		.align	1
 3431              		.syntax unified
 3432              		.thumb
 3433              		.thumb_func
 3434              		.fpu softvfp
 3435              		.type	prvCheckTasksWaitingTermination, %function
 3436              	prvCheckTasksWaitingTermination:
 3437              	.LFB39:
3637:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3638:FreeRTOS/Source/tasks.c **** 
3639:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
ARM GAS  /tmp/cckqXCjj.s 			page 130


3640:FreeRTOS/Source/tasks.c **** {
 3438              		.loc 1 3640 0
 3439              		.cfi_startproc
 3440              		@ args = 0, pretend = 0, frame = 8
 3441              		@ frame_needed = 1, uses_anonymous_args = 0
 3442 1010 80B5     		push	{r7, lr}
 3443              		.cfi_def_cfa_offset 8
 3444              		.cfi_offset 7, -8
 3445              		.cfi_offset 14, -4
 3446 1012 82B0     		sub	sp, sp, #8
 3447              		.cfi_def_cfa_offset 16
 3448 1014 00AF     		add	r7, sp, #0
 3449              		.cfi_def_cfa_register 7
 3450              	.LBB48:
3641:FreeRTOS/Source/tasks.c **** 
3642:FreeRTOS/Source/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3643:FreeRTOS/Source/tasks.c **** 
3644:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3645:FreeRTOS/Source/tasks.c **** 	{
3646:FreeRTOS/Source/tasks.c **** 		TCB_t *pxTCB;
3647:FreeRTOS/Source/tasks.c **** 
3648:FreeRTOS/Source/tasks.c **** 		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
3649:FreeRTOS/Source/tasks.c **** 		being called too often in the idle task. */
3650:FreeRTOS/Source/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 3451              		.loc 1 3650 0
 3452 1016 19E0     		b	.L228
 3453              	.L229:
3651:FreeRTOS/Source/tasks.c **** 		{
3652:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 3454              		.loc 1 3652 0
 3455 1018 FFF7FEFF 		bl	vPortEnterCritical
3653:FreeRTOS/Source/tasks.c **** 			{
3654:FreeRTOS/Source/tasks.c **** 				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is u
 3456              		.loc 1 3654 0
 3457 101c 0F4B     		ldr	r3, .L230
 3458 101e DB68     		ldr	r3, [r3, #12]
 3459 1020 DB68     		ldr	r3, [r3, #12]
 3460 1022 7B60     		str	r3, [r7, #4]
3655:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 3461              		.loc 1 3655 0
 3462 1024 7B68     		ldr	r3, [r7, #4]
 3463 1026 0433     		adds	r3, r3, #4
 3464 1028 1846     		mov	r0, r3
 3465 102a FFF7FEFF 		bl	uxListRemove
3656:FreeRTOS/Source/tasks.c **** 				--uxCurrentNumberOfTasks;
 3466              		.loc 1 3656 0
 3467 102e 0C4B     		ldr	r3, .L230+4
 3468 1030 1B68     		ldr	r3, [r3]
 3469 1032 013B     		subs	r3, r3, #1
 3470 1034 0A4A     		ldr	r2, .L230+4
 3471 1036 1360     		str	r3, [r2]
3657:FreeRTOS/Source/tasks.c **** 				--uxDeletedTasksWaitingCleanUp;
 3472              		.loc 1 3657 0
 3473 1038 0A4B     		ldr	r3, .L230+8
 3474 103a 1B68     		ldr	r3, [r3]
 3475 103c 013B     		subs	r3, r3, #1
 3476 103e 094A     		ldr	r2, .L230+8
ARM GAS  /tmp/cckqXCjj.s 			page 131


 3477 1040 1360     		str	r3, [r2]
3658:FreeRTOS/Source/tasks.c **** 			}
3659:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 3478              		.loc 1 3659 0
 3479 1042 FFF7FEFF 		bl	vPortExitCritical
3660:FreeRTOS/Source/tasks.c **** 
3661:FreeRTOS/Source/tasks.c **** 			prvDeleteTCB( pxTCB );
 3480              		.loc 1 3661 0
 3481 1046 7868     		ldr	r0, [r7, #4]
 3482 1048 00F00EF8 		bl	prvDeleteTCB
 3483              	.L228:
3650:FreeRTOS/Source/tasks.c **** 		{
 3484              		.loc 1 3650 0
 3485 104c 054B     		ldr	r3, .L230+8
 3486 104e 1B68     		ldr	r3, [r3]
 3487 1050 002B     		cmp	r3, #0
 3488 1052 E1D1     		bne	.L229
 3489              	.LBE48:
3662:FreeRTOS/Source/tasks.c **** 		}
3663:FreeRTOS/Source/tasks.c **** 	}
3664:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3665:FreeRTOS/Source/tasks.c **** }
 3490              		.loc 1 3665 0
 3491 1054 00BF     		nop
 3492 1056 0837     		adds	r7, r7, #8
 3493              		.cfi_def_cfa_offset 8
 3494 1058 BD46     		mov	sp, r7
 3495              		.cfi_def_cfa_register 13
 3496              		@ sp needed
 3497 105a 80BD     		pop	{r7, pc}
 3498              	.L231:
 3499              		.align	2
 3500              	.L230:
 3501 105c AC000000 		.word	xTasksWaitingTermination
 3502 1060 D8000000 		.word	uxCurrentNumberOfTasks
 3503 1064 C0000000 		.word	uxDeletedTasksWaitingCleanUp
 3504              		.cfi_endproc
 3505              	.LFE39:
 3506              		.size	prvCheckTasksWaitingTermination, .-prvCheckTasksWaitingTermination
 3507              		.align	1
 3508              		.syntax unified
 3509              		.thumb
 3510              		.thumb_func
 3511              		.fpu softvfp
 3512              		.type	prvDeleteTCB, %function
 3513              	prvDeleteTCB:
 3514              	.LFB40:
3666:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3667:FreeRTOS/Source/tasks.c **** 
3668:FreeRTOS/Source/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3669:FreeRTOS/Source/tasks.c **** 
3670:FreeRTOS/Source/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3671:FreeRTOS/Source/tasks.c **** 	{
3672:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3673:FreeRTOS/Source/tasks.c **** 
3674:FreeRTOS/Source/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3675:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
ARM GAS  /tmp/cckqXCjj.s 			page 132


3676:FreeRTOS/Source/tasks.c **** 
3677:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3678:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3679:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3680:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3681:FreeRTOS/Source/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3682:FreeRTOS/Source/tasks.c **** 
3683:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3684:FreeRTOS/Source/tasks.c **** 		{
3685:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3686:FreeRTOS/Source/tasks.c **** 		}
3687:FreeRTOS/Source/tasks.c **** 		#else
3688:FreeRTOS/Source/tasks.c **** 		{
3689:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3690:FreeRTOS/Source/tasks.c **** 		}
3691:FreeRTOS/Source/tasks.c **** 		#endif
3692:FreeRTOS/Source/tasks.c **** 
3693:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3694:FreeRTOS/Source/tasks.c **** 		{
3695:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3696:FreeRTOS/Source/tasks.c **** 		}
3697:FreeRTOS/Source/tasks.c **** 		#else
3698:FreeRTOS/Source/tasks.c **** 		{
3699:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3700:FreeRTOS/Source/tasks.c **** 		}
3701:FreeRTOS/Source/tasks.c **** 		#endif
3702:FreeRTOS/Source/tasks.c **** 
3703:FreeRTOS/Source/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the
3704:FreeRTOS/Source/tasks.c **** 		value of eState passed into this function is eInvalid - otherwise the
3705:FreeRTOS/Source/tasks.c **** 		state is just set to whatever is passed in. */
3706:FreeRTOS/Source/tasks.c **** 		if( eState != eInvalid )
3707:FreeRTOS/Source/tasks.c **** 		{
3708:FreeRTOS/Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
3709:FreeRTOS/Source/tasks.c **** 			{
3710:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->eCurrentState = eRunning;
3711:FreeRTOS/Source/tasks.c **** 			}
3712:FreeRTOS/Source/tasks.c **** 			else
3713:FreeRTOS/Source/tasks.c **** 			{
3714:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->eCurrentState = eState;
3715:FreeRTOS/Source/tasks.c **** 
3716:FreeRTOS/Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
3717:FreeRTOS/Source/tasks.c **** 				{
3718:FreeRTOS/Source/tasks.c **** 					/* If the task is in the suspended list then there is a
3719:FreeRTOS/Source/tasks.c **** 					chance it is actually just blocked indefinitely - so really
3720:FreeRTOS/Source/tasks.c **** 					it should be reported as being in the Blocked state. */
3721:FreeRTOS/Source/tasks.c **** 					if( eState == eSuspended )
3722:FreeRTOS/Source/tasks.c **** 					{
3723:FreeRTOS/Source/tasks.c **** 						vTaskSuspendAll();
3724:FreeRTOS/Source/tasks.c **** 						{
3725:FreeRTOS/Source/tasks.c **** 							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3726:FreeRTOS/Source/tasks.c **** 							{
3727:FreeRTOS/Source/tasks.c **** 								pxTaskStatus->eCurrentState = eBlocked;
3728:FreeRTOS/Source/tasks.c **** 							}
3729:FreeRTOS/Source/tasks.c **** 						}
3730:FreeRTOS/Source/tasks.c **** 						( void ) xTaskResumeAll();
3731:FreeRTOS/Source/tasks.c **** 					}
3732:FreeRTOS/Source/tasks.c **** 				}
ARM GAS  /tmp/cckqXCjj.s 			page 133


3733:FreeRTOS/Source/tasks.c **** 				#endif /* INCLUDE_vTaskSuspend */
3734:FreeRTOS/Source/tasks.c **** 			}
3735:FreeRTOS/Source/tasks.c **** 		}
3736:FreeRTOS/Source/tasks.c **** 		else
3737:FreeRTOS/Source/tasks.c **** 		{
3738:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
3739:FreeRTOS/Source/tasks.c **** 		}
3740:FreeRTOS/Source/tasks.c **** 
3741:FreeRTOS/Source/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3742:FreeRTOS/Source/tasks.c **** 		parameter is provided to allow it to be skipped. */
3743:FreeRTOS/Source/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3744:FreeRTOS/Source/tasks.c **** 		{
3745:FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3746:FreeRTOS/Source/tasks.c **** 			{
3747:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3748:FreeRTOS/Source/tasks.c **** 			}
3749:FreeRTOS/Source/tasks.c **** 			#else
3750:FreeRTOS/Source/tasks.c **** 			{
3751:FreeRTOS/Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3752:FreeRTOS/Source/tasks.c **** 			}
3753:FreeRTOS/Source/tasks.c **** 			#endif
3754:FreeRTOS/Source/tasks.c **** 		}
3755:FreeRTOS/Source/tasks.c **** 		else
3756:FreeRTOS/Source/tasks.c **** 		{
3757:FreeRTOS/Source/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3758:FreeRTOS/Source/tasks.c **** 		}
3759:FreeRTOS/Source/tasks.c **** 	}
3760:FreeRTOS/Source/tasks.c **** 
3761:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3762:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3763:FreeRTOS/Source/tasks.c **** 
3764:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3765:FreeRTOS/Source/tasks.c **** 
3766:FreeRTOS/Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3767:FreeRTOS/Source/tasks.c **** 	{
3768:FreeRTOS/Source/tasks.c **** 	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
3769:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTask = 0;
3770:FreeRTOS/Source/tasks.c **** 
3771:FreeRTOS/Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3772:FreeRTOS/Source/tasks.c **** 		{
3773:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is
3774:FreeRTOS/Source/tasks.c **** 
3775:FreeRTOS/Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3776:FreeRTOS/Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3777:FreeRTOS/Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3778:FreeRTOS/Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3779:FreeRTOS/Source/tasks.c **** 			do
3780:FreeRTOS/Source/tasks.c **** 			{
3781:FreeRTOS/Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is
3782:FreeRTOS/Source/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3783:FreeRTOS/Source/tasks.c **** 				uxTask++;
3784:FreeRTOS/Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
3785:FreeRTOS/Source/tasks.c **** 		}
3786:FreeRTOS/Source/tasks.c **** 		else
3787:FreeRTOS/Source/tasks.c **** 		{
3788:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3789:FreeRTOS/Source/tasks.c **** 		}
ARM GAS  /tmp/cckqXCjj.s 			page 134


3790:FreeRTOS/Source/tasks.c **** 
3791:FreeRTOS/Source/tasks.c **** 		return uxTask;
3792:FreeRTOS/Source/tasks.c **** 	}
3793:FreeRTOS/Source/tasks.c **** 
3794:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3795:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3796:FreeRTOS/Source/tasks.c **** 
3797:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
3798:FreeRTOS/Source/tasks.c **** 
3799:FreeRTOS/Source/tasks.c **** 	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3800:FreeRTOS/Source/tasks.c **** 	{
3801:FreeRTOS/Source/tasks.c **** 	uint32_t ulCount = 0U;
3802:FreeRTOS/Source/tasks.c **** 
3803:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
3804:FreeRTOS/Source/tasks.c **** 		{
3805:FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
3806:FreeRTOS/Source/tasks.c **** 			ulCount++;
3807:FreeRTOS/Source/tasks.c **** 		}
3808:FreeRTOS/Source/tasks.c **** 
3809:FreeRTOS/Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
3810:FreeRTOS/Source/tasks.c **** 
3811:FreeRTOS/Source/tasks.c **** 		return ( configSTACK_DEPTH_TYPE ) ulCount;
3812:FreeRTOS/Source/tasks.c **** 	}
3813:FreeRTOS/Source/tasks.c **** 
3814:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( 
3815:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3816:FreeRTOS/Source/tasks.c **** 
3817:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )
3818:FreeRTOS/Source/tasks.c **** 
3819:FreeRTOS/Source/tasks.c **** 	/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
3820:FreeRTOS/Source/tasks.c **** 	same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
3821:FreeRTOS/Source/tasks.c **** 	user to determine the return type.  It gets around the problem of the value
3822:FreeRTOS/Source/tasks.c **** 	overflowing on 8-bit types without breaking backward compatibility for
3823:FreeRTOS/Source/tasks.c **** 	applications that expect an 8-bit return type. */
3824:FreeRTOS/Source/tasks.c **** 	configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )
3825:FreeRTOS/Source/tasks.c **** 	{
3826:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3827:FreeRTOS/Source/tasks.c **** 	uint8_t *pucEndOfStack;
3828:FreeRTOS/Source/tasks.c **** 	configSTACK_DEPTH_TYPE uxReturn;
3829:FreeRTOS/Source/tasks.c **** 
3830:FreeRTOS/Source/tasks.c **** 		/* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
3831:FreeRTOS/Source/tasks.c **** 		the same except for their return type.  Using configSTACK_DEPTH_TYPE
3832:FreeRTOS/Source/tasks.c **** 		allows the user to determine the return type.  It gets around the
3833:FreeRTOS/Source/tasks.c **** 		problem of the value overflowing on 8-bit types without breaking
3834:FreeRTOS/Source/tasks.c **** 		backward compatibility for applications that expect an 8-bit return
3835:FreeRTOS/Source/tasks.c **** 		type. */
3836:FreeRTOS/Source/tasks.c **** 
3837:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3838:FreeRTOS/Source/tasks.c **** 
3839:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3840:FreeRTOS/Source/tasks.c **** 		{
3841:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3842:FreeRTOS/Source/tasks.c **** 		}
3843:FreeRTOS/Source/tasks.c **** 		#else
3844:FreeRTOS/Source/tasks.c **** 		{
3845:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3846:FreeRTOS/Source/tasks.c **** 		}
ARM GAS  /tmp/cckqXCjj.s 			page 135


3847:FreeRTOS/Source/tasks.c **** 		#endif
3848:FreeRTOS/Source/tasks.c **** 
3849:FreeRTOS/Source/tasks.c **** 		uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );
3850:FreeRTOS/Source/tasks.c **** 
3851:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3852:FreeRTOS/Source/tasks.c **** 	}
3853:FreeRTOS/Source/tasks.c **** 
3854:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */
3855:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3856:FreeRTOS/Source/tasks.c **** 
3857:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3858:FreeRTOS/Source/tasks.c **** 
3859:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3860:FreeRTOS/Source/tasks.c **** 	{
3861:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
3862:FreeRTOS/Source/tasks.c **** 	uint8_t *pucEndOfStack;
3863:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxReturn;
3864:FreeRTOS/Source/tasks.c **** 
3865:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3866:FreeRTOS/Source/tasks.c **** 
3867:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3868:FreeRTOS/Source/tasks.c **** 		{
3869:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3870:FreeRTOS/Source/tasks.c **** 		}
3871:FreeRTOS/Source/tasks.c **** 		#else
3872:FreeRTOS/Source/tasks.c **** 		{
3873:FreeRTOS/Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3874:FreeRTOS/Source/tasks.c **** 		}
3875:FreeRTOS/Source/tasks.c **** 		#endif
3876:FreeRTOS/Source/tasks.c **** 
3877:FreeRTOS/Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
3878:FreeRTOS/Source/tasks.c **** 
3879:FreeRTOS/Source/tasks.c **** 		return uxReturn;
3880:FreeRTOS/Source/tasks.c **** 	}
3881:FreeRTOS/Source/tasks.c **** 
3882:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3883:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3884:FreeRTOS/Source/tasks.c **** 
3885:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3886:FreeRTOS/Source/tasks.c **** 
3887:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3888:FreeRTOS/Source/tasks.c **** 	{
 3515              		.loc 1 3888 0
 3516              		.cfi_startproc
 3517              		@ args = 0, pretend = 0, frame = 8
 3518              		@ frame_needed = 1, uses_anonymous_args = 0
 3519 1068 80B5     		push	{r7, lr}
 3520              		.cfi_def_cfa_offset 8
 3521              		.cfi_offset 7, -8
 3522              		.cfi_offset 14, -4
 3523 106a 82B0     		sub	sp, sp, #8
 3524              		.cfi_def_cfa_offset 16
 3525 106c 00AF     		add	r7, sp, #0
 3526              		.cfi_def_cfa_register 7
 3527 106e 7860     		str	r0, [r7, #4]
3889:FreeRTOS/Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3890:FreeRTOS/Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
ARM GAS  /tmp/cckqXCjj.s 			page 136


3891:FreeRTOS/Source/tasks.c **** 		want to allocate and clean RAM statically. */
3892:FreeRTOS/Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3893:FreeRTOS/Source/tasks.c **** 
3894:FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3895:FreeRTOS/Source/tasks.c **** 		to the task to free any memory allocated at the application level.
3896:FreeRTOS/Source/tasks.c **** 		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
3897:FreeRTOS/Source/tasks.c **** 		for additional information. */
3898:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3899:FreeRTOS/Source/tasks.c **** 		{
3900:FreeRTOS/Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3901:FreeRTOS/Source/tasks.c **** 		}
3902:FreeRTOS/Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3903:FreeRTOS/Source/tasks.c **** 
3904:FreeRTOS/Source/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( p
3905:FreeRTOS/Source/tasks.c **** 		{
3906:FreeRTOS/Source/tasks.c **** 			/* The task can only have been allocated dynamically - free both
3907:FreeRTOS/Source/tasks.c **** 			the stack and TCB. */
3908:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB->pxStack );
 3528              		.loc 1 3908 0
 3529 1070 7B68     		ldr	r3, [r7, #4]
 3530 1072 1B6B     		ldr	r3, [r3, #48]
 3531 1074 1846     		mov	r0, r3
 3532 1076 FFF7FEFF 		bl	vPortFree
3909:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTCB );
 3533              		.loc 1 3909 0
 3534 107a 7868     		ldr	r0, [r7, #4]
 3535 107c FFF7FEFF 		bl	vPortFree
3910:FreeRTOS/Source/tasks.c **** 		}
3911:FreeRTOS/Source/tasks.c **** 		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consol
3912:FreeRTOS/Source/tasks.c **** 		{
3913:FreeRTOS/Source/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3914:FreeRTOS/Source/tasks.c **** 			check what was statically allocated before trying to free the
3915:FreeRTOS/Source/tasks.c **** 			memory. */
3916:FreeRTOS/Source/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3917:FreeRTOS/Source/tasks.c **** 			{
3918:FreeRTOS/Source/tasks.c **** 				/* Both the stack and TCB were allocated dynamically, so both
3919:FreeRTOS/Source/tasks.c **** 				must be freed. */
3920:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB->pxStack );
3921:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB );
3922:FreeRTOS/Source/tasks.c **** 			}
3923:FreeRTOS/Source/tasks.c **** 			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3924:FreeRTOS/Source/tasks.c **** 			{
3925:FreeRTOS/Source/tasks.c **** 				/* Only the stack was statically allocated, so the TCB is the
3926:FreeRTOS/Source/tasks.c **** 				only memory that must be freed. */
3927:FreeRTOS/Source/tasks.c **** 				vPortFree( pxTCB );
3928:FreeRTOS/Source/tasks.c **** 			}
3929:FreeRTOS/Source/tasks.c **** 			else
3930:FreeRTOS/Source/tasks.c **** 			{
3931:FreeRTOS/Source/tasks.c **** 				/* Neither the stack nor the TCB were allocated dynamically, so
3932:FreeRTOS/Source/tasks.c **** 				nothing needs to be freed. */
3933:FreeRTOS/Source/tasks.c **** 				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
3934:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3935:FreeRTOS/Source/tasks.c **** 			}
3936:FreeRTOS/Source/tasks.c **** 		}
3937:FreeRTOS/Source/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3938:FreeRTOS/Source/tasks.c **** 	}
 3536              		.loc 1 3938 0
ARM GAS  /tmp/cckqXCjj.s 			page 137


 3537 1080 00BF     		nop
 3538 1082 0837     		adds	r7, r7, #8
 3539              		.cfi_def_cfa_offset 8
 3540 1084 BD46     		mov	sp, r7
 3541              		.cfi_def_cfa_register 13
 3542              		@ sp needed
 3543 1086 80BD     		pop	{r7, pc}
 3544              		.cfi_endproc
 3545              	.LFE40:
 3546              		.size	prvDeleteTCB, .-prvDeleteTCB
 3547              		.align	1
 3548              		.syntax unified
 3549              		.thumb
 3550              		.thumb_func
 3551              		.fpu softvfp
 3552              		.type	prvResetNextTaskUnblockTime, %function
 3553              	prvResetNextTaskUnblockTime:
 3554              	.LFB41:
3939:FreeRTOS/Source/tasks.c **** 
3940:FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3941:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3942:FreeRTOS/Source/tasks.c **** 
3943:FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3944:FreeRTOS/Source/tasks.c **** {
 3555              		.loc 1 3944 0
 3556              		.cfi_startproc
 3557              		@ args = 0, pretend = 0, frame = 8
 3558              		@ frame_needed = 1, uses_anonymous_args = 0
 3559              		@ link register save eliminated.
 3560 1088 80B4     		push	{r7}
 3561              		.cfi_def_cfa_offset 4
 3562              		.cfi_offset 7, -4
 3563 108a 83B0     		sub	sp, sp, #12
 3564              		.cfi_def_cfa_offset 16
 3565 108c 00AF     		add	r7, sp, #0
 3566              		.cfi_def_cfa_register 7
3945:FreeRTOS/Source/tasks.c **** TCB_t *pxTCB;
3946:FreeRTOS/Source/tasks.c **** 
3947:FreeRTOS/Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 3567              		.loc 1 3947 0
 3568 108e 0C4B     		ldr	r3, .L237
 3569 1090 1B68     		ldr	r3, [r3]
 3570 1092 1B68     		ldr	r3, [r3]
 3571 1094 002B     		cmp	r3, #0
 3572 1096 04D1     		bne	.L234
3948:FreeRTOS/Source/tasks.c **** 	{
3949:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3950:FreeRTOS/Source/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3951:FreeRTOS/Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3952:FreeRTOS/Source/tasks.c **** 		there is an item in the delayed list. */
3953:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 3573              		.loc 1 3953 0
 3574 1098 0A4B     		ldr	r3, .L237+4
 3575 109a 4FF0FF32 		mov	r2, #-1
 3576 109e 1A60     		str	r2, [r3]
3954:FreeRTOS/Source/tasks.c **** 	}
3955:FreeRTOS/Source/tasks.c **** 	else
ARM GAS  /tmp/cckqXCjj.s 			page 138


3956:FreeRTOS/Source/tasks.c **** 	{
3957:FreeRTOS/Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3958:FreeRTOS/Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3959:FreeRTOS/Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3960:FreeRTOS/Source/tasks.c **** 		from the Blocked state. */
3961:FreeRTOS/Source/tasks.c **** 		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as thi
3962:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
3963:FreeRTOS/Source/tasks.c **** 	}
3964:FreeRTOS/Source/tasks.c **** }
 3577              		.loc 1 3964 0
 3578 10a0 08E0     		b	.L236
 3579              	.L234:
3961:FreeRTOS/Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 3580              		.loc 1 3961 0
 3581 10a2 074B     		ldr	r3, .L237
 3582 10a4 1B68     		ldr	r3, [r3]
 3583 10a6 DB68     		ldr	r3, [r3, #12]
 3584 10a8 DB68     		ldr	r3, [r3, #12]
 3585 10aa 7B60     		str	r3, [r7, #4]
3962:FreeRTOS/Source/tasks.c **** 	}
 3586              		.loc 1 3962 0
 3587 10ac 7B68     		ldr	r3, [r7, #4]
 3588 10ae 5B68     		ldr	r3, [r3, #4]
 3589 10b0 044A     		ldr	r2, .L237+4
 3590 10b2 1360     		str	r3, [r2]
 3591              	.L236:
 3592              		.loc 1 3964 0
 3593 10b4 00BF     		nop
 3594 10b6 0C37     		adds	r7, r7, #12
 3595              		.cfi_def_cfa_offset 4
 3596 10b8 BD46     		mov	sp, r7
 3597              		.cfi_def_cfa_register 13
 3598              		@ sp needed
 3599 10ba 80BC     		pop	{r7}
 3600              		.cfi_restore 7
 3601              		.cfi_def_cfa_offset 0
 3602 10bc 7047     		bx	lr
 3603              	.L238:
 3604 10be 00BF     		.align	2
 3605              	.L237:
 3606 10c0 90000000 		.word	pxDelayedTaskList
 3607 10c4 F8000000 		.word	xNextTaskUnblockTime
 3608              		.cfi_endproc
 3609              	.LFE41:
 3610              		.size	prvResetNextTaskUnblockTime, .-prvResetNextTaskUnblockTime
 3611              		.align	1
 3612              		.global	xTaskGetSchedulerState
 3613              		.syntax unified
 3614              		.thumb
 3615              		.thumb_func
 3616              		.fpu softvfp
 3617              		.type	xTaskGetSchedulerState, %function
 3618              	xTaskGetSchedulerState:
 3619              	.LFB42:
3965:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3966:FreeRTOS/Source/tasks.c **** 
3967:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
ARM GAS  /tmp/cckqXCjj.s 			page 139


3968:FreeRTOS/Source/tasks.c **** 
3969:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3970:FreeRTOS/Source/tasks.c **** 	{
3971:FreeRTOS/Source/tasks.c **** 	TaskHandle_t xReturn;
3972:FreeRTOS/Source/tasks.c **** 
3973:FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
3974:FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3975:FreeRTOS/Source/tasks.c **** 		individual execution thread. */
3976:FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
3977:FreeRTOS/Source/tasks.c **** 
3978:FreeRTOS/Source/tasks.c **** 		return xReturn;
3979:FreeRTOS/Source/tasks.c **** 	}
3980:FreeRTOS/Source/tasks.c **** 
3981:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3982:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3983:FreeRTOS/Source/tasks.c **** 
3984:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3985:FreeRTOS/Source/tasks.c **** 
3986:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3987:FreeRTOS/Source/tasks.c **** 	{
 3620              		.loc 1 3987 0
 3621              		.cfi_startproc
 3622              		@ args = 0, pretend = 0, frame = 8
 3623              		@ frame_needed = 1, uses_anonymous_args = 0
 3624              		@ link register save eliminated.
 3625 10c8 80B4     		push	{r7}
 3626              		.cfi_def_cfa_offset 4
 3627              		.cfi_offset 7, -4
 3628 10ca 83B0     		sub	sp, sp, #12
 3629              		.cfi_def_cfa_offset 16
 3630 10cc 00AF     		add	r7, sp, #0
 3631              		.cfi_def_cfa_register 7
3988:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
3989:FreeRTOS/Source/tasks.c **** 
3990:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 3632              		.loc 1 3990 0
 3633 10ce 0B4B     		ldr	r3, .L244
 3634 10d0 1B68     		ldr	r3, [r3]
 3635 10d2 002B     		cmp	r3, #0
 3636 10d4 02D1     		bne	.L240
3991:FreeRTOS/Source/tasks.c **** 		{
3992:FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
 3637              		.loc 1 3992 0
 3638 10d6 0123     		movs	r3, #1
 3639 10d8 7B60     		str	r3, [r7, #4]
 3640 10da 08E0     		b	.L241
 3641              	.L240:
3993:FreeRTOS/Source/tasks.c **** 		}
3994:FreeRTOS/Source/tasks.c **** 		else
3995:FreeRTOS/Source/tasks.c **** 		{
3996:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 3642              		.loc 1 3996 0
 3643 10dc 084B     		ldr	r3, .L244+4
 3644 10de 1B68     		ldr	r3, [r3]
 3645 10e0 002B     		cmp	r3, #0
 3646 10e2 02D1     		bne	.L242
3997:FreeRTOS/Source/tasks.c **** 			{
ARM GAS  /tmp/cckqXCjj.s 			page 140


3998:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
 3647              		.loc 1 3998 0
 3648 10e4 0223     		movs	r3, #2
 3649 10e6 7B60     		str	r3, [r7, #4]
 3650 10e8 01E0     		b	.L241
 3651              	.L242:
3999:FreeRTOS/Source/tasks.c **** 			}
4000:FreeRTOS/Source/tasks.c **** 			else
4001:FreeRTOS/Source/tasks.c **** 			{
4002:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
 3652              		.loc 1 4002 0
 3653 10ea 0023     		movs	r3, #0
 3654 10ec 7B60     		str	r3, [r7, #4]
 3655              	.L241:
4003:FreeRTOS/Source/tasks.c **** 			}
4004:FreeRTOS/Source/tasks.c **** 		}
4005:FreeRTOS/Source/tasks.c **** 
4006:FreeRTOS/Source/tasks.c **** 		return xReturn;
 3656              		.loc 1 4006 0
 3657 10ee 7B68     		ldr	r3, [r7, #4]
4007:FreeRTOS/Source/tasks.c **** 	}
 3658              		.loc 1 4007 0
 3659 10f0 1846     		mov	r0, r3
 3660 10f2 0C37     		adds	r7, r7, #12
 3661              		.cfi_def_cfa_offset 4
 3662 10f4 BD46     		mov	sp, r7
 3663              		.cfi_def_cfa_register 13
 3664              		@ sp needed
 3665 10f6 80BC     		pop	{r7}
 3666              		.cfi_restore 7
 3667              		.cfi_def_cfa_offset 0
 3668 10f8 7047     		bx	lr
 3669              	.L245:
 3670 10fa 00BF     		.align	2
 3671              	.L244:
 3672 10fc E4000000 		.word	xSchedulerRunning
 3673 1100 00010000 		.word	uxSchedulerSuspended
 3674              		.cfi_endproc
 3675              	.LFE42:
 3676              		.size	xTaskGetSchedulerState, .-xTaskGetSchedulerState
 3677              		.align	1
 3678              		.global	uxTaskResetEventItemValue
 3679              		.syntax unified
 3680              		.thumb
 3681              		.thumb_func
 3682              		.fpu softvfp
 3683              		.type	uxTaskResetEventItemValue, %function
 3684              	uxTaskResetEventItemValue:
 3685              	.LFB43:
4008:FreeRTOS/Source/tasks.c **** 
4009:FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
4010:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4011:FreeRTOS/Source/tasks.c **** 
4012:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4013:FreeRTOS/Source/tasks.c **** 
4014:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
4015:FreeRTOS/Source/tasks.c **** 	{
ARM GAS  /tmp/cckqXCjj.s 			page 141


4016:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
4017:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
4018:FreeRTOS/Source/tasks.c **** 
4019:FreeRTOS/Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
4020:FreeRTOS/Source/tasks.c **** 		locked then the mutex holder might now be NULL.  _RB_ Is this still
4021:FreeRTOS/Source/tasks.c **** 		needed as interrupts can no longer use mutexes? */
4022:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
4023:FreeRTOS/Source/tasks.c **** 		{
4024:FreeRTOS/Source/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
4025:FreeRTOS/Source/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
4026:FreeRTOS/Source/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
4027:FreeRTOS/Source/tasks.c **** 			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
4028:FreeRTOS/Source/tasks.c **** 			{
4029:FreeRTOS/Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
4030:FreeRTOS/Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
4031:FreeRTOS/Source/tasks.c **** 				not being used for anything else. */
4032:FreeRTOS/Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VA
4033:FreeRTOS/Source/tasks.c **** 				{
4034:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIOR
4035:FreeRTOS/Source/tasks.c **** 				}
4036:FreeRTOS/Source/tasks.c **** 				else
4037:FreeRTOS/Source/tasks.c **** 				{
4038:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4039:FreeRTOS/Source/tasks.c **** 				}
4040:FreeRTOS/Source/tasks.c **** 
4041:FreeRTOS/Source/tasks.c **** 				/* If the task being modified is in the ready state it will need
4042:FreeRTOS/Source/tasks.c **** 				to be moved into a new list. */
4043:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutex
4044:FreeRTOS/Source/tasks.c **** 				{
4045:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4046:FreeRTOS/Source/tasks.c **** 					{
4047:FreeRTOS/Source/tasks.c **** 						/* It is known that the task is in its ready list so
4048:FreeRTOS/Source/tasks.c **** 						there is no need to check again and the port level
4049:FreeRTOS/Source/tasks.c **** 						reset macro can be called directly. */
4050:FreeRTOS/Source/tasks.c **** 						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
4051:FreeRTOS/Source/tasks.c **** 					}
4052:FreeRTOS/Source/tasks.c **** 					else
4053:FreeRTOS/Source/tasks.c **** 					{
4054:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4055:FreeRTOS/Source/tasks.c **** 					}
4056:FreeRTOS/Source/tasks.c **** 
4057:FreeRTOS/Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
4058:FreeRTOS/Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
4059:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxMutexHolderTCB );
4060:FreeRTOS/Source/tasks.c **** 				}
4061:FreeRTOS/Source/tasks.c **** 				else
4062:FreeRTOS/Source/tasks.c **** 				{
4063:FreeRTOS/Source/tasks.c **** 					/* Just inherit the priority. */
4064:FreeRTOS/Source/tasks.c **** 					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
4065:FreeRTOS/Source/tasks.c **** 				}
4066:FreeRTOS/Source/tasks.c **** 
4067:FreeRTOS/Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
4068:FreeRTOS/Source/tasks.c **** 
4069:FreeRTOS/Source/tasks.c **** 				/* Inheritance occurred. */
4070:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
4071:FreeRTOS/Source/tasks.c **** 			}
4072:FreeRTOS/Source/tasks.c **** 			else
ARM GAS  /tmp/cckqXCjj.s 			page 142


4073:FreeRTOS/Source/tasks.c **** 			{
4074:FreeRTOS/Source/tasks.c **** 				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
4075:FreeRTOS/Source/tasks.c **** 				{
4076:FreeRTOS/Source/tasks.c **** 					/* The base priority of the mutex holder is lower than the
4077:FreeRTOS/Source/tasks.c **** 					priority of the task attempting to take the mutex, but the
4078:FreeRTOS/Source/tasks.c **** 					current priority of the mutex holder is not lower than the
4079:FreeRTOS/Source/tasks.c **** 					priority of the task attempting to take the mutex.
4080:FreeRTOS/Source/tasks.c **** 					Therefore the mutex holder must have already inherited a
4081:FreeRTOS/Source/tasks.c **** 					priority, but inheritance would have occurred if that had
4082:FreeRTOS/Source/tasks.c **** 					not been the case. */
4083:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
4084:FreeRTOS/Source/tasks.c **** 				}
4085:FreeRTOS/Source/tasks.c **** 				else
4086:FreeRTOS/Source/tasks.c **** 				{
4087:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4088:FreeRTOS/Source/tasks.c **** 				}
4089:FreeRTOS/Source/tasks.c **** 			}
4090:FreeRTOS/Source/tasks.c **** 		}
4091:FreeRTOS/Source/tasks.c **** 		else
4092:FreeRTOS/Source/tasks.c **** 		{
4093:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4094:FreeRTOS/Source/tasks.c **** 		}
4095:FreeRTOS/Source/tasks.c **** 
4096:FreeRTOS/Source/tasks.c **** 		return xReturn;
4097:FreeRTOS/Source/tasks.c **** 	}
4098:FreeRTOS/Source/tasks.c **** 
4099:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4100:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4101:FreeRTOS/Source/tasks.c **** 
4102:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4103:FreeRTOS/Source/tasks.c **** 
4104:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
4105:FreeRTOS/Source/tasks.c **** 	{
4106:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
4107:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
4108:FreeRTOS/Source/tasks.c **** 
4109:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
4110:FreeRTOS/Source/tasks.c **** 		{
4111:FreeRTOS/Source/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
4112:FreeRTOS/Source/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
4113:FreeRTOS/Source/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
4114:FreeRTOS/Source/tasks.c **** 			be the running state task. */
4115:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
4116:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4117:FreeRTOS/Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
4118:FreeRTOS/Source/tasks.c **** 
4119:FreeRTOS/Source/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
4120:FreeRTOS/Source/tasks.c **** 			task? */
4121:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
4122:FreeRTOS/Source/tasks.c **** 			{
4123:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
4124:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
4125:FreeRTOS/Source/tasks.c **** 				{
4126:FreeRTOS/Source/tasks.c **** 					/* A task can only have an inherited priority if it holds
4127:FreeRTOS/Source/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
4128:FreeRTOS/Source/tasks.c **** 					given from an interrupt, and if a mutex is given by the
4129:FreeRTOS/Source/tasks.c **** 					holding task then it must be the running state task.  Remove
ARM GAS  /tmp/cckqXCjj.s 			page 143


4130:FreeRTOS/Source/tasks.c **** 					the holding task from the ready/delayed list. */
4131:FreeRTOS/Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4132:FreeRTOS/Source/tasks.c **** 					{
4133:FreeRTOS/Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
4134:FreeRTOS/Source/tasks.c **** 					}
4135:FreeRTOS/Source/tasks.c **** 					else
4136:FreeRTOS/Source/tasks.c **** 					{
4137:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4138:FreeRTOS/Source/tasks.c **** 					}
4139:FreeRTOS/Source/tasks.c **** 
4140:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority before adding the task into the
4141:FreeRTOS/Source/tasks.c **** 					new	ready list. */
4142:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4143:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
4144:FreeRTOS/Source/tasks.c **** 
4145:FreeRTOS/Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
4146:FreeRTOS/Source/tasks.c **** 					any other purpose if this task is running, and it must be
4147:FreeRTOS/Source/tasks.c **** 					running to give back the mutex. */
4148:FreeRTOS/Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
4149:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
4150:FreeRTOS/Source/tasks.c **** 
4151:FreeRTOS/Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
4152:FreeRTOS/Source/tasks.c **** 					This is only actually required in the corner case whereby
4153:FreeRTOS/Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
4154:FreeRTOS/Source/tasks.c **** 					in an order different to that in which they were taken.
4155:FreeRTOS/Source/tasks.c **** 					If a context switch did not occur when the first mutex was
4156:FreeRTOS/Source/tasks.c **** 					returned, even if a task was waiting on it, then a context
4157:FreeRTOS/Source/tasks.c **** 					switch should occur when the last mutex is returned whether
4158:FreeRTOS/Source/tasks.c **** 					a task is waiting on it or not. */
4159:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
4160:FreeRTOS/Source/tasks.c **** 				}
4161:FreeRTOS/Source/tasks.c **** 				else
4162:FreeRTOS/Source/tasks.c **** 				{
4163:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4164:FreeRTOS/Source/tasks.c **** 				}
4165:FreeRTOS/Source/tasks.c **** 			}
4166:FreeRTOS/Source/tasks.c **** 			else
4167:FreeRTOS/Source/tasks.c **** 			{
4168:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4169:FreeRTOS/Source/tasks.c **** 			}
4170:FreeRTOS/Source/tasks.c **** 		}
4171:FreeRTOS/Source/tasks.c **** 		else
4172:FreeRTOS/Source/tasks.c **** 		{
4173:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4174:FreeRTOS/Source/tasks.c **** 		}
4175:FreeRTOS/Source/tasks.c **** 
4176:FreeRTOS/Source/tasks.c **** 		return xReturn;
4177:FreeRTOS/Source/tasks.c **** 	}
4178:FreeRTOS/Source/tasks.c **** 
4179:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4180:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4181:FreeRTOS/Source/tasks.c **** 
4182:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4183:FreeRTOS/Source/tasks.c **** 
4184:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestP
4185:FreeRTOS/Source/tasks.c **** 	{
4186:FreeRTOS/Source/tasks.c **** 	TCB_t * const pxTCB = pxMutexHolder;
ARM GAS  /tmp/cckqXCjj.s 			page 144


4187:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4188:FreeRTOS/Source/tasks.c **** 	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
4189:FreeRTOS/Source/tasks.c **** 
4190:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
4191:FreeRTOS/Source/tasks.c **** 		{
4192:FreeRTOS/Source/tasks.c **** 			/* If pxMutexHolder is not NULL then the holder must hold at least
4193:FreeRTOS/Source/tasks.c **** 			one mutex. */
4194:FreeRTOS/Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
4195:FreeRTOS/Source/tasks.c **** 
4196:FreeRTOS/Source/tasks.c **** 			/* Determine the priority to which the priority of the task that
4197:FreeRTOS/Source/tasks.c **** 			holds the mutex should be set.  This will be the greater of the
4198:FreeRTOS/Source/tasks.c **** 			holding task's base priority and the priority of the highest
4199:FreeRTOS/Source/tasks.c **** 			priority task that is waiting to obtain the mutex. */
4200:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
4201:FreeRTOS/Source/tasks.c **** 			{
4202:FreeRTOS/Source/tasks.c **** 				uxPriorityToUse = uxHighestPriorityWaitingTask;
4203:FreeRTOS/Source/tasks.c **** 			}
4204:FreeRTOS/Source/tasks.c **** 			else
4205:FreeRTOS/Source/tasks.c **** 			{
4206:FreeRTOS/Source/tasks.c **** 				uxPriorityToUse = pxTCB->uxBasePriority;
4207:FreeRTOS/Source/tasks.c **** 			}
4208:FreeRTOS/Source/tasks.c **** 
4209:FreeRTOS/Source/tasks.c **** 			/* Does the priority need to change? */
4210:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != uxPriorityToUse )
4211:FreeRTOS/Source/tasks.c **** 			{
4212:FreeRTOS/Source/tasks.c **** 				/* Only disinherit if no other mutexes are held.  This is a
4213:FreeRTOS/Source/tasks.c **** 				simplification in the priority inheritance implementation.  If
4214:FreeRTOS/Source/tasks.c **** 				the task that holds the mutex is also holding other mutexes then
4215:FreeRTOS/Source/tasks.c **** 				the other mutexes may have caused the priority inheritance. */
4216:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
4217:FreeRTOS/Source/tasks.c **** 				{
4218:FreeRTOS/Source/tasks.c **** 					/* If a task has timed out because it already holds the
4219:FreeRTOS/Source/tasks.c **** 					mutex it was trying to obtain then it cannot of inherited
4220:FreeRTOS/Source/tasks.c **** 					its own priority. */
4221:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB != pxCurrentTCB );
4222:FreeRTOS/Source/tasks.c **** 
4223:FreeRTOS/Source/tasks.c **** 					/* Disinherit the priority, remembering the previous
4224:FreeRTOS/Source/tasks.c **** 					priority to facilitate determining the subject task's
4225:FreeRTOS/Source/tasks.c **** 					state. */
4226:FreeRTOS/Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4227:FreeRTOS/Source/tasks.c **** 					uxPriorityUsedOnEntry = pxTCB->uxPriority;
4228:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxPriorityToUse;
4229:FreeRTOS/Source/tasks.c **** 
4230:FreeRTOS/Source/tasks.c **** 					/* Only reset the event list item value if the value is not
4231:FreeRTOS/Source/tasks.c **** 					being used for anything else. */
4232:FreeRTOS/Source/tasks.c **** 					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE
4233:FreeRTOS/Source/tasks.c **** 					{
4234:FreeRTOS/Source/tasks.c **** 						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( 
4235:FreeRTOS/Source/tasks.c **** 					}
4236:FreeRTOS/Source/tasks.c **** 					else
4237:FreeRTOS/Source/tasks.c **** 					{
4238:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4239:FreeRTOS/Source/tasks.c **** 					}
4240:FreeRTOS/Source/tasks.c **** 
4241:FreeRTOS/Source/tasks.c **** 					/* If the running task is not the task that holds the mutex
4242:FreeRTOS/Source/tasks.c **** 					then the task that holds the mutex could be in either the
4243:FreeRTOS/Source/tasks.c **** 					Ready, Blocked or Suspended states.  Only remove the task
ARM GAS  /tmp/cckqXCjj.s 			page 145


4244:FreeRTOS/Source/tasks.c **** 					from its current state list if it is in the Ready state as
4245:FreeRTOS/Source/tasks.c **** 					the task's priority is going to change and there is one
4246:FreeRTOS/Source/tasks.c **** 					Ready list per priority. */
4247:FreeRTOS/Source/tasks.c **** 					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xState
4248:FreeRTOS/Source/tasks.c **** 					{
4249:FreeRTOS/Source/tasks.c **** 						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
4250:FreeRTOS/Source/tasks.c **** 						{
4251:FreeRTOS/Source/tasks.c **** 							/* It is known that the task is in its ready list so
4252:FreeRTOS/Source/tasks.c **** 							there is no need to check again and the port level
4253:FreeRTOS/Source/tasks.c **** 							reset macro can be called directly. */
4254:FreeRTOS/Source/tasks.c **** 							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
4255:FreeRTOS/Source/tasks.c **** 						}
4256:FreeRTOS/Source/tasks.c **** 						else
4257:FreeRTOS/Source/tasks.c **** 						{
4258:FreeRTOS/Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
4259:FreeRTOS/Source/tasks.c **** 						}
4260:FreeRTOS/Source/tasks.c **** 
4261:FreeRTOS/Source/tasks.c **** 						prvAddTaskToReadyList( pxTCB );
4262:FreeRTOS/Source/tasks.c **** 					}
4263:FreeRTOS/Source/tasks.c **** 					else
4264:FreeRTOS/Source/tasks.c **** 					{
4265:FreeRTOS/Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
4266:FreeRTOS/Source/tasks.c **** 					}
4267:FreeRTOS/Source/tasks.c **** 				}
4268:FreeRTOS/Source/tasks.c **** 				else
4269:FreeRTOS/Source/tasks.c **** 				{
4270:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4271:FreeRTOS/Source/tasks.c **** 				}
4272:FreeRTOS/Source/tasks.c **** 			}
4273:FreeRTOS/Source/tasks.c **** 			else
4274:FreeRTOS/Source/tasks.c **** 			{
4275:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4276:FreeRTOS/Source/tasks.c **** 			}
4277:FreeRTOS/Source/tasks.c **** 		}
4278:FreeRTOS/Source/tasks.c **** 		else
4279:FreeRTOS/Source/tasks.c **** 		{
4280:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4281:FreeRTOS/Source/tasks.c **** 		}
4282:FreeRTOS/Source/tasks.c **** 	}
4283:FreeRTOS/Source/tasks.c **** 
4284:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4285:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4286:FreeRTOS/Source/tasks.c **** 
4287:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4288:FreeRTOS/Source/tasks.c **** 
4289:FreeRTOS/Source/tasks.c **** 	void vTaskEnterCritical( void )
4290:FreeRTOS/Source/tasks.c **** 	{
4291:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
4292:FreeRTOS/Source/tasks.c **** 
4293:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4294:FreeRTOS/Source/tasks.c **** 		{
4295:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
4296:FreeRTOS/Source/tasks.c **** 
4297:FreeRTOS/Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
4298:FreeRTOS/Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
4299:FreeRTOS/Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
4300:FreeRTOS/Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
ARM GAS  /tmp/cckqXCjj.s 			page 146


4301:FreeRTOS/Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
4302:FreeRTOS/Source/tasks.c **** 			critical section. */
4303:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
4304:FreeRTOS/Source/tasks.c **** 			{
4305:FreeRTOS/Source/tasks.c **** 				portASSERT_IF_IN_ISR();
4306:FreeRTOS/Source/tasks.c **** 			}
4307:FreeRTOS/Source/tasks.c **** 		}
4308:FreeRTOS/Source/tasks.c **** 		else
4309:FreeRTOS/Source/tasks.c **** 		{
4310:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4311:FreeRTOS/Source/tasks.c **** 		}
4312:FreeRTOS/Source/tasks.c **** 	}
4313:FreeRTOS/Source/tasks.c **** 
4314:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4315:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4316:FreeRTOS/Source/tasks.c **** 
4317:FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4318:FreeRTOS/Source/tasks.c **** 
4319:FreeRTOS/Source/tasks.c **** 	void vTaskExitCritical( void )
4320:FreeRTOS/Source/tasks.c **** 	{
4321:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
4322:FreeRTOS/Source/tasks.c **** 		{
4323:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
4324:FreeRTOS/Source/tasks.c **** 			{
4325:FreeRTOS/Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
4326:FreeRTOS/Source/tasks.c **** 
4327:FreeRTOS/Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
4328:FreeRTOS/Source/tasks.c **** 				{
4329:FreeRTOS/Source/tasks.c **** 					portENABLE_INTERRUPTS();
4330:FreeRTOS/Source/tasks.c **** 				}
4331:FreeRTOS/Source/tasks.c **** 				else
4332:FreeRTOS/Source/tasks.c **** 				{
4333:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4334:FreeRTOS/Source/tasks.c **** 				}
4335:FreeRTOS/Source/tasks.c **** 			}
4336:FreeRTOS/Source/tasks.c **** 			else
4337:FreeRTOS/Source/tasks.c **** 			{
4338:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4339:FreeRTOS/Source/tasks.c **** 			}
4340:FreeRTOS/Source/tasks.c **** 		}
4341:FreeRTOS/Source/tasks.c **** 		else
4342:FreeRTOS/Source/tasks.c **** 		{
4343:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4344:FreeRTOS/Source/tasks.c **** 		}
4345:FreeRTOS/Source/tasks.c **** 	}
4346:FreeRTOS/Source/tasks.c **** 
4347:FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4348:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4349:FreeRTOS/Source/tasks.c **** 
4350:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4351:FreeRTOS/Source/tasks.c **** 
4352:FreeRTOS/Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
4353:FreeRTOS/Source/tasks.c **** 	{
4354:FreeRTOS/Source/tasks.c **** 	size_t x;
4355:FreeRTOS/Source/tasks.c **** 
4356:FreeRTOS/Source/tasks.c **** 		/* Start by copying the entire string. */
4357:FreeRTOS/Source/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
ARM GAS  /tmp/cckqXCjj.s 			page 147


4358:FreeRTOS/Source/tasks.c **** 
4359:FreeRTOS/Source/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
4360:FreeRTOS/Source/tasks.c **** 		printed out. */
4361:FreeRTOS/Source/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4362:FreeRTOS/Source/tasks.c **** 		{
4363:FreeRTOS/Source/tasks.c **** 			pcBuffer[ x ] = ' ';
4364:FreeRTOS/Source/tasks.c **** 		}
4365:FreeRTOS/Source/tasks.c **** 
4366:FreeRTOS/Source/tasks.c **** 		/* Terminate. */
4367:FreeRTOS/Source/tasks.c **** 		pcBuffer[ x ] = ( char ) 0x00;
4368:FreeRTOS/Source/tasks.c **** 
4369:FreeRTOS/Source/tasks.c **** 		/* Return the new end of string. */
4370:FreeRTOS/Source/tasks.c **** 		return &( pcBuffer[ x ] );
4371:FreeRTOS/Source/tasks.c **** 	}
4372:FreeRTOS/Source/tasks.c **** 
4373:FreeRTOS/Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4374:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4375:FreeRTOS/Source/tasks.c **** 
4376:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( config
4377:FreeRTOS/Source/tasks.c **** 
4378:FreeRTOS/Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
4379:FreeRTOS/Source/tasks.c **** 	{
4380:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4381:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4382:FreeRTOS/Source/tasks.c **** 	char cStatus;
4383:FreeRTOS/Source/tasks.c **** 
4384:FreeRTOS/Source/tasks.c **** 		/*
4385:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
4386:FreeRTOS/Source/tasks.c **** 		 *
4387:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4388:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4389:FreeRTOS/Source/tasks.c **** 		 * scheduler.
4390:FreeRTOS/Source/tasks.c **** 		 *
4391:FreeRTOS/Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4392:FreeRTOS/Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
4393:FreeRTOS/Source/tasks.c **** 		 * displays task names, states and stack usage.
4394:FreeRTOS/Source/tasks.c **** 		 *
4395:FreeRTOS/Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
4396:FreeRTOS/Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
4397:FreeRTOS/Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
4398:FreeRTOS/Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
4399:FreeRTOS/Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
4400:FreeRTOS/Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
4401:FreeRTOS/Source/tasks.c **** 		 * snprintf() implementation!).
4402:FreeRTOS/Source/tasks.c **** 		 *
4403:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4404:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4405:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskList().
4406:FreeRTOS/Source/tasks.c **** 		 */
4407:FreeRTOS/Source/tasks.c **** 
4408:FreeRTOS/Source/tasks.c **** 
4409:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4410:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4411:FreeRTOS/Source/tasks.c **** 
4412:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4413:FreeRTOS/Source/tasks.c **** 		function is executing. */
4414:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
ARM GAS  /tmp/cckqXCjj.s 			page 148


4415:FreeRTOS/Source/tasks.c **** 
4416:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
4417:FreeRTOS/Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4418:FreeRTOS/Source/tasks.c **** 		equate to NULL. */
4419:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4420:FreeRTOS/Source/tasks.c **** 
4421:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4422:FreeRTOS/Source/tasks.c **** 		{
4423:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
4424:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4425:FreeRTOS/Source/tasks.c **** 
4426:FreeRTOS/Source/tasks.c **** 			/* Create a human readable table from the binary data. */
4427:FreeRTOS/Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
4428:FreeRTOS/Source/tasks.c **** 			{
4429:FreeRTOS/Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
4430:FreeRTOS/Source/tasks.c **** 				{
4431:FreeRTOS/Source/tasks.c **** 					case eRunning:		cStatus = tskRUNNING_CHAR;
4432:FreeRTOS/Source/tasks.c **** 										break;
4433:FreeRTOS/Source/tasks.c **** 
4434:FreeRTOS/Source/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
4435:FreeRTOS/Source/tasks.c **** 										break;
4436:FreeRTOS/Source/tasks.c **** 
4437:FreeRTOS/Source/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
4438:FreeRTOS/Source/tasks.c **** 										break;
4439:FreeRTOS/Source/tasks.c **** 
4440:FreeRTOS/Source/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4441:FreeRTOS/Source/tasks.c **** 										break;
4442:FreeRTOS/Source/tasks.c **** 
4443:FreeRTOS/Source/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
4444:FreeRTOS/Source/tasks.c **** 										break;
4445:FreeRTOS/Source/tasks.c **** 
4446:FreeRTOS/Source/tasks.c **** 					case eInvalid:		/* Fall through. */
4447:FreeRTOS/Source/tasks.c **** 					default:			/* Should not get here, but it is included
4448:FreeRTOS/Source/tasks.c **** 										to prevent static checking errors. */
4449:FreeRTOS/Source/tasks.c **** 										cStatus = ( char ) 0x00;
4450:FreeRTOS/Source/tasks.c **** 										break;
4451:FreeRTOS/Source/tasks.c **** 				}
4452:FreeRTOS/Source/tasks.c **** 
4453:FreeRTOS/Source/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
4454:FreeRTOS/Source/tasks.c **** 				can be printed in tabular form more easily. */
4455:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4456:FreeRTOS/Source/tasks.c **** 
4457:FreeRTOS/Source/tasks.c **** 				/* Write the rest of the string. */
4458:FreeRTOS/Source/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
4459:FreeRTOS/Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers 
4460:FreeRTOS/Source/tasks.c **** 			}
4461:FreeRTOS/Source/tasks.c **** 
4462:FreeRTOS/Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4463:FreeRTOS/Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4464:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4465:FreeRTOS/Source/tasks.c **** 		}
4466:FreeRTOS/Source/tasks.c **** 		else
4467:FreeRTOS/Source/tasks.c **** 		{
4468:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4469:FreeRTOS/Source/tasks.c **** 		}
4470:FreeRTOS/Source/tasks.c **** 	}
4471:FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/cckqXCjj.s 			page 149


4472:FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( 
4473:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
4474:FreeRTOS/Source/tasks.c **** 
4475:FreeRTOS/Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4476:FreeRTOS/Source/tasks.c **** 
4477:FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4478:FreeRTOS/Source/tasks.c **** 	{
4479:FreeRTOS/Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4480:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxArraySize, x;
4481:FreeRTOS/Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
4482:FreeRTOS/Source/tasks.c **** 
4483:FreeRTOS/Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
4484:FreeRTOS/Source/tasks.c **** 		{
4485:FreeRTOS/Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
4486:FreeRTOS/Source/tasks.c **** 		}
4487:FreeRTOS/Source/tasks.c **** 		#endif
4488:FreeRTOS/Source/tasks.c **** 
4489:FreeRTOS/Source/tasks.c **** 		/*
4490:FreeRTOS/Source/tasks.c **** 		 * PLEASE NOTE:
4491:FreeRTOS/Source/tasks.c **** 		 *
4492:FreeRTOS/Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4493:FreeRTOS/Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4494:FreeRTOS/Source/tasks.c **** 		 * scheduler.
4495:FreeRTOS/Source/tasks.c **** 		 *
4496:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4497:FreeRTOS/Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
4498:FreeRTOS/Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
4499:FreeRTOS/Source/tasks.c **** 		 * in both absolute and percentage terms.
4500:FreeRTOS/Source/tasks.c **** 		 *
4501:FreeRTOS/Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4502:FreeRTOS/Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
4503:FreeRTOS/Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
4504:FreeRTOS/Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
4505:FreeRTOS/Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4506:FreeRTOS/Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4507:FreeRTOS/Source/tasks.c **** 		 * a full snprintf() implementation!).
4508:FreeRTOS/Source/tasks.c **** 		 *
4509:FreeRTOS/Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4510:FreeRTOS/Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4511:FreeRTOS/Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
4512:FreeRTOS/Source/tasks.c **** 		 */
4513:FreeRTOS/Source/tasks.c **** 
4514:FreeRTOS/Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4515:FreeRTOS/Source/tasks.c **** 		*pcWriteBuffer = ( char ) 0x00;
4516:FreeRTOS/Source/tasks.c **** 
4517:FreeRTOS/Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4518:FreeRTOS/Source/tasks.c **** 		function is executing. */
4519:FreeRTOS/Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4520:FreeRTOS/Source/tasks.c **** 
4521:FreeRTOS/Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
4522:FreeRTOS/Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4523:FreeRTOS/Source/tasks.c **** 		equate to NULL. */
4524:FreeRTOS/Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e907
4525:FreeRTOS/Source/tasks.c **** 
4526:FreeRTOS/Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4527:FreeRTOS/Source/tasks.c **** 		{
4528:FreeRTOS/Source/tasks.c **** 			/* Generate the (binary) data. */
ARM GAS  /tmp/cckqXCjj.s 			page 150


4529:FreeRTOS/Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4530:FreeRTOS/Source/tasks.c **** 
4531:FreeRTOS/Source/tasks.c **** 			/* For percentage calculations. */
4532:FreeRTOS/Source/tasks.c **** 			ulTotalTime /= 100UL;
4533:FreeRTOS/Source/tasks.c **** 
4534:FreeRTOS/Source/tasks.c **** 			/* Avoid divide by zero errors. */
4535:FreeRTOS/Source/tasks.c **** 			if( ulTotalTime > 0UL )
4536:FreeRTOS/Source/tasks.c **** 			{
4537:FreeRTOS/Source/tasks.c **** 				/* Create a human readable table from the binary data. */
4538:FreeRTOS/Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
4539:FreeRTOS/Source/tasks.c **** 				{
4540:FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
4541:FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
4542:FreeRTOS/Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
4543:FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4544:FreeRTOS/Source/tasks.c **** 
4545:FreeRTOS/Source/tasks.c **** 					/* Write the task name to the string, padding with
4546:FreeRTOS/Source/tasks.c **** 					spaces so it can be printed in tabular form more
4547:FreeRTOS/Source/tasks.c **** 					easily. */
4548:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4549:FreeRTOS/Source/tasks.c **** 
4550:FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
4551:FreeRTOS/Source/tasks.c **** 					{
4552:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4553:FreeRTOS/Source/tasks.c **** 						{
4554:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
4555:FreeRTOS/Source/tasks.c **** 						}
4556:FreeRTOS/Source/tasks.c **** 						#else
4557:FreeRTOS/Source/tasks.c **** 						{
4558:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4559:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
4560:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4561:FreeRTOS/Source/tasks.c **** 						}
4562:FreeRTOS/Source/tasks.c **** 						#endif
4563:FreeRTOS/Source/tasks.c **** 					}
4564:FreeRTOS/Source/tasks.c **** 					else
4565:FreeRTOS/Source/tasks.c **** 					{
4566:FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
4567:FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
4568:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4569:FreeRTOS/Source/tasks.c **** 						{
4570:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4571:FreeRTOS/Source/tasks.c **** 						}
4572:FreeRTOS/Source/tasks.c **** 						#else
4573:FreeRTOS/Source/tasks.c **** 						{
4574:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4575:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
4576:FreeRTOS/Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4577:FreeRTOS/Source/tasks.c **** 						}
4578:FreeRTOS/Source/tasks.c **** 						#endif
4579:FreeRTOS/Source/tasks.c **** 					}
4580:FreeRTOS/Source/tasks.c **** 
4581:FreeRTOS/Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers
4582:FreeRTOS/Source/tasks.c **** 				}
4583:FreeRTOS/Source/tasks.c **** 			}
4584:FreeRTOS/Source/tasks.c **** 			else
4585:FreeRTOS/Source/tasks.c **** 			{
ARM GAS  /tmp/cckqXCjj.s 			page 151


4586:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4587:FreeRTOS/Source/tasks.c **** 			}
4588:FreeRTOS/Source/tasks.c **** 
4589:FreeRTOS/Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4590:FreeRTOS/Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4591:FreeRTOS/Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4592:FreeRTOS/Source/tasks.c **** 		}
4593:FreeRTOS/Source/tasks.c **** 		else
4594:FreeRTOS/Source/tasks.c **** 		{
4595:FreeRTOS/Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4596:FreeRTOS/Source/tasks.c **** 		}
4597:FreeRTOS/Source/tasks.c **** 	}
4598:FreeRTOS/Source/tasks.c **** 
4599:FreeRTOS/Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4600:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4601:FreeRTOS/Source/tasks.c **** 
4602:FreeRTOS/Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4603:FreeRTOS/Source/tasks.c **** {
 3686              		.loc 1 4603 0
 3687              		.cfi_startproc
 3688              		@ args = 0, pretend = 0, frame = 8
 3689              		@ frame_needed = 1, uses_anonymous_args = 0
 3690              		@ link register save eliminated.
 3691 1104 80B4     		push	{r7}
 3692              		.cfi_def_cfa_offset 4
 3693              		.cfi_offset 7, -4
 3694 1106 83B0     		sub	sp, sp, #12
 3695              		.cfi_def_cfa_offset 16
 3696 1108 00AF     		add	r7, sp, #0
 3697              		.cfi_def_cfa_register 7
4604:FreeRTOS/Source/tasks.c **** TickType_t uxReturn;
4605:FreeRTOS/Source/tasks.c **** 
4606:FreeRTOS/Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 3698              		.loc 1 4606 0
 3699 110a 094B     		ldr	r3, .L248
 3700 110c 1B68     		ldr	r3, [r3]
 3701 110e 9B69     		ldr	r3, [r3, #24]
 3702 1110 7B60     		str	r3, [r7, #4]
4607:FreeRTOS/Source/tasks.c **** 
4608:FreeRTOS/Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4609:FreeRTOS/Source/tasks.c **** 	queues and semaphores. */
4610:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
 3703              		.loc 1 4610 0
 3704 1112 074B     		ldr	r3, .L248
 3705 1114 1B68     		ldr	r3, [r3]
 3706 1116 064A     		ldr	r2, .L248
 3707 1118 1268     		ldr	r2, [r2]
 3708 111a D26A     		ldr	r2, [r2, #44]
 3709 111c C2F10502 		rsb	r2, r2, #5
 3710 1120 9A61     		str	r2, [r3, #24]
4611:FreeRTOS/Source/tasks.c **** 
4612:FreeRTOS/Source/tasks.c **** 	return uxReturn;
 3711              		.loc 1 4612 0
 3712 1122 7B68     		ldr	r3, [r7, #4]
4613:FreeRTOS/Source/tasks.c **** }
 3713              		.loc 1 4613 0
 3714 1124 1846     		mov	r0, r3
ARM GAS  /tmp/cckqXCjj.s 			page 152


 3715 1126 0C37     		adds	r7, r7, #12
 3716              		.cfi_def_cfa_offset 4
 3717 1128 BD46     		mov	sp, r7
 3718              		.cfi_def_cfa_register 13
 3719              		@ sp needed
 3720 112a 80BC     		pop	{r7}
 3721              		.cfi_restore 7
 3722              		.cfi_def_cfa_offset 0
 3723 112c 7047     		bx	lr
 3724              	.L249:
 3725 112e 00BF     		.align	2
 3726              	.L248:
 3727 1130 00000000 		.word	pxCurrentTCB
 3728              		.cfi_endproc
 3729              	.LFE43:
 3730              		.size	uxTaskResetEventItemValue, .-uxTaskResetEventItemValue
 3731              		.align	1
 3732              		.global	ulTaskNotifyTake
 3733              		.syntax unified
 3734              		.thumb
 3735              		.thumb_func
 3736              		.fpu softvfp
 3737              		.type	ulTaskNotifyTake, %function
 3738              	ulTaskNotifyTake:
 3739              	.LFB44:
4614:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4615:FreeRTOS/Source/tasks.c **** 
4616:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4617:FreeRTOS/Source/tasks.c **** 
4618:FreeRTOS/Source/tasks.c **** 	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
4619:FreeRTOS/Source/tasks.c **** 	{
4620:FreeRTOS/Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4621:FreeRTOS/Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
4622:FreeRTOS/Source/tasks.c **** 		if( pxCurrentTCB != NULL )
4623:FreeRTOS/Source/tasks.c **** 		{
4624:FreeRTOS/Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
4625:FreeRTOS/Source/tasks.c **** 		}
4626:FreeRTOS/Source/tasks.c **** 
4627:FreeRTOS/Source/tasks.c **** 		return pxCurrentTCB;
4628:FreeRTOS/Source/tasks.c **** 	}
4629:FreeRTOS/Source/tasks.c **** 
4630:FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4631:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4632:FreeRTOS/Source/tasks.c **** 
4633:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4634:FreeRTOS/Source/tasks.c **** 
4635:FreeRTOS/Source/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4636:FreeRTOS/Source/tasks.c **** 	{
 3740              		.loc 1 4636 0
 3741              		.cfi_startproc
 3742              		@ args = 0, pretend = 0, frame = 16
 3743              		@ frame_needed = 1, uses_anonymous_args = 0
 3744 1134 80B5     		push	{r7, lr}
 3745              		.cfi_def_cfa_offset 8
 3746              		.cfi_offset 7, -8
 3747              		.cfi_offset 14, -4
 3748 1136 84B0     		sub	sp, sp, #16
ARM GAS  /tmp/cckqXCjj.s 			page 153


 3749              		.cfi_def_cfa_offset 24
 3750 1138 00AF     		add	r7, sp, #0
 3751              		.cfi_def_cfa_register 7
 3752 113a 7860     		str	r0, [r7, #4]
 3753 113c 3960     		str	r1, [r7]
4637:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
4638:FreeRTOS/Source/tasks.c **** 
4639:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 3754              		.loc 1 4639 0
 3755 113e FFF7FEFF 		bl	vPortEnterCritical
4640:FreeRTOS/Source/tasks.c **** 		{
4641:FreeRTOS/Source/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4642:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 3756              		.loc 1 4642 0
 3757 1142 1E4B     		ldr	r3, .L256
 3758 1144 1B68     		ldr	r3, [r3]
 3759 1146 5B6C     		ldr	r3, [r3, #68]
 3760 1148 002B     		cmp	r3, #0
 3761 114a 13D1     		bne	.L251
4643:FreeRTOS/Source/tasks.c **** 			{
4644:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4645:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 3762              		.loc 1 4645 0
 3763 114c 1B4B     		ldr	r3, .L256
 3764 114e 1B68     		ldr	r3, [r3]
 3765 1150 0122     		movs	r2, #1
 3766 1152 83F84820 		strb	r2, [r3, #72]
4646:FreeRTOS/Source/tasks.c **** 
4647:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 3767              		.loc 1 4647 0
 3768 1156 3B68     		ldr	r3, [r7]
 3769 1158 002B     		cmp	r3, #0
 3770 115a 0BD0     		beq	.L251
4648:FreeRTOS/Source/tasks.c **** 				{
4649:FreeRTOS/Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 3771              		.loc 1 4649 0
 3772 115c 0121     		movs	r1, #1
 3773 115e 3868     		ldr	r0, [r7]
 3774 1160 00F076FA 		bl	prvAddCurrentTaskToDelayedList
4650:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4651:FreeRTOS/Source/tasks.c **** 
4652:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4653:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
4654:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
4655:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
4656:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 3775              		.loc 1 4656 0
 3776 1164 164B     		ldr	r3, .L256+4
 3777 1166 4FF08052 		mov	r2, #268435456
 3778 116a 1A60     		str	r2, [r3]
 3779              		.syntax unified
 3780              	@ 4656 "FreeRTOS/Source/tasks.c" 1
 3781 116c BFF34F8F 		dsb
 3782              	@ 0 "" 2
 3783              	@ 4656 "FreeRTOS/Source/tasks.c" 1
 3784 1170 BFF36F8F 		isb
 3785              	@ 0 "" 2
ARM GAS  /tmp/cckqXCjj.s 			page 154


 3786              		.thumb
 3787              		.syntax unified
 3788              	.L251:
4657:FreeRTOS/Source/tasks.c **** 				}
4658:FreeRTOS/Source/tasks.c **** 				else
4659:FreeRTOS/Source/tasks.c **** 				{
4660:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4661:FreeRTOS/Source/tasks.c **** 				}
4662:FreeRTOS/Source/tasks.c **** 			}
4663:FreeRTOS/Source/tasks.c **** 			else
4664:FreeRTOS/Source/tasks.c **** 			{
4665:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4666:FreeRTOS/Source/tasks.c **** 			}
4667:FreeRTOS/Source/tasks.c **** 		}
4668:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 3789              		.loc 1 4668 0
 3790 1174 FFF7FEFF 		bl	vPortExitCritical
4669:FreeRTOS/Source/tasks.c **** 
4670:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 3791              		.loc 1 4670 0
 3792 1178 FFF7FEFF 		bl	vPortEnterCritical
4671:FreeRTOS/Source/tasks.c **** 		{
4672:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4673:FreeRTOS/Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
 3793              		.loc 1 4673 0
 3794 117c 0F4B     		ldr	r3, .L256
 3795 117e 1B68     		ldr	r3, [r3]
 3796 1180 5B6C     		ldr	r3, [r3, #68]
 3797 1182 FB60     		str	r3, [r7, #12]
4674:FreeRTOS/Source/tasks.c **** 
4675:FreeRTOS/Source/tasks.c **** 			if( ulReturn != 0UL )
 3798              		.loc 1 4675 0
 3799 1184 FB68     		ldr	r3, [r7, #12]
 3800 1186 002B     		cmp	r3, #0
 3801 1188 0CD0     		beq	.L252
4676:FreeRTOS/Source/tasks.c **** 			{
4677:FreeRTOS/Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
 3802              		.loc 1 4677 0
 3803 118a 7B68     		ldr	r3, [r7, #4]
 3804 118c 002B     		cmp	r3, #0
 3805 118e 04D0     		beq	.L253
4678:FreeRTOS/Source/tasks.c **** 				{
4679:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
 3806              		.loc 1 4679 0
 3807 1190 0A4B     		ldr	r3, .L256
 3808 1192 1B68     		ldr	r3, [r3]
 3809 1194 0022     		movs	r2, #0
 3810 1196 5A64     		str	r2, [r3, #68]
 3811 1198 04E0     		b	.L252
 3812              	.L253:
4680:FreeRTOS/Source/tasks.c **** 				}
4681:FreeRTOS/Source/tasks.c **** 				else
4682:FreeRTOS/Source/tasks.c **** 				{
4683:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
 3813              		.loc 1 4683 0
 3814 119a 084B     		ldr	r3, .L256
 3815 119c 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/cckqXCjj.s 			page 155


 3816 119e FA68     		ldr	r2, [r7, #12]
 3817 11a0 013A     		subs	r2, r2, #1
 3818 11a2 5A64     		str	r2, [r3, #68]
 3819              	.L252:
4684:FreeRTOS/Source/tasks.c **** 				}
4685:FreeRTOS/Source/tasks.c **** 			}
4686:FreeRTOS/Source/tasks.c **** 			else
4687:FreeRTOS/Source/tasks.c **** 			{
4688:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4689:FreeRTOS/Source/tasks.c **** 			}
4690:FreeRTOS/Source/tasks.c **** 
4691:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 3820              		.loc 1 4691 0
 3821 11a4 054B     		ldr	r3, .L256
 3822 11a6 1B68     		ldr	r3, [r3]
 3823 11a8 0022     		movs	r2, #0
 3824 11aa 83F84820 		strb	r2, [r3, #72]
4692:FreeRTOS/Source/tasks.c **** 		}
4693:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 3825              		.loc 1 4693 0
 3826 11ae FFF7FEFF 		bl	vPortExitCritical
4694:FreeRTOS/Source/tasks.c **** 
4695:FreeRTOS/Source/tasks.c **** 		return ulReturn;
 3827              		.loc 1 4695 0
 3828 11b2 FB68     		ldr	r3, [r7, #12]
4696:FreeRTOS/Source/tasks.c **** 	}
 3829              		.loc 1 4696 0
 3830 11b4 1846     		mov	r0, r3
 3831 11b6 1037     		adds	r7, r7, #16
 3832              		.cfi_def_cfa_offset 8
 3833 11b8 BD46     		mov	sp, r7
 3834              		.cfi_def_cfa_register 13
 3835              		@ sp needed
 3836 11ba 80BD     		pop	{r7, pc}
 3837              	.L257:
 3838              		.align	2
 3839              	.L256:
 3840 11bc 00000000 		.word	pxCurrentTCB
 3841 11c0 04ED00E0 		.word	-536810236
 3842              		.cfi_endproc
 3843              	.LFE44:
 3844              		.size	ulTaskNotifyTake, .-ulTaskNotifyTake
 3845              		.align	1
 3846              		.global	xTaskNotifyWait
 3847              		.syntax unified
 3848              		.thumb
 3849              		.thumb_func
 3850              		.fpu softvfp
 3851              		.type	xTaskNotifyWait, %function
 3852              	xTaskNotifyWait:
 3853              	.LFB45:
4697:FreeRTOS/Source/tasks.c **** 
4698:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4699:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4700:FreeRTOS/Source/tasks.c **** 
4701:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4702:FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/cckqXCjj.s 			page 156


4703:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4704:FreeRTOS/Source/tasks.c **** 	{
 3854              		.loc 1 4704 0
 3855              		.cfi_startproc
 3856              		@ args = 0, pretend = 0, frame = 24
 3857              		@ frame_needed = 1, uses_anonymous_args = 0
 3858 11c4 80B5     		push	{r7, lr}
 3859              		.cfi_def_cfa_offset 8
 3860              		.cfi_offset 7, -8
 3861              		.cfi_offset 14, -4
 3862 11c6 86B0     		sub	sp, sp, #24
 3863              		.cfi_def_cfa_offset 32
 3864 11c8 00AF     		add	r7, sp, #0
 3865              		.cfi_def_cfa_register 7
 3866 11ca F860     		str	r0, [r7, #12]
 3867 11cc B960     		str	r1, [r7, #8]
 3868 11ce 7A60     		str	r2, [r7, #4]
 3869 11d0 3B60     		str	r3, [r7]
4705:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
4706:FreeRTOS/Source/tasks.c **** 
4707:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 3870              		.loc 1 4707 0
 3871 11d2 FFF7FEFF 		bl	vPortEnterCritical
4708:FreeRTOS/Source/tasks.c **** 		{
4709:FreeRTOS/Source/tasks.c **** 			/* Only block if a notification is not already pending. */
4710:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 3872              		.loc 1 4710 0
 3873 11d6 264B     		ldr	r3, .L264
 3874 11d8 1B68     		ldr	r3, [r3]
 3875 11da 93F84830 		ldrb	r3, [r3, #72]
 3876 11de DBB2     		uxtb	r3, r3
 3877 11e0 022B     		cmp	r3, #2
 3878 11e2 1AD0     		beq	.L259
4711:FreeRTOS/Source/tasks.c **** 			{
4712:FreeRTOS/Source/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4713:FreeRTOS/Source/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4714:FreeRTOS/Source/tasks.c **** 				clear the value to zero. */
4715:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 3879              		.loc 1 4715 0
 3880 11e4 224B     		ldr	r3, .L264
 3881 11e6 1B68     		ldr	r3, [r3]
 3882 11e8 596C     		ldr	r1, [r3, #68]
 3883 11ea FA68     		ldr	r2, [r7, #12]
 3884 11ec D243     		mvns	r2, r2
 3885 11ee 0A40     		ands	r2, r2, r1
 3886 11f0 5A64     		str	r2, [r3, #68]
4716:FreeRTOS/Source/tasks.c **** 
4717:FreeRTOS/Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4718:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 3887              		.loc 1 4718 0
 3888 11f2 1F4B     		ldr	r3, .L264
 3889 11f4 1B68     		ldr	r3, [r3]
 3890 11f6 0122     		movs	r2, #1
 3891 11f8 83F84820 		strb	r2, [r3, #72]
4719:FreeRTOS/Source/tasks.c **** 
4720:FreeRTOS/Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 3892              		.loc 1 4720 0
ARM GAS  /tmp/cckqXCjj.s 			page 157


 3893 11fc 3B68     		ldr	r3, [r7]
 3894 11fe 002B     		cmp	r3, #0
 3895 1200 0BD0     		beq	.L259
4721:FreeRTOS/Source/tasks.c **** 				{
4722:FreeRTOS/Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 3896              		.loc 1 4722 0
 3897 1202 0121     		movs	r1, #1
 3898 1204 3868     		ldr	r0, [r7]
 3899 1206 00F023FA 		bl	prvAddCurrentTaskToDelayedList
4723:FreeRTOS/Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4724:FreeRTOS/Source/tasks.c **** 
4725:FreeRTOS/Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4726:FreeRTOS/Source/tasks.c **** 					section (some will yield immediately, others wait until the
4727:FreeRTOS/Source/tasks.c **** 					critical section exits) - but it is not something that
4728:FreeRTOS/Source/tasks.c **** 					application code should ever do. */
4729:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 3900              		.loc 1 4729 0
 3901 120a 1A4B     		ldr	r3, .L264+4
 3902 120c 4FF08052 		mov	r2, #268435456
 3903 1210 1A60     		str	r2, [r3]
 3904              		.syntax unified
 3905              	@ 4729 "FreeRTOS/Source/tasks.c" 1
 3906 1212 BFF34F8F 		dsb
 3907              	@ 0 "" 2
 3908              	@ 4729 "FreeRTOS/Source/tasks.c" 1
 3909 1216 BFF36F8F 		isb
 3910              	@ 0 "" 2
 3911              		.thumb
 3912              		.syntax unified
 3913              	.L259:
4730:FreeRTOS/Source/tasks.c **** 				}
4731:FreeRTOS/Source/tasks.c **** 				else
4732:FreeRTOS/Source/tasks.c **** 				{
4733:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4734:FreeRTOS/Source/tasks.c **** 				}
4735:FreeRTOS/Source/tasks.c **** 			}
4736:FreeRTOS/Source/tasks.c **** 			else
4737:FreeRTOS/Source/tasks.c **** 			{
4738:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4739:FreeRTOS/Source/tasks.c **** 			}
4740:FreeRTOS/Source/tasks.c **** 		}
4741:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 3914              		.loc 1 4741 0
 3915 121a FFF7FEFF 		bl	vPortExitCritical
4742:FreeRTOS/Source/tasks.c **** 
4743:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 3916              		.loc 1 4743 0
 3917 121e FFF7FEFF 		bl	vPortEnterCritical
4744:FreeRTOS/Source/tasks.c **** 		{
4745:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4746:FreeRTOS/Source/tasks.c **** 
4747:FreeRTOS/Source/tasks.c **** 			if( pulNotificationValue != NULL )
 3918              		.loc 1 4747 0
 3919 1222 7B68     		ldr	r3, [r7, #4]
 3920 1224 002B     		cmp	r3, #0
 3921 1226 04D0     		beq	.L260
4748:FreeRTOS/Source/tasks.c **** 			{
ARM GAS  /tmp/cckqXCjj.s 			page 158


4749:FreeRTOS/Source/tasks.c **** 				/* Output the current notification value, which may or may not
4750:FreeRTOS/Source/tasks.c **** 				have changed. */
4751:FreeRTOS/Source/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 3922              		.loc 1 4751 0
 3923 1228 114B     		ldr	r3, .L264
 3924 122a 1B68     		ldr	r3, [r3]
 3925 122c 5A6C     		ldr	r2, [r3, #68]
 3926 122e 7B68     		ldr	r3, [r7, #4]
 3927 1230 1A60     		str	r2, [r3]
 3928              	.L260:
4752:FreeRTOS/Source/tasks.c **** 			}
4753:FreeRTOS/Source/tasks.c **** 
4754:FreeRTOS/Source/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4755:FreeRTOS/Source/tasks.c **** 			blocked state (because a notification was already pending) or the
4756:FreeRTOS/Source/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4757:FreeRTOS/Source/tasks.c **** 			unblocked because of a timeout. */
4758:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 3929              		.loc 1 4758 0
 3930 1232 0F4B     		ldr	r3, .L264
 3931 1234 1B68     		ldr	r3, [r3]
 3932 1236 93F84830 		ldrb	r3, [r3, #72]
 3933 123a DBB2     		uxtb	r3, r3
 3934 123c 022B     		cmp	r3, #2
 3935 123e 02D0     		beq	.L261
4759:FreeRTOS/Source/tasks.c **** 			{
4760:FreeRTOS/Source/tasks.c **** 				/* A notification was not received. */
4761:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
 3936              		.loc 1 4761 0
 3937 1240 0023     		movs	r3, #0
 3938 1242 7B61     		str	r3, [r7, #20]
 3939 1244 08E0     		b	.L262
 3940              	.L261:
4762:FreeRTOS/Source/tasks.c **** 			}
4763:FreeRTOS/Source/tasks.c **** 			else
4764:FreeRTOS/Source/tasks.c **** 			{
4765:FreeRTOS/Source/tasks.c **** 				/* A notification was already pending or a notification was
4766:FreeRTOS/Source/tasks.c **** 				received while the task was waiting. */
4767:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 3941              		.loc 1 4767 0
 3942 1246 0A4B     		ldr	r3, .L264
 3943 1248 1B68     		ldr	r3, [r3]
 3944 124a 596C     		ldr	r1, [r3, #68]
 3945 124c BA68     		ldr	r2, [r7, #8]
 3946 124e D243     		mvns	r2, r2
 3947 1250 0A40     		ands	r2, r2, r1
 3948 1252 5A64     		str	r2, [r3, #68]
4768:FreeRTOS/Source/tasks.c **** 				xReturn = pdTRUE;
 3949              		.loc 1 4768 0
 3950 1254 0123     		movs	r3, #1
 3951 1256 7B61     		str	r3, [r7, #20]
 3952              	.L262:
4769:FreeRTOS/Source/tasks.c **** 			}
4770:FreeRTOS/Source/tasks.c **** 
4771:FreeRTOS/Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 3953              		.loc 1 4771 0
 3954 1258 054B     		ldr	r3, .L264
 3955 125a 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/cckqXCjj.s 			page 159


 3956 125c 0022     		movs	r2, #0
 3957 125e 83F84820 		strb	r2, [r3, #72]
4772:FreeRTOS/Source/tasks.c **** 		}
4773:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 3958              		.loc 1 4773 0
 3959 1262 FFF7FEFF 		bl	vPortExitCritical
4774:FreeRTOS/Source/tasks.c **** 
4775:FreeRTOS/Source/tasks.c **** 		return xReturn;
 3960              		.loc 1 4775 0
 3961 1266 7B69     		ldr	r3, [r7, #20]
4776:FreeRTOS/Source/tasks.c **** 	}
 3962              		.loc 1 4776 0
 3963 1268 1846     		mov	r0, r3
 3964 126a 1837     		adds	r7, r7, #24
 3965              		.cfi_def_cfa_offset 8
 3966 126c BD46     		mov	sp, r7
 3967              		.cfi_def_cfa_register 13
 3968              		@ sp needed
 3969 126e 80BD     		pop	{r7, pc}
 3970              	.L265:
 3971              		.align	2
 3972              	.L264:
 3973 1270 00000000 		.word	pxCurrentTCB
 3974 1274 04ED00E0 		.word	-536810236
 3975              		.cfi_endproc
 3976              	.LFE45:
 3977              		.size	xTaskNotifyWait, .-xTaskNotifyWait
 3978              		.align	1
 3979              		.global	xTaskGenericNotify
 3980              		.syntax unified
 3981              		.thumb
 3982              		.thumb_func
 3983              		.fpu softvfp
 3984              		.type	xTaskGenericNotify, %function
 3985              	xTaskGenericNotify:
 3986              	.LFB46:
4777:FreeRTOS/Source/tasks.c **** 
4778:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4779:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4780:FreeRTOS/Source/tasks.c **** 
4781:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4782:FreeRTOS/Source/tasks.c **** 
4783:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4784:FreeRTOS/Source/tasks.c **** 	{
 3987              		.loc 1 4784 0
 3988              		.cfi_startproc
 3989              		@ args = 0, pretend = 0, frame = 32
 3990              		@ frame_needed = 1, uses_anonymous_args = 0
 3991 1278 80B5     		push	{r7, lr}
 3992              		.cfi_def_cfa_offset 8
 3993              		.cfi_offset 7, -8
 3994              		.cfi_offset 14, -4
 3995 127a 88B0     		sub	sp, sp, #32
 3996              		.cfi_def_cfa_offset 40
 3997 127c 00AF     		add	r7, sp, #0
 3998              		.cfi_def_cfa_register 7
 3999 127e F860     		str	r0, [r7, #12]
ARM GAS  /tmp/cckqXCjj.s 			page 160


 4000 1280 B960     		str	r1, [r7, #8]
 4001 1282 3B60     		str	r3, [r7]
 4002 1284 1346     		mov	r3, r2
 4003 1286 FB71     		strb	r3, [r7, #7]
4785:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4786:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
 4004              		.loc 1 4786 0
 4005 1288 0123     		movs	r3, #1
 4006 128a FB61     		str	r3, [r7, #28]
4787:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4788:FreeRTOS/Source/tasks.c **** 
4789:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4790:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
 4007              		.loc 1 4790 0
 4008 128c FB68     		ldr	r3, [r7, #12]
 4009 128e BB61     		str	r3, [r7, #24]
4791:FreeRTOS/Source/tasks.c **** 
4792:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 4010              		.loc 1 4792 0
 4011 1290 FFF7FEFF 		bl	vPortEnterCritical
4793:FreeRTOS/Source/tasks.c **** 		{
4794:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 4012              		.loc 1 4794 0
 4013 1294 3B68     		ldr	r3, [r7]
 4014 1296 002B     		cmp	r3, #0
 4015 1298 03D0     		beq	.L267
4795:FreeRTOS/Source/tasks.c **** 			{
4796:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 4016              		.loc 1 4796 0
 4017 129a BB69     		ldr	r3, [r7, #24]
 4018 129c 5A6C     		ldr	r2, [r3, #68]
 4019 129e 3B68     		ldr	r3, [r7]
 4020 12a0 1A60     		str	r2, [r3]
 4021              	.L267:
4797:FreeRTOS/Source/tasks.c **** 			}
4798:FreeRTOS/Source/tasks.c **** 
4799:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 4022              		.loc 1 4799 0
 4023 12a2 BB69     		ldr	r3, [r7, #24]
 4024 12a4 93F84830 		ldrb	r3, [r3, #72]
 4025 12a8 FB75     		strb	r3, [r7, #23]
4800:FreeRTOS/Source/tasks.c **** 
4801:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4026              		.loc 1 4801 0
 4027 12aa BB69     		ldr	r3, [r7, #24]
 4028 12ac 0222     		movs	r2, #2
 4029 12ae 83F84820 		strb	r2, [r3, #72]
4802:FreeRTOS/Source/tasks.c **** 
4803:FreeRTOS/Source/tasks.c **** 			switch( eAction )
 4030              		.loc 1 4803 0
 4031 12b2 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4032 12b4 042B     		cmp	r3, #4
 4033 12b6 28D8     		bhi	.L280
 4034 12b8 01A2     		adr	r2, .L270
 4035 12ba 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 4036 12be 00BF     		.p2align 2
 4037              	.L270:
ARM GAS  /tmp/cckqXCjj.s 			page 161


 4038 12c0 0B130000 		.word	.L280+1
 4039 12c4 D5120000 		.word	.L271+1
 4040 12c8 E3120000 		.word	.L272+1
 4041 12cc EF120000 		.word	.L273+1
 4042 12d0 F7120000 		.word	.L274+1
 4043              		.p2align 1
 4044              	.L271:
4804:FreeRTOS/Source/tasks.c **** 			{
4805:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4806:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 4045              		.loc 1 4806 0
 4046 12d4 BB69     		ldr	r3, [r7, #24]
 4047 12d6 5A6C     		ldr	r2, [r3, #68]
 4048 12d8 BB68     		ldr	r3, [r7, #8]
 4049 12da 1A43     		orrs	r2, r2, r3
 4050 12dc BB69     		ldr	r3, [r7, #24]
 4051 12de 5A64     		str	r2, [r3, #68]
4807:FreeRTOS/Source/tasks.c **** 					break;
 4052              		.loc 1 4807 0
 4053 12e0 14E0     		b	.L275
 4054              	.L272:
4808:FreeRTOS/Source/tasks.c **** 
4809:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4810:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 4055              		.loc 1 4810 0
 4056 12e2 BB69     		ldr	r3, [r7, #24]
 4057 12e4 5B6C     		ldr	r3, [r3, #68]
 4058 12e6 5A1C     		adds	r2, r3, #1
 4059 12e8 BB69     		ldr	r3, [r7, #24]
 4060 12ea 5A64     		str	r2, [r3, #68]
4811:FreeRTOS/Source/tasks.c **** 					break;
 4061              		.loc 1 4811 0
 4062 12ec 0EE0     		b	.L275
 4063              	.L273:
4812:FreeRTOS/Source/tasks.c **** 
4813:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4814:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 4064              		.loc 1 4814 0
 4065 12ee BB69     		ldr	r3, [r7, #24]
 4066 12f0 BA68     		ldr	r2, [r7, #8]
 4067 12f2 5A64     		str	r2, [r3, #68]
4815:FreeRTOS/Source/tasks.c **** 					break;
 4068              		.loc 1 4815 0
 4069 12f4 0AE0     		b	.L275
 4070              	.L274:
4816:FreeRTOS/Source/tasks.c **** 
4817:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4818:FreeRTOS/Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4071              		.loc 1 4818 0
 4072 12f6 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4073 12f8 022B     		cmp	r3, #2
 4074 12fa 03D0     		beq	.L276
4819:FreeRTOS/Source/tasks.c **** 					{
4820:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 4075              		.loc 1 4820 0
 4076 12fc BB69     		ldr	r3, [r7, #24]
 4077 12fe BA68     		ldr	r2, [r7, #8]
ARM GAS  /tmp/cckqXCjj.s 			page 162


 4078 1300 5A64     		str	r2, [r3, #68]
4821:FreeRTOS/Source/tasks.c **** 					}
4822:FreeRTOS/Source/tasks.c **** 					else
4823:FreeRTOS/Source/tasks.c **** 					{
4824:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4825:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4826:FreeRTOS/Source/tasks.c **** 					}
4827:FreeRTOS/Source/tasks.c **** 					break;
 4079              		.loc 1 4827 0
 4080 1302 03E0     		b	.L275
 4081              	.L276:
4825:FreeRTOS/Source/tasks.c **** 					}
 4082              		.loc 1 4825 0
 4083 1304 0023     		movs	r3, #0
 4084 1306 FB61     		str	r3, [r7, #28]
 4085              		.loc 1 4827 0
 4086 1308 00E0     		b	.L275
 4087              	.L280:
4828:FreeRTOS/Source/tasks.c **** 
4829:FreeRTOS/Source/tasks.c **** 				case eNoAction:
4830:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4831:FreeRTOS/Source/tasks.c **** 					updated. */
4832:FreeRTOS/Source/tasks.c **** 					break;
4833:FreeRTOS/Source/tasks.c **** 
4834:FreeRTOS/Source/tasks.c **** 				default:
4835:FreeRTOS/Source/tasks.c **** 					/* Should not get here if all enums are handled.
4836:FreeRTOS/Source/tasks.c **** 					Artificially force an assert by testing a value the
4837:FreeRTOS/Source/tasks.c **** 					compiler can't assume is const. */
4838:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4839:FreeRTOS/Source/tasks.c **** 
4840:FreeRTOS/Source/tasks.c **** 					break;
 4088              		.loc 1 4840 0
 4089 130a 00BF     		nop
 4090              	.L275:
4841:FreeRTOS/Source/tasks.c **** 			}
4842:FreeRTOS/Source/tasks.c **** 
4843:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY();
4844:FreeRTOS/Source/tasks.c **** 
4845:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4846:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4847:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4091              		.loc 1 4847 0
 4092 130c FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4093 130e 012B     		cmp	r3, #1
 4094 1310 2AD1     		bne	.L278
4848:FreeRTOS/Source/tasks.c **** 			{
4849:FreeRTOS/Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4095              		.loc 1 4849 0
 4096 1312 BB69     		ldr	r3, [r7, #24]
 4097 1314 0433     		adds	r3, r3, #4
 4098 1316 1846     		mov	r0, r3
 4099 1318 FFF7FEFF 		bl	uxListRemove
4850:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 4100              		.loc 1 4850 0
 4101 131c BB69     		ldr	r3, [r7, #24]
 4102 131e DB6A     		ldr	r3, [r3, #44]
 4103 1320 0122     		movs	r2, #1
ARM GAS  /tmp/cckqXCjj.s 			page 163


 4104 1322 9A40     		lsls	r2, r2, r3
 4105 1324 144B     		ldr	r3, .L281
 4106 1326 1B68     		ldr	r3, [r3]
 4107 1328 1343     		orrs	r3, r3, r2
 4108 132a 134A     		ldr	r2, .L281
 4109 132c 1360     		str	r3, [r2]
 4110 132e BB69     		ldr	r3, [r7, #24]
 4111 1330 DA6A     		ldr	r2, [r3, #44]
 4112 1332 1346     		mov	r3, r2
 4113 1334 9B00     		lsls	r3, r3, #2
 4114 1336 1344     		add	r3, r3, r2
 4115 1338 9B00     		lsls	r3, r3, #2
 4116 133a 104A     		ldr	r2, .L281+4
 4117 133c 1A44     		add	r2, r2, r3
 4118 133e BB69     		ldr	r3, [r7, #24]
 4119 1340 0433     		adds	r3, r3, #4
 4120 1342 1946     		mov	r1, r3
 4121 1344 1046     		mov	r0, r2
 4122 1346 FFF7FEFF 		bl	vListInsertEnd
4851:FreeRTOS/Source/tasks.c **** 
4852:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4853:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4854:FreeRTOS/Source/tasks.c **** 
4855:FreeRTOS/Source/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4856:FreeRTOS/Source/tasks.c **** 				{
4857:FreeRTOS/Source/tasks.c **** 					/* If a task is blocked waiting for a notification then
4858:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4859:FreeRTOS/Source/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4860:FreeRTOS/Source/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4861:FreeRTOS/Source/tasks.c **** 					because it will automatically get reset to a new value when
4862:FreeRTOS/Source/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4863:FreeRTOS/Source/tasks.c **** 					tickless idling is used it might be more important to enter
4864:FreeRTOS/Source/tasks.c **** 					sleep mode at the earliest possible time - so reset
4865:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4866:FreeRTOS/Source/tasks.c **** 					earliest possible time. */
4867:FreeRTOS/Source/tasks.c **** 					prvResetNextTaskUnblockTime();
4868:FreeRTOS/Source/tasks.c **** 				}
4869:FreeRTOS/Source/tasks.c **** 				#endif
4870:FreeRTOS/Source/tasks.c **** 
4871:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4123              		.loc 1 4871 0
 4124 134a BB69     		ldr	r3, [r7, #24]
 4125 134c DA6A     		ldr	r2, [r3, #44]
 4126 134e 0C4B     		ldr	r3, .L281+8
 4127 1350 1B68     		ldr	r3, [r3]
 4128 1352 DB6A     		ldr	r3, [r3, #44]
 4129 1354 9A42     		cmp	r2, r3
 4130 1356 07D9     		bls	.L278
4872:FreeRTOS/Source/tasks.c **** 				{
4873:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4874:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
4875:FreeRTOS/Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 4131              		.loc 1 4875 0
 4132 1358 0A4B     		ldr	r3, .L281+12
 4133 135a 4FF08052 		mov	r2, #268435456
 4134 135e 1A60     		str	r2, [r3]
 4135              		.syntax unified
ARM GAS  /tmp/cckqXCjj.s 			page 164


 4136              	@ 4875 "FreeRTOS/Source/tasks.c" 1
 4137 1360 BFF34F8F 		dsb
 4138              	@ 0 "" 2
 4139              	@ 4875 "FreeRTOS/Source/tasks.c" 1
 4140 1364 BFF36F8F 		isb
 4141              	@ 0 "" 2
 4142              		.thumb
 4143              		.syntax unified
 4144              	.L278:
4876:FreeRTOS/Source/tasks.c **** 				}
4877:FreeRTOS/Source/tasks.c **** 				else
4878:FreeRTOS/Source/tasks.c **** 				{
4879:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4880:FreeRTOS/Source/tasks.c **** 				}
4881:FreeRTOS/Source/tasks.c **** 			}
4882:FreeRTOS/Source/tasks.c **** 			else
4883:FreeRTOS/Source/tasks.c **** 			{
4884:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4885:FreeRTOS/Source/tasks.c **** 			}
4886:FreeRTOS/Source/tasks.c **** 		}
4887:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 4145              		.loc 1 4887 0
 4146 1368 FFF7FEFF 		bl	vPortExitCritical
4888:FreeRTOS/Source/tasks.c **** 
4889:FreeRTOS/Source/tasks.c **** 		return xReturn;
 4147              		.loc 1 4889 0
 4148 136c FB69     		ldr	r3, [r7, #28]
4890:FreeRTOS/Source/tasks.c **** 	}
 4149              		.loc 1 4890 0
 4150 136e 1846     		mov	r0, r3
 4151 1370 2037     		adds	r7, r7, #32
 4152              		.cfi_def_cfa_offset 8
 4153 1372 BD46     		mov	sp, r7
 4154              		.cfi_def_cfa_register 13
 4155              		@ sp needed
 4156 1374 80BD     		pop	{r7, pc}
 4157              	.L282:
 4158 1376 00BF     		.align	2
 4159              	.L281:
 4160 1378 E0000000 		.word	uxTopReadyPriority
 4161 137c 04000000 		.word	pxReadyTasksLists
 4162 1380 00000000 		.word	pxCurrentTCB
 4163 1384 04ED00E0 		.word	-536810236
 4164              		.cfi_endproc
 4165              	.LFE46:
 4166              		.size	xTaskGenericNotify, .-xTaskGenericNotify
 4167              		.align	1
 4168              		.global	xTaskGenericNotifyFromISR
 4169              		.syntax unified
 4170              		.thumb
 4171              		.thumb_func
 4172              		.fpu softvfp
 4173              		.type	xTaskGenericNotifyFromISR, %function
 4174              	xTaskGenericNotifyFromISR:
 4175              	.LFB47:
4891:FreeRTOS/Source/tasks.c **** 
4892:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
ARM GAS  /tmp/cckqXCjj.s 			page 165


4893:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4894:FreeRTOS/Source/tasks.c **** 
4895:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4896:FreeRTOS/Source/tasks.c **** 
4897:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4898:FreeRTOS/Source/tasks.c **** 	{
 4176              		.loc 1 4898 0
 4177              		.cfi_startproc
 4178              		@ args = 4, pretend = 0, frame = 48
 4179              		@ frame_needed = 1, uses_anonymous_args = 0
 4180 1388 80B5     		push	{r7, lr}
 4181              		.cfi_def_cfa_offset 8
 4182              		.cfi_offset 7, -8
 4183              		.cfi_offset 14, -4
 4184 138a 8CB0     		sub	sp, sp, #48
 4185              		.cfi_def_cfa_offset 56
 4186 138c 00AF     		add	r7, sp, #0
 4187              		.cfi_def_cfa_register 7
 4188 138e F860     		str	r0, [r7, #12]
 4189 1390 B960     		str	r1, [r7, #8]
 4190 1392 3B60     		str	r3, [r7]
 4191 1394 1346     		mov	r3, r2
 4192 1396 FB71     		strb	r3, [r7, #7]
4899:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
4900:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4901:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
 4193              		.loc 1 4901 0
 4194 1398 0123     		movs	r3, #1
 4195 139a FB62     		str	r3, [r7, #44]
4902:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4903:FreeRTOS/Source/tasks.c **** 
4904:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
4905:FreeRTOS/Source/tasks.c **** 
4906:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4907:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4908:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4909:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4910:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4911:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4912:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4913:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4914:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4915:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4916:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4917:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4918:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4919:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4920:FreeRTOS/Source/tasks.c **** 		provided on the following link:
4921:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4922:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4923:FreeRTOS/Source/tasks.c **** 
4924:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
 4196              		.loc 1 4924 0
 4197 139c FB68     		ldr	r3, [r7, #12]
 4198 139e BB62     		str	r3, [r7, #40]
 4199              	.LBB49:
 4200              	.LBB50:
ARM GAS  /tmp/cckqXCjj.s 			page 166


 213:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 4201              		.loc 2 213 0
 4202              		.syntax unified
 4203              	@ 213 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 4204 13a0 EFF31182 			mrs r2, basepri											
 4205 13a4 4FF0BF03 		mov r3, #191												
 4206 13a8 83F31188 		msr basepri, r3											
 4207 13ac BFF36F8F 		isb														
 4208 13b0 BFF34F8F 		dsb														
 4209              	
 4210              	@ 0 "" 2
 4211              		.thumb
 4212              		.syntax unified
 4213 13b4 FA61     		str	r2, [r7, #28]
 4214 13b6 BB61     		str	r3, [r7, #24]
 225:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
 4215              		.loc 2 225 0
 4216 13b8 FB69     		ldr	r3, [r7, #28]
 4217              	.LBE50:
 4218              	.LBE49:
4925:FreeRTOS/Source/tasks.c **** 
4926:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4219              		.loc 1 4926 0
 4220 13ba 7B62     		str	r3, [r7, #36]
4927:FreeRTOS/Source/tasks.c **** 		{
4928:FreeRTOS/Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 4221              		.loc 1 4928 0
 4222 13bc 3B68     		ldr	r3, [r7]
 4223 13be 002B     		cmp	r3, #0
 4224 13c0 03D0     		beq	.L285
4929:FreeRTOS/Source/tasks.c **** 			{
4930:FreeRTOS/Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 4225              		.loc 1 4930 0
 4226 13c2 BB6A     		ldr	r3, [r7, #40]
 4227 13c4 5A6C     		ldr	r2, [r3, #68]
 4228 13c6 3B68     		ldr	r3, [r7]
 4229 13c8 1A60     		str	r2, [r3]
 4230              	.L285:
4931:FreeRTOS/Source/tasks.c **** 			}
4932:FreeRTOS/Source/tasks.c **** 
4933:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 4231              		.loc 1 4933 0
 4232 13ca BB6A     		ldr	r3, [r7, #40]
 4233 13cc 93F84830 		ldrb	r3, [r3, #72]
 4234 13d0 87F82330 		strb	r3, [r7, #35]
4934:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4235              		.loc 1 4934 0
 4236 13d4 BB6A     		ldr	r3, [r7, #40]
 4237 13d6 0222     		movs	r2, #2
 4238 13d8 83F84820 		strb	r2, [r3, #72]
4935:FreeRTOS/Source/tasks.c **** 
4936:FreeRTOS/Source/tasks.c **** 			switch( eAction )
 4239              		.loc 1 4936 0
 4240 13dc FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4241 13de 042B     		cmp	r3, #4
 4242 13e0 28D8     		bhi	.L301
 4243 13e2 01A2     		adr	r2, .L288
ARM GAS  /tmp/cckqXCjj.s 			page 167


 4244 13e4 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 4245              		.p2align 2
 4246              	.L288:
 4247 13e8 35140000 		.word	.L301+1
 4248 13ec FD130000 		.word	.L289+1
 4249 13f0 0B140000 		.word	.L290+1
 4250 13f4 17140000 		.word	.L291+1
 4251 13f8 1F140000 		.word	.L292+1
 4252              		.p2align 1
 4253              	.L289:
4937:FreeRTOS/Source/tasks.c **** 			{
4938:FreeRTOS/Source/tasks.c **** 				case eSetBits	:
4939:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 4254              		.loc 1 4939 0
 4255 13fc BB6A     		ldr	r3, [r7, #40]
 4256 13fe 5A6C     		ldr	r2, [r3, #68]
 4257 1400 BB68     		ldr	r3, [r7, #8]
 4258 1402 1A43     		orrs	r2, r2, r3
 4259 1404 BB6A     		ldr	r3, [r7, #40]
 4260 1406 5A64     		str	r2, [r3, #68]
4940:FreeRTOS/Source/tasks.c **** 					break;
 4261              		.loc 1 4940 0
 4262 1408 15E0     		b	.L293
 4263              	.L290:
4941:FreeRTOS/Source/tasks.c **** 
4942:FreeRTOS/Source/tasks.c **** 				case eIncrement	:
4943:FreeRTOS/Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 4264              		.loc 1 4943 0
 4265 140a BB6A     		ldr	r3, [r7, #40]
 4266 140c 5B6C     		ldr	r3, [r3, #68]
 4267 140e 5A1C     		adds	r2, r3, #1
 4268 1410 BB6A     		ldr	r3, [r7, #40]
 4269 1412 5A64     		str	r2, [r3, #68]
4944:FreeRTOS/Source/tasks.c **** 					break;
 4270              		.loc 1 4944 0
 4271 1414 0FE0     		b	.L293
 4272              	.L291:
4945:FreeRTOS/Source/tasks.c **** 
4946:FreeRTOS/Source/tasks.c **** 				case eSetValueWithOverwrite	:
4947:FreeRTOS/Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 4273              		.loc 1 4947 0
 4274 1416 BB6A     		ldr	r3, [r7, #40]
 4275 1418 BA68     		ldr	r2, [r7, #8]
 4276 141a 5A64     		str	r2, [r3, #68]
4948:FreeRTOS/Source/tasks.c **** 					break;
 4277              		.loc 1 4948 0
 4278 141c 0BE0     		b	.L293
 4279              	.L292:
4949:FreeRTOS/Source/tasks.c **** 
4950:FreeRTOS/Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4951:FreeRTOS/Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4280              		.loc 1 4951 0
 4281 141e 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 4282 1422 022B     		cmp	r3, #2
 4283 1424 03D0     		beq	.L294
4952:FreeRTOS/Source/tasks.c **** 					{
4953:FreeRTOS/Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
ARM GAS  /tmp/cckqXCjj.s 			page 168


 4284              		.loc 1 4953 0
 4285 1426 BB6A     		ldr	r3, [r7, #40]
 4286 1428 BA68     		ldr	r2, [r7, #8]
 4287 142a 5A64     		str	r2, [r3, #68]
4954:FreeRTOS/Source/tasks.c **** 					}
4955:FreeRTOS/Source/tasks.c **** 					else
4956:FreeRTOS/Source/tasks.c **** 					{
4957:FreeRTOS/Source/tasks.c **** 						/* The value could not be written to the task. */
4958:FreeRTOS/Source/tasks.c **** 						xReturn = pdFAIL;
4959:FreeRTOS/Source/tasks.c **** 					}
4960:FreeRTOS/Source/tasks.c **** 					break;
 4288              		.loc 1 4960 0
 4289 142c 03E0     		b	.L293
 4290              	.L294:
4958:FreeRTOS/Source/tasks.c **** 					}
 4291              		.loc 1 4958 0
 4292 142e 0023     		movs	r3, #0
 4293 1430 FB62     		str	r3, [r7, #44]
 4294              		.loc 1 4960 0
 4295 1432 00E0     		b	.L293
 4296              	.L301:
4961:FreeRTOS/Source/tasks.c **** 
4962:FreeRTOS/Source/tasks.c **** 				case eNoAction :
4963:FreeRTOS/Source/tasks.c **** 					/* The task is being notified without its notify value being
4964:FreeRTOS/Source/tasks.c **** 					updated. */
4965:FreeRTOS/Source/tasks.c **** 					break;
4966:FreeRTOS/Source/tasks.c **** 
4967:FreeRTOS/Source/tasks.c **** 				default:
4968:FreeRTOS/Source/tasks.c **** 					/* Should not get here if all enums are handled.
4969:FreeRTOS/Source/tasks.c **** 					Artificially force an assert by testing a value the
4970:FreeRTOS/Source/tasks.c **** 					compiler can't assume is const. */
4971:FreeRTOS/Source/tasks.c **** 					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
4972:FreeRTOS/Source/tasks.c **** 					break;
 4297              		.loc 1 4972 0
 4298 1434 00BF     		nop
 4299              	.L293:
4973:FreeRTOS/Source/tasks.c **** 			}
4974:FreeRTOS/Source/tasks.c **** 
4975:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4976:FreeRTOS/Source/tasks.c **** 
4977:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4978:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
4979:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4300              		.loc 1 4979 0
 4301 1436 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 4302 143a 012B     		cmp	r3, #1
 4303 143c 36D1     		bne	.L296
4980:FreeRTOS/Source/tasks.c **** 			{
4981:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
4982:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4983:FreeRTOS/Source/tasks.c **** 
4984:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4304              		.loc 1 4984 0
 4305 143e 204B     		ldr	r3, .L302
 4306 1440 1B68     		ldr	r3, [r3]
 4307 1442 002B     		cmp	r3, #0
 4308 1444 1CD1     		bne	.L297
ARM GAS  /tmp/cckqXCjj.s 			page 169


4985:FreeRTOS/Source/tasks.c **** 				{
4986:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4309              		.loc 1 4986 0
 4310 1446 BB6A     		ldr	r3, [r7, #40]
 4311 1448 0433     		adds	r3, r3, #4
 4312 144a 1846     		mov	r0, r3
 4313 144c FFF7FEFF 		bl	uxListRemove
4987:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4314              		.loc 1 4987 0
 4315 1450 BB6A     		ldr	r3, [r7, #40]
 4316 1452 DB6A     		ldr	r3, [r3, #44]
 4317 1454 0122     		movs	r2, #1
 4318 1456 9A40     		lsls	r2, r2, r3
 4319 1458 1A4B     		ldr	r3, .L302+4
 4320 145a 1B68     		ldr	r3, [r3]
 4321 145c 1343     		orrs	r3, r3, r2
 4322 145e 194A     		ldr	r2, .L302+4
 4323 1460 1360     		str	r3, [r2]
 4324 1462 BB6A     		ldr	r3, [r7, #40]
 4325 1464 DA6A     		ldr	r2, [r3, #44]
 4326 1466 1346     		mov	r3, r2
 4327 1468 9B00     		lsls	r3, r3, #2
 4328 146a 1344     		add	r3, r3, r2
 4329 146c 9B00     		lsls	r3, r3, #2
 4330 146e 164A     		ldr	r2, .L302+8
 4331 1470 1A44     		add	r2, r2, r3
 4332 1472 BB6A     		ldr	r3, [r7, #40]
 4333 1474 0433     		adds	r3, r3, #4
 4334 1476 1946     		mov	r1, r3
 4335 1478 1046     		mov	r0, r2
 4336 147a FFF7FEFF 		bl	vListInsertEnd
 4337 147e 05E0     		b	.L298
 4338              	.L297:
4988:FreeRTOS/Source/tasks.c **** 				}
4989:FreeRTOS/Source/tasks.c **** 				else
4990:FreeRTOS/Source/tasks.c **** 				{
4991:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4992:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4993:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4339              		.loc 1 4993 0
 4340 1480 BB6A     		ldr	r3, [r7, #40]
 4341 1482 1833     		adds	r3, r3, #24
 4342 1484 1946     		mov	r1, r3
 4343 1486 1148     		ldr	r0, .L302+12
 4344 1488 FFF7FEFF 		bl	vListInsertEnd
 4345              	.L298:
4994:FreeRTOS/Source/tasks.c **** 				}
4995:FreeRTOS/Source/tasks.c **** 
4996:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4346              		.loc 1 4996 0
 4347 148c BB6A     		ldr	r3, [r7, #40]
 4348 148e DA6A     		ldr	r2, [r3, #44]
 4349 1490 0F4B     		ldr	r3, .L302+16
 4350 1492 1B68     		ldr	r3, [r3]
 4351 1494 DB6A     		ldr	r3, [r3, #44]
 4352 1496 9A42     		cmp	r2, r3
 4353 1498 08D9     		bls	.L296
ARM GAS  /tmp/cckqXCjj.s 			page 170


4997:FreeRTOS/Source/tasks.c **** 				{
4998:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
4999:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
5000:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 4354              		.loc 1 5000 0
 4355 149a BB6B     		ldr	r3, [r7, #56]
 4356 149c 002B     		cmp	r3, #0
 4357 149e 02D0     		beq	.L299
5001:FreeRTOS/Source/tasks.c **** 					{
5002:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 4358              		.loc 1 5002 0
 4359 14a0 BB6B     		ldr	r3, [r7, #56]
 4360 14a2 0122     		movs	r2, #1
 4361 14a4 1A60     		str	r2, [r3]
 4362              	.L299:
5003:FreeRTOS/Source/tasks.c **** 					}
5004:FreeRTOS/Source/tasks.c **** 
5005:FreeRTOS/Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
5006:FreeRTOS/Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter to an ISR
5007:FreeRTOS/Source/tasks.c **** 					safe FreeRTOS function. */
5008:FreeRTOS/Source/tasks.c **** 					xYieldPending = pdTRUE;
 4363              		.loc 1 5008 0
 4364 14a6 0B4B     		ldr	r3, .L302+20
 4365 14a8 0122     		movs	r2, #1
 4366 14aa 1A60     		str	r2, [r3]
 4367              	.L296:
 4368 14ac 7B6A     		ldr	r3, [r7, #36]
 4369 14ae 7B61     		str	r3, [r7, #20]
 4370              	.LBB51:
 4371              	.LBB52:
 4372              		.loc 2 231 0
 4373 14b0 7B69     		ldr	r3, [r7, #20]
 4374              		.syntax unified
 4375              	@ 231 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 4376 14b2 83F31188 			msr basepri, r3	
 4377              	@ 0 "" 2
 4378              		.thumb
 4379              		.syntax unified
 4380              	.LBE52:
 4381              	.LBE51:
5009:FreeRTOS/Source/tasks.c **** 				}
5010:FreeRTOS/Source/tasks.c **** 				else
5011:FreeRTOS/Source/tasks.c **** 				{
5012:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5013:FreeRTOS/Source/tasks.c **** 				}
5014:FreeRTOS/Source/tasks.c **** 			}
5015:FreeRTOS/Source/tasks.c **** 		}
5016:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
5017:FreeRTOS/Source/tasks.c **** 
5018:FreeRTOS/Source/tasks.c **** 		return xReturn;
 4382              		.loc 1 5018 0
 4383 14b6 FB6A     		ldr	r3, [r7, #44]
5019:FreeRTOS/Source/tasks.c **** 	}
 4384              		.loc 1 5019 0
 4385 14b8 1846     		mov	r0, r3
 4386 14ba 3037     		adds	r7, r7, #48
 4387              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/cckqXCjj.s 			page 171


 4388 14bc BD46     		mov	sp, r7
 4389              		.cfi_def_cfa_register 13
 4390              		@ sp needed
 4391 14be 80BD     		pop	{r7, pc}
 4392              	.L303:
 4393              		.align	2
 4394              	.L302:
 4395 14c0 00010000 		.word	uxSchedulerSuspended
 4396 14c4 E0000000 		.word	uxTopReadyPriority
 4397 14c8 04000000 		.word	pxReadyTasksLists
 4398 14cc 98000000 		.word	xPendingReadyList
 4399 14d0 00000000 		.word	pxCurrentTCB
 4400 14d4 EC000000 		.word	xYieldPending
 4401              		.cfi_endproc
 4402              	.LFE47:
 4403              		.size	xTaskGenericNotifyFromISR, .-xTaskGenericNotifyFromISR
 4404              		.align	1
 4405              		.global	vTaskNotifyGiveFromISR
 4406              		.syntax unified
 4407              		.thumb
 4408              		.thumb_func
 4409              		.fpu softvfp
 4410              		.type	vTaskNotifyGiveFromISR, %function
 4411              	vTaskNotifyGiveFromISR:
 4412              	.LFB48:
5020:FreeRTOS/Source/tasks.c **** 
5021:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5022:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5023:FreeRTOS/Source/tasks.c **** 
5024:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
5025:FreeRTOS/Source/tasks.c **** 
5026:FreeRTOS/Source/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
5027:FreeRTOS/Source/tasks.c **** 	{
 4413              		.loc 1 5027 0
 4414              		.cfi_startproc
 4415              		@ args = 0, pretend = 0, frame = 32
 4416              		@ frame_needed = 1, uses_anonymous_args = 0
 4417 14d8 80B5     		push	{r7, lr}
 4418              		.cfi_def_cfa_offset 8
 4419              		.cfi_offset 7, -8
 4420              		.cfi_offset 14, -4
 4421 14da 88B0     		sub	sp, sp, #32
 4422              		.cfi_def_cfa_offset 40
 4423 14dc 00AF     		add	r7, sp, #0
 4424              		.cfi_def_cfa_register 7
 4425 14de 7860     		str	r0, [r7, #4]
 4426 14e0 3960     		str	r1, [r7]
5028:FreeRTOS/Source/tasks.c **** 	TCB_t * pxTCB;
5029:FreeRTOS/Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
5030:FreeRTOS/Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
5031:FreeRTOS/Source/tasks.c **** 
5032:FreeRTOS/Source/tasks.c **** 		configASSERT( xTaskToNotify );
5033:FreeRTOS/Source/tasks.c **** 
5034:FreeRTOS/Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
5035:FreeRTOS/Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
5036:FreeRTOS/Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
5037:FreeRTOS/Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
ARM GAS  /tmp/cckqXCjj.s 			page 172


5038:FreeRTOS/Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
5039:FreeRTOS/Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
5040:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
5041:FreeRTOS/Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
5042:FreeRTOS/Source/tasks.c **** 		been assigned a priority above the configured maximum system call
5043:FreeRTOS/Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
5044:FreeRTOS/Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
5045:FreeRTOS/Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
5046:FreeRTOS/Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
5047:FreeRTOS/Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
5048:FreeRTOS/Source/tasks.c **** 		provided on the following link:
5049:FreeRTOS/Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
5050:FreeRTOS/Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
5051:FreeRTOS/Source/tasks.c **** 
5052:FreeRTOS/Source/tasks.c **** 		pxTCB = xTaskToNotify;
 4427              		.loc 1 5052 0
 4428 14e2 7B68     		ldr	r3, [r7, #4]
 4429 14e4 FB61     		str	r3, [r7, #28]
 4430              	.LBB53:
 4431              	.LBB54:
 213:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** 	(
 4432              		.loc 2 213 0
 4433              		.syntax unified
 4434              	@ 213 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 4435 14e6 EFF31182 			mrs r2, basepri											
 4436 14ea 4FF0BF03 		mov r3, #191												
 4437 14ee 83F31188 		msr basepri, r3											
 4438 14f2 BFF36F8F 		isb														
 4439 14f6 BFF34F8F 		dsb														
 4440              	
 4441              	@ 0 "" 2
 4442              		.thumb
 4443              		.syntax unified
 4444 14fa 3A61     		str	r2, [r7, #16]
 4445 14fc FB60     		str	r3, [r7, #12]
 225:FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h **** }
 4446              		.loc 2 225 0
 4447 14fe 3B69     		ldr	r3, [r7, #16]
 4448              	.LBE54:
 4449              	.LBE53:
5053:FreeRTOS/Source/tasks.c **** 
5054:FreeRTOS/Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4450              		.loc 1 5054 0
 4451 1500 BB61     		str	r3, [r7, #24]
5055:FreeRTOS/Source/tasks.c **** 		{
5056:FreeRTOS/Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 4452              		.loc 1 5056 0
 4453 1502 FB69     		ldr	r3, [r7, #28]
 4454 1504 93F84830 		ldrb	r3, [r3, #72]
 4455 1508 FB75     		strb	r3, [r7, #23]
5057:FreeRTOS/Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4456              		.loc 1 5057 0
 4457 150a FB69     		ldr	r3, [r7, #28]
 4458 150c 0222     		movs	r2, #2
 4459 150e 83F84820 		strb	r2, [r3, #72]
5058:FreeRTOS/Source/tasks.c **** 
5059:FreeRTOS/Source/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
ARM GAS  /tmp/cckqXCjj.s 			page 173


5060:FreeRTOS/Source/tasks.c **** 			semaphore. */
5061:FreeRTOS/Source/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
 4460              		.loc 1 5061 0
 4461 1512 FB69     		ldr	r3, [r7, #28]
 4462 1514 5B6C     		ldr	r3, [r3, #68]
 4463 1516 5A1C     		adds	r2, r3, #1
 4464 1518 FB69     		ldr	r3, [r7, #28]
 4465 151a 5A64     		str	r2, [r3, #68]
5062:FreeRTOS/Source/tasks.c **** 
5063:FreeRTOS/Source/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
5064:FreeRTOS/Source/tasks.c **** 
5065:FreeRTOS/Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
5066:FreeRTOS/Source/tasks.c **** 			notification then unblock it now. */
5067:FreeRTOS/Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4466              		.loc 1 5067 0
 4467 151c FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4468 151e 012B     		cmp	r3, #1
 4469 1520 36D1     		bne	.L306
5068:FreeRTOS/Source/tasks.c **** 			{
5069:FreeRTOS/Source/tasks.c **** 				/* The task should not have been on an event list. */
5070:FreeRTOS/Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
5071:FreeRTOS/Source/tasks.c **** 
5072:FreeRTOS/Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4470              		.loc 1 5072 0
 4471 1522 204B     		ldr	r3, .L310
 4472 1524 1B68     		ldr	r3, [r3]
 4473 1526 002B     		cmp	r3, #0
 4474 1528 1CD1     		bne	.L307
5073:FreeRTOS/Source/tasks.c **** 				{
5074:FreeRTOS/Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4475              		.loc 1 5074 0
 4476 152a FB69     		ldr	r3, [r7, #28]
 4477 152c 0433     		adds	r3, r3, #4
 4478 152e 1846     		mov	r0, r3
 4479 1530 FFF7FEFF 		bl	uxListRemove
5075:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4480              		.loc 1 5075 0
 4481 1534 FB69     		ldr	r3, [r7, #28]
 4482 1536 DB6A     		ldr	r3, [r3, #44]
 4483 1538 0122     		movs	r2, #1
 4484 153a 9A40     		lsls	r2, r2, r3
 4485 153c 1A4B     		ldr	r3, .L310+4
 4486 153e 1B68     		ldr	r3, [r3]
 4487 1540 1343     		orrs	r3, r3, r2
 4488 1542 194A     		ldr	r2, .L310+4
 4489 1544 1360     		str	r3, [r2]
 4490 1546 FB69     		ldr	r3, [r7, #28]
 4491 1548 DA6A     		ldr	r2, [r3, #44]
 4492 154a 1346     		mov	r3, r2
 4493 154c 9B00     		lsls	r3, r3, #2
 4494 154e 1344     		add	r3, r3, r2
 4495 1550 9B00     		lsls	r3, r3, #2
 4496 1552 164A     		ldr	r2, .L310+8
 4497 1554 1A44     		add	r2, r2, r3
 4498 1556 FB69     		ldr	r3, [r7, #28]
 4499 1558 0433     		adds	r3, r3, #4
 4500 155a 1946     		mov	r1, r3
ARM GAS  /tmp/cckqXCjj.s 			page 174


 4501 155c 1046     		mov	r0, r2
 4502 155e FFF7FEFF 		bl	vListInsertEnd
 4503 1562 05E0     		b	.L308
 4504              	.L307:
5076:FreeRTOS/Source/tasks.c **** 				}
5077:FreeRTOS/Source/tasks.c **** 				else
5078:FreeRTOS/Source/tasks.c **** 				{
5079:FreeRTOS/Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
5080:FreeRTOS/Source/tasks.c **** 					this task pending until the scheduler is resumed. */
5081:FreeRTOS/Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4505              		.loc 1 5081 0
 4506 1564 FB69     		ldr	r3, [r7, #28]
 4507 1566 1833     		adds	r3, r3, #24
 4508 1568 1946     		mov	r1, r3
 4509 156a 1148     		ldr	r0, .L310+12
 4510 156c FFF7FEFF 		bl	vListInsertEnd
 4511              	.L308:
5082:FreeRTOS/Source/tasks.c **** 				}
5083:FreeRTOS/Source/tasks.c **** 
5084:FreeRTOS/Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4512              		.loc 1 5084 0
 4513 1570 FB69     		ldr	r3, [r7, #28]
 4514 1572 DA6A     		ldr	r2, [r3, #44]
 4515 1574 0F4B     		ldr	r3, .L310+16
 4516 1576 1B68     		ldr	r3, [r3]
 4517 1578 DB6A     		ldr	r3, [r3, #44]
 4518 157a 9A42     		cmp	r2, r3
 4519 157c 08D9     		bls	.L306
5085:FreeRTOS/Source/tasks.c **** 				{
5086:FreeRTOS/Source/tasks.c **** 					/* The notified task has a priority above the currently
5087:FreeRTOS/Source/tasks.c **** 					executing task so a yield is required. */
5088:FreeRTOS/Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 4520              		.loc 1 5088 0
 4521 157e 3B68     		ldr	r3, [r7]
 4522 1580 002B     		cmp	r3, #0
 4523 1582 02D0     		beq	.L309
5089:FreeRTOS/Source/tasks.c **** 					{
5090:FreeRTOS/Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 4524              		.loc 1 5090 0
 4525 1584 3B68     		ldr	r3, [r7]
 4526 1586 0122     		movs	r2, #1
 4527 1588 1A60     		str	r2, [r3]
 4528              	.L309:
5091:FreeRTOS/Source/tasks.c **** 					}
5092:FreeRTOS/Source/tasks.c **** 
5093:FreeRTOS/Source/tasks.c **** 					/* Mark that a yield is pending in case the user is not
5094:FreeRTOS/Source/tasks.c **** 					using the "xHigherPriorityTaskWoken" parameter in an ISR
5095:FreeRTOS/Source/tasks.c **** 					safe FreeRTOS function. */
5096:FreeRTOS/Source/tasks.c **** 					xYieldPending = pdTRUE;
 4529              		.loc 1 5096 0
 4530 158a 0B4B     		ldr	r3, .L310+20
 4531 158c 0122     		movs	r2, #1
 4532 158e 1A60     		str	r2, [r3]
 4533              	.L306:
 4534 1590 BB69     		ldr	r3, [r7, #24]
 4535 1592 BB60     		str	r3, [r7, #8]
 4536              	.LBB55:
ARM GAS  /tmp/cckqXCjj.s 			page 175


 4537              	.LBB56:
 4538              		.loc 2 231 0
 4539 1594 BB68     		ldr	r3, [r7, #8]
 4540              		.syntax unified
 4541              	@ 231 "FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h" 1
 4542 1596 83F31188 			msr basepri, r3	
 4543              	@ 0 "" 2
 4544              		.thumb
 4545              		.syntax unified
 4546              	.LBE56:
 4547              	.LBE55:
5097:FreeRTOS/Source/tasks.c **** 				}
5098:FreeRTOS/Source/tasks.c **** 				else
5099:FreeRTOS/Source/tasks.c **** 				{
5100:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5101:FreeRTOS/Source/tasks.c **** 				}
5102:FreeRTOS/Source/tasks.c **** 			}
5103:FreeRTOS/Source/tasks.c **** 		}
5104:FreeRTOS/Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
5105:FreeRTOS/Source/tasks.c **** 	}
 4548              		.loc 1 5105 0
 4549 159a 00BF     		nop
 4550 159c 2037     		adds	r7, r7, #32
 4551              		.cfi_def_cfa_offset 8
 4552 159e BD46     		mov	sp, r7
 4553              		.cfi_def_cfa_register 13
 4554              		@ sp needed
 4555 15a0 80BD     		pop	{r7, pc}
 4556              	.L311:
 4557 15a2 00BF     		.align	2
 4558              	.L310:
 4559 15a4 00010000 		.word	uxSchedulerSuspended
 4560 15a8 E0000000 		.word	uxTopReadyPriority
 4561 15ac 04000000 		.word	pxReadyTasksLists
 4562 15b0 98000000 		.word	xPendingReadyList
 4563 15b4 00000000 		.word	pxCurrentTCB
 4564 15b8 EC000000 		.word	xYieldPending
 4565              		.cfi_endproc
 4566              	.LFE48:
 4567              		.size	vTaskNotifyGiveFromISR, .-vTaskNotifyGiveFromISR
 4568              		.align	1
 4569              		.global	xTaskNotifyStateClear
 4570              		.syntax unified
 4571              		.thumb
 4572              		.thumb_func
 4573              		.fpu softvfp
 4574              		.type	xTaskNotifyStateClear, %function
 4575              	xTaskNotifyStateClear:
 4576              	.LFB49:
5106:FreeRTOS/Source/tasks.c **** 
5107:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5108:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5109:FreeRTOS/Source/tasks.c **** 
5110:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
5111:FreeRTOS/Source/tasks.c **** 
5112:FreeRTOS/Source/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
5113:FreeRTOS/Source/tasks.c **** 	{
ARM GAS  /tmp/cckqXCjj.s 			page 176


 4577              		.loc 1 5113 0
 4578              		.cfi_startproc
 4579              		@ args = 0, pretend = 0, frame = 16
 4580              		@ frame_needed = 1, uses_anonymous_args = 0
 4581 15bc 80B5     		push	{r7, lr}
 4582              		.cfi_def_cfa_offset 8
 4583              		.cfi_offset 7, -8
 4584              		.cfi_offset 14, -4
 4585 15be 84B0     		sub	sp, sp, #16
 4586              		.cfi_def_cfa_offset 24
 4587 15c0 00AF     		add	r7, sp, #0
 4588              		.cfi_def_cfa_register 7
 4589 15c2 7860     		str	r0, [r7, #4]
5114:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
5115:FreeRTOS/Source/tasks.c **** 	BaseType_t xReturn;
5116:FreeRTOS/Source/tasks.c **** 
5117:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
5118:FreeRTOS/Source/tasks.c **** 		its notification state cleared. */
5119:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 4590              		.loc 1 5119 0
 4591 15c4 7B68     		ldr	r3, [r7, #4]
 4592 15c6 002B     		cmp	r3, #0
 4593 15c8 02D1     		bne	.L313
 4594              		.loc 1 5119 0 is_stmt 0 discriminator 1
 4595 15ca 0E4B     		ldr	r3, .L318
 4596 15cc 1B68     		ldr	r3, [r3]
 4597 15ce 00E0     		b	.L314
 4598              	.L313:
 4599              		.loc 1 5119 0 discriminator 2
 4600 15d0 7B68     		ldr	r3, [r7, #4]
 4601              	.L314:
 4602              		.loc 1 5119 0 discriminator 4
 4603 15d2 BB60     		str	r3, [r7, #8]
5120:FreeRTOS/Source/tasks.c **** 
5121:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 4604              		.loc 1 5121 0 is_stmt 1 discriminator 4
 4605 15d4 FFF7FEFF 		bl	vPortEnterCritical
5122:FreeRTOS/Source/tasks.c **** 		{
5123:FreeRTOS/Source/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 4606              		.loc 1 5123 0 discriminator 4
 4607 15d8 BB68     		ldr	r3, [r7, #8]
 4608 15da 93F84830 		ldrb	r3, [r3, #72]
 4609 15de DBB2     		uxtb	r3, r3
 4610 15e0 022B     		cmp	r3, #2
 4611 15e2 06D1     		bne	.L315
5124:FreeRTOS/Source/tasks.c **** 			{
5125:FreeRTOS/Source/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 4612              		.loc 1 5125 0
 4613 15e4 BB68     		ldr	r3, [r7, #8]
 4614 15e6 0022     		movs	r2, #0
 4615 15e8 83F84820 		strb	r2, [r3, #72]
5126:FreeRTOS/Source/tasks.c **** 				xReturn = pdPASS;
 4616              		.loc 1 5126 0
 4617 15ec 0123     		movs	r3, #1
 4618 15ee FB60     		str	r3, [r7, #12]
 4619 15f0 01E0     		b	.L316
 4620              	.L315:
ARM GAS  /tmp/cckqXCjj.s 			page 177


5127:FreeRTOS/Source/tasks.c **** 			}
5128:FreeRTOS/Source/tasks.c **** 			else
5129:FreeRTOS/Source/tasks.c **** 			{
5130:FreeRTOS/Source/tasks.c **** 				xReturn = pdFAIL;
 4621              		.loc 1 5130 0
 4622 15f2 0023     		movs	r3, #0
 4623 15f4 FB60     		str	r3, [r7, #12]
 4624              	.L316:
5131:FreeRTOS/Source/tasks.c **** 			}
5132:FreeRTOS/Source/tasks.c **** 		}
5133:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 4625              		.loc 1 5133 0
 4626 15f6 FFF7FEFF 		bl	vPortExitCritical
5134:FreeRTOS/Source/tasks.c **** 
5135:FreeRTOS/Source/tasks.c **** 		return xReturn;
 4627              		.loc 1 5135 0
 4628 15fa FB68     		ldr	r3, [r7, #12]
5136:FreeRTOS/Source/tasks.c **** 	}
 4629              		.loc 1 5136 0
 4630 15fc 1846     		mov	r0, r3
 4631 15fe 1037     		adds	r7, r7, #16
 4632              		.cfi_def_cfa_offset 8
 4633 1600 BD46     		mov	sp, r7
 4634              		.cfi_def_cfa_register 13
 4635              		@ sp needed
 4636 1602 80BD     		pop	{r7, pc}
 4637              	.L319:
 4638              		.align	2
 4639              	.L318:
 4640 1604 00000000 		.word	pxCurrentTCB
 4641              		.cfi_endproc
 4642              	.LFE49:
 4643              		.size	xTaskNotifyStateClear, .-xTaskNotifyStateClear
 4644              		.align	1
 4645              		.global	ulTaskNotifyValueClear
 4646              		.syntax unified
 4647              		.thumb
 4648              		.thumb_func
 4649              		.fpu softvfp
 4650              		.type	ulTaskNotifyValueClear, %function
 4651              	ulTaskNotifyValueClear:
 4652              	.LFB50:
5137:FreeRTOS/Source/tasks.c **** 
5138:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5139:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5140:FreeRTOS/Source/tasks.c **** 
5141:FreeRTOS/Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
5142:FreeRTOS/Source/tasks.c **** 
5143:FreeRTOS/Source/tasks.c **** 	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
5144:FreeRTOS/Source/tasks.c **** 	{
 4653              		.loc 1 5144 0
 4654              		.cfi_startproc
 4655              		@ args = 0, pretend = 0, frame = 16
 4656              		@ frame_needed = 1, uses_anonymous_args = 0
 4657 1608 80B5     		push	{r7, lr}
 4658              		.cfi_def_cfa_offset 8
 4659              		.cfi_offset 7, -8
ARM GAS  /tmp/cckqXCjj.s 			page 178


 4660              		.cfi_offset 14, -4
 4661 160a 84B0     		sub	sp, sp, #16
 4662              		.cfi_def_cfa_offset 24
 4663 160c 00AF     		add	r7, sp, #0
 4664              		.cfi_def_cfa_register 7
 4665 160e 7860     		str	r0, [r7, #4]
 4666 1610 3960     		str	r1, [r7]
5145:FreeRTOS/Source/tasks.c **** 	TCB_t *pxTCB;
5146:FreeRTOS/Source/tasks.c **** 	uint32_t ulReturn;
5147:FreeRTOS/Source/tasks.c **** 
5148:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
5149:FreeRTOS/Source/tasks.c **** 		its notification state cleared. */
5150:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 4667              		.loc 1 5150 0
 4668 1612 7B68     		ldr	r3, [r7, #4]
 4669 1614 002B     		cmp	r3, #0
 4670 1616 02D1     		bne	.L321
 4671              		.loc 1 5150 0 is_stmt 0 discriminator 1
 4672 1618 0C4B     		ldr	r3, .L324
 4673 161a 1B68     		ldr	r3, [r3]
 4674 161c 00E0     		b	.L322
 4675              	.L321:
 4676              		.loc 1 5150 0 discriminator 2
 4677 161e 7B68     		ldr	r3, [r7, #4]
 4678              	.L322:
 4679              		.loc 1 5150 0 discriminator 4
 4680 1620 FB60     		str	r3, [r7, #12]
5151:FreeRTOS/Source/tasks.c **** 
5152:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 4681              		.loc 1 5152 0 is_stmt 1 discriminator 4
 4682 1622 FFF7FEFF 		bl	vPortEnterCritical
5153:FreeRTOS/Source/tasks.c **** 		{
5154:FreeRTOS/Source/tasks.c **** 			/* Return the notification as it was before the bits were cleared,
5155:FreeRTOS/Source/tasks.c **** 			then clear the bit mask. */
5156:FreeRTOS/Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
 4683              		.loc 1 5156 0 discriminator 4
 4684 1626 094B     		ldr	r3, .L324
 4685 1628 1B68     		ldr	r3, [r3]
 4686 162a 5B6C     		ldr	r3, [r3, #68]
 4687 162c BB60     		str	r3, [r7, #8]
5157:FreeRTOS/Source/tasks.c **** 			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
 4688              		.loc 1 5157 0 discriminator 4
 4689 162e FB68     		ldr	r3, [r7, #12]
 4690 1630 5A6C     		ldr	r2, [r3, #68]
 4691 1632 3B68     		ldr	r3, [r7]
 4692 1634 DB43     		mvns	r3, r3
 4693 1636 1A40     		ands	r2, r2, r3
 4694 1638 FB68     		ldr	r3, [r7, #12]
 4695 163a 5A64     		str	r2, [r3, #68]
5158:FreeRTOS/Source/tasks.c **** 		}
5159:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 4696              		.loc 1 5159 0 discriminator 4
 4697 163c FFF7FEFF 		bl	vPortExitCritical
5160:FreeRTOS/Source/tasks.c **** 
5161:FreeRTOS/Source/tasks.c **** 		return ulReturn;
 4698              		.loc 1 5161 0 discriminator 4
 4699 1640 BB68     		ldr	r3, [r7, #8]
ARM GAS  /tmp/cckqXCjj.s 			page 179


5162:FreeRTOS/Source/tasks.c **** 	}
 4700              		.loc 1 5162 0 discriminator 4
 4701 1642 1846     		mov	r0, r3
 4702 1644 1037     		adds	r7, r7, #16
 4703              		.cfi_def_cfa_offset 8
 4704 1646 BD46     		mov	sp, r7
 4705              		.cfi_def_cfa_register 13
 4706              		@ sp needed
 4707 1648 80BD     		pop	{r7, pc}
 4708              	.L325:
 4709 164a 00BF     		.align	2
 4710              	.L324:
 4711 164c 00000000 		.word	pxCurrentTCB
 4712              		.cfi_endproc
 4713              	.LFE50:
 4714              		.size	ulTaskNotifyValueClear, .-ulTaskNotifyValueClear
 4715              		.align	1
 4716              		.syntax unified
 4717              		.thumb
 4718              		.thumb_func
 4719              		.fpu softvfp
 4720              		.type	prvAddCurrentTaskToDelayedList, %function
 4721              	prvAddCurrentTaskToDelayedList:
 4722              	.LFB51:
5163:FreeRTOS/Source/tasks.c **** 
5164:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5165:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5166:FreeRTOS/Source/tasks.c **** 
5167:FreeRTOS/Source/tasks.c **** #if( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) )
5168:FreeRTOS/Source/tasks.c **** 
5169:FreeRTOS/Source/tasks.c **** 	uint32_t ulTaskGetIdleRunTimeCounter( void )
5170:FreeRTOS/Source/tasks.c **** 	{
5171:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle->ulRunTimeCounter;
5172:FreeRTOS/Source/tasks.c **** 	}
5173:FreeRTOS/Source/tasks.c **** 
5174:FreeRTOS/Source/tasks.c **** #endif
5175:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5176:FreeRTOS/Source/tasks.c **** 
5177:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
5178:FreeRTOS/Source/tasks.c **** {
 4723              		.loc 1 5178 0
 4724              		.cfi_startproc
 4725              		@ args = 0, pretend = 0, frame = 16
 4726              		@ frame_needed = 1, uses_anonymous_args = 0
 4727 1650 80B5     		push	{r7, lr}
 4728              		.cfi_def_cfa_offset 8
 4729              		.cfi_offset 7, -8
 4730              		.cfi_offset 14, -4
 4731 1652 84B0     		sub	sp, sp, #16
 4732              		.cfi_def_cfa_offset 24
 4733 1654 00AF     		add	r7, sp, #0
 4734              		.cfi_def_cfa_register 7
 4735 1656 7860     		str	r0, [r7, #4]
 4736 1658 3960     		str	r1, [r7]
5179:FreeRTOS/Source/tasks.c **** TickType_t xTimeToWake;
5180:FreeRTOS/Source/tasks.c **** const TickType_t xConstTickCount = xTickCount;
 4737              		.loc 1 5180 0
ARM GAS  /tmp/cckqXCjj.s 			page 180


 4738 165a 294B     		ldr	r3, .L332
 4739 165c 1B68     		ldr	r3, [r3]
 4740 165e FB60     		str	r3, [r7, #12]
5181:FreeRTOS/Source/tasks.c **** 
5182:FreeRTOS/Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
5183:FreeRTOS/Source/tasks.c **** 	{
5184:FreeRTOS/Source/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
5185:FreeRTOS/Source/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
5186:FreeRTOS/Source/tasks.c **** 		when the task leaves the Blocked state. */
5187:FreeRTOS/Source/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
5188:FreeRTOS/Source/tasks.c **** 	}
5189:FreeRTOS/Source/tasks.c **** 	#endif
5190:FreeRTOS/Source/tasks.c **** 
5191:FreeRTOS/Source/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
5192:FreeRTOS/Source/tasks.c **** 	as the same list item is used for both lists. */
5193:FreeRTOS/Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4741              		.loc 1 5193 0
 4742 1660 284B     		ldr	r3, .L332+4
 4743 1662 1B68     		ldr	r3, [r3]
 4744 1664 0433     		adds	r3, r3, #4
 4745 1666 1846     		mov	r0, r3
 4746 1668 FFF7FEFF 		bl	uxListRemove
 4747 166c 0346     		mov	r3, r0
 4748 166e 002B     		cmp	r3, #0
 4749 1670 0BD1     		bne	.L327
5194:FreeRTOS/Source/tasks.c **** 	{
5195:FreeRTOS/Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
5196:FreeRTOS/Source/tasks.c **** 		check, and the port reset macro can be called directly. */
5197:FreeRTOS/Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentT
 4750              		.loc 1 5197 0
 4751 1672 244B     		ldr	r3, .L332+4
 4752 1674 1B68     		ldr	r3, [r3]
 4753 1676 DB6A     		ldr	r3, [r3, #44]
 4754 1678 0122     		movs	r2, #1
 4755 167a 02FA03F3 		lsl	r3, r2, r3
 4756 167e DA43     		mvns	r2, r3
 4757 1680 214B     		ldr	r3, .L332+8
 4758 1682 1B68     		ldr	r3, [r3]
 4759 1684 1340     		ands	r3, r3, r2
 4760 1686 204A     		ldr	r2, .L332+8
 4761 1688 1360     		str	r3, [r2]
 4762              	.L327:
5198:FreeRTOS/Source/tasks.c **** 	}
5199:FreeRTOS/Source/tasks.c **** 	else
5200:FreeRTOS/Source/tasks.c **** 	{
5201:FreeRTOS/Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
5202:FreeRTOS/Source/tasks.c **** 	}
5203:FreeRTOS/Source/tasks.c **** 
5204:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
5205:FreeRTOS/Source/tasks.c **** 	{
5206:FreeRTOS/Source/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 4763              		.loc 1 5206 0
 4764 168a 7B68     		ldr	r3, [r7, #4]
 4765 168c B3F1FF3F 		cmp	r3, #-1
 4766 1690 0AD1     		bne	.L328
 4767              		.loc 1 5206 0 is_stmt 0 discriminator 1
 4768 1692 3B68     		ldr	r3, [r7]
ARM GAS  /tmp/cckqXCjj.s 			page 181


 4769 1694 002B     		cmp	r3, #0
 4770 1696 07D0     		beq	.L328
5207:FreeRTOS/Source/tasks.c **** 		{
5208:FreeRTOS/Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
5209:FreeRTOS/Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
5210:FreeRTOS/Source/tasks.c **** 			indefinitely. */
5211:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 4771              		.loc 1 5211 0 is_stmt 1
 4772 1698 1A4B     		ldr	r3, .L332+4
 4773 169a 1B68     		ldr	r3, [r3]
 4774 169c 0433     		adds	r3, r3, #4
 4775 169e 1946     		mov	r1, r3
 4776 16a0 1A48     		ldr	r0, .L332+12
 4777 16a2 FFF7FEFF 		bl	vListInsertEnd
5212:FreeRTOS/Source/tasks.c **** 		}
5213:FreeRTOS/Source/tasks.c **** 		else
5214:FreeRTOS/Source/tasks.c **** 		{
5215:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
5216:FreeRTOS/Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
5217:FreeRTOS/Source/tasks.c **** 			kernel will manage it correctly. */
5218:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
5219:FreeRTOS/Source/tasks.c **** 
5220:FreeRTOS/Source/tasks.c **** 			/* The list item will be inserted in wake time order. */
5221:FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5222:FreeRTOS/Source/tasks.c **** 
5223:FreeRTOS/Source/tasks.c **** 			if( xTimeToWake < xConstTickCount )
5224:FreeRTOS/Source/tasks.c **** 			{
5225:FreeRTOS/Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
5226:FreeRTOS/Source/tasks.c **** 				list. */
5227:FreeRTOS/Source/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5228:FreeRTOS/Source/tasks.c **** 			}
5229:FreeRTOS/Source/tasks.c **** 			else
5230:FreeRTOS/Source/tasks.c **** 			{
5231:FreeRTOS/Source/tasks.c **** 				/* The wake time has not overflowed, so the current block list
5232:FreeRTOS/Source/tasks.c **** 				is used. */
5233:FreeRTOS/Source/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5234:FreeRTOS/Source/tasks.c **** 
5235:FreeRTOS/Source/tasks.c **** 				/* If the task entering the blocked state was placed at the
5236:FreeRTOS/Source/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
5237:FreeRTOS/Source/tasks.c **** 				needs to be updated too. */
5238:FreeRTOS/Source/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
5239:FreeRTOS/Source/tasks.c **** 				{
5240:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
5241:FreeRTOS/Source/tasks.c **** 				}
5242:FreeRTOS/Source/tasks.c **** 				else
5243:FreeRTOS/Source/tasks.c **** 				{
5244:FreeRTOS/Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
5245:FreeRTOS/Source/tasks.c **** 				}
5246:FreeRTOS/Source/tasks.c **** 			}
5247:FreeRTOS/Source/tasks.c **** 		}
5248:FreeRTOS/Source/tasks.c **** 	}
5249:FreeRTOS/Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
5250:FreeRTOS/Source/tasks.c **** 	{
5251:FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event
5252:FreeRTOS/Source/tasks.c **** 		does not occur.  This may overflow but this doesn't matter, the kernel
5253:FreeRTOS/Source/tasks.c **** 		will manage it correctly. */
5254:FreeRTOS/Source/tasks.c **** 		xTimeToWake = xConstTickCount + xTicksToWait;
ARM GAS  /tmp/cckqXCjj.s 			page 182


5255:FreeRTOS/Source/tasks.c **** 
5256:FreeRTOS/Source/tasks.c **** 		/* The list item will be inserted in wake time order. */
5257:FreeRTOS/Source/tasks.c **** 		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5258:FreeRTOS/Source/tasks.c **** 
5259:FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xConstTickCount )
5260:FreeRTOS/Source/tasks.c **** 		{
5261:FreeRTOS/Source/tasks.c **** 			/* Wake time has overflowed.  Place this item in the overflow list. */
5262:FreeRTOS/Source/tasks.c **** 			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5263:FreeRTOS/Source/tasks.c **** 		}
5264:FreeRTOS/Source/tasks.c **** 		else
5265:FreeRTOS/Source/tasks.c **** 		{
5266:FreeRTOS/Source/tasks.c **** 			/* The wake time has not overflowed, so the current block list is used. */
5267:FreeRTOS/Source/tasks.c **** 			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5268:FreeRTOS/Source/tasks.c **** 
5269:FreeRTOS/Source/tasks.c **** 			/* If the task entering the blocked state was placed at the head of the
5270:FreeRTOS/Source/tasks.c **** 			list of blocked tasks then xNextTaskUnblockTime needs to be updated
5271:FreeRTOS/Source/tasks.c **** 			too. */
5272:FreeRTOS/Source/tasks.c **** 			if( xTimeToWake < xNextTaskUnblockTime )
5273:FreeRTOS/Source/tasks.c **** 			{
5274:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = xTimeToWake;
5275:FreeRTOS/Source/tasks.c **** 			}
5276:FreeRTOS/Source/tasks.c **** 			else
5277:FreeRTOS/Source/tasks.c **** 			{
5278:FreeRTOS/Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
5279:FreeRTOS/Source/tasks.c **** 			}
5280:FreeRTOS/Source/tasks.c **** 		}
5281:FreeRTOS/Source/tasks.c **** 
5282:FreeRTOS/Source/tasks.c **** 		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
5283:FreeRTOS/Source/tasks.c **** 		( void ) xCanBlockIndefinitely;
5284:FreeRTOS/Source/tasks.c **** 	}
5285:FreeRTOS/Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
5286:FreeRTOS/Source/tasks.c **** }
 4778              		.loc 1 5286 0
 4779 16a6 26E0     		b	.L331
 4780              	.L328:
5218:FreeRTOS/Source/tasks.c **** 
 4781              		.loc 1 5218 0
 4782 16a8 FA68     		ldr	r2, [r7, #12]
 4783 16aa 7B68     		ldr	r3, [r7, #4]
 4784 16ac 1344     		add	r3, r3, r2
 4785 16ae BB60     		str	r3, [r7, #8]
5221:FreeRTOS/Source/tasks.c **** 
 4786              		.loc 1 5221 0
 4787 16b0 144B     		ldr	r3, .L332+4
 4788 16b2 1B68     		ldr	r3, [r3]
 4789 16b4 BA68     		ldr	r2, [r7, #8]
 4790 16b6 5A60     		str	r2, [r3, #4]
5223:FreeRTOS/Source/tasks.c **** 			{
 4791              		.loc 1 5223 0
 4792 16b8 BA68     		ldr	r2, [r7, #8]
 4793 16ba FB68     		ldr	r3, [r7, #12]
 4794 16bc 9A42     		cmp	r2, r3
 4795 16be 09D2     		bcs	.L330
5227:FreeRTOS/Source/tasks.c **** 			}
 4796              		.loc 1 5227 0
 4797 16c0 134B     		ldr	r3, .L332+16
 4798 16c2 1A68     		ldr	r2, [r3]
ARM GAS  /tmp/cckqXCjj.s 			page 183


 4799 16c4 0F4B     		ldr	r3, .L332+4
 4800 16c6 1B68     		ldr	r3, [r3]
 4801 16c8 0433     		adds	r3, r3, #4
 4802 16ca 1946     		mov	r1, r3
 4803 16cc 1046     		mov	r0, r2
 4804 16ce FFF7FEFF 		bl	vListInsert
 4805              		.loc 1 5286 0
 4806 16d2 10E0     		b	.L331
 4807              	.L330:
5233:FreeRTOS/Source/tasks.c **** 
 4808              		.loc 1 5233 0
 4809 16d4 0F4B     		ldr	r3, .L332+20
 4810 16d6 1A68     		ldr	r2, [r3]
 4811 16d8 0A4B     		ldr	r3, .L332+4
 4812 16da 1B68     		ldr	r3, [r3]
 4813 16dc 0433     		adds	r3, r3, #4
 4814 16de 1946     		mov	r1, r3
 4815 16e0 1046     		mov	r0, r2
 4816 16e2 FFF7FEFF 		bl	vListInsert
5238:FreeRTOS/Source/tasks.c **** 				{
 4817              		.loc 1 5238 0
 4818 16e6 0C4B     		ldr	r3, .L332+24
 4819 16e8 1B68     		ldr	r3, [r3]
 4820 16ea BA68     		ldr	r2, [r7, #8]
 4821 16ec 9A42     		cmp	r2, r3
 4822 16ee 02D2     		bcs	.L331
5240:FreeRTOS/Source/tasks.c **** 				}
 4823              		.loc 1 5240 0
 4824 16f0 094A     		ldr	r2, .L332+24
 4825 16f2 BB68     		ldr	r3, [r7, #8]
 4826 16f4 1360     		str	r3, [r2]
 4827              	.L331:
 4828              		.loc 1 5286 0
 4829 16f6 00BF     		nop
 4830 16f8 1037     		adds	r7, r7, #16
 4831              		.cfi_def_cfa_offset 8
 4832 16fa BD46     		mov	sp, r7
 4833              		.cfi_def_cfa_register 13
 4834              		@ sp needed
 4835 16fc 80BD     		pop	{r7, pc}
 4836              	.L333:
 4837 16fe 00BF     		.align	2
 4838              	.L332:
 4839 1700 DC000000 		.word	xTickCount
 4840 1704 00000000 		.word	pxCurrentTCB
 4841 1708 E0000000 		.word	uxTopReadyPriority
 4842 170c C4000000 		.word	xSuspendedTaskList
 4843 1710 94000000 		.word	pxOverflowDelayedTaskList
 4844 1714 90000000 		.word	pxDelayedTaskList
 4845 1718 F8000000 		.word	xNextTaskUnblockTime
 4846              		.cfi_endproc
 4847              	.LFE51:
 4848              		.size	prvAddCurrentTaskToDelayedList, .-prvAddCurrentTaskToDelayedList
 4849              	.Letext0:
 4850              		.file 3 "/usr/lib/gcc/arm-none-eabi/6.3.1/include/stddef.h"
 4851              		.file 4 "/usr/include/newlib/machine/_default_types.h"
 4852              		.file 5 "/usr/include/newlib/sys/lock.h"
ARM GAS  /tmp/cckqXCjj.s 			page 184


 4853              		.file 6 "/usr/include/newlib/sys/_types.h"
 4854              		.file 7 "/usr/include/newlib/sys/reent.h"
 4855              		.file 8 "/usr/include/newlib/sys/_stdint.h"
 4856              		.file 9 "include/FreeRTOSConfig.h"
 4857              		.file 10 "FreeRTOS/Source/include/projdefs.h"
 4858              		.file 11 "FreeRTOS/Source/include/list.h"
 4859              		.file 12 "FreeRTOS/Source/include/task.h"
 4860              		.section	.debug_info,"",%progbits
 4861              	.Ldebug_info0:
 4862 0000 8C1C0000 		.4byte	0x1c8c
 4863 0004 0400     		.2byte	0x4
 4864 0006 00000000 		.4byte	.Ldebug_abbrev0
 4865 000a 04       		.byte	0x4
 4866 000b 01       		.uleb128 0x1
 4867 000c 3D000000 		.4byte	.LASF303
 4868 0010 0C       		.byte	0xc
 4869 0011 9B0B0000 		.4byte	.LASF304
 4870 0015 04080000 		.4byte	.LASF305
 4871 0019 00000000 		.4byte	.Ltext0
 4872 001d 1C170000 		.4byte	.Letext0-.Ltext0
 4873 0021 00000000 		.4byte	.Ldebug_line0
 4874 0025 02       		.uleb128 0x2
 4875 0026 2B050000 		.4byte	.LASF2
 4876 002a 03       		.byte	0x3
 4877 002b D8       		.byte	0xd8
 4878 002c 30000000 		.4byte	0x30
 4879 0030 03       		.uleb128 0x3
 4880 0031 04       		.byte	0x4
 4881 0032 07       		.byte	0x7
 4882 0033 67010000 		.4byte	.LASF0
 4883 0037 04       		.uleb128 0x4
 4884 0038 04       		.byte	0x4
 4885 0039 05       		.byte	0x5
 4886 003a 696E7400 		.ascii	"int\000"
 4887 003e 03       		.uleb128 0x3
 4888 003f 01       		.byte	0x1
 4889 0040 06       		.byte	0x6
 4890 0041 410F0000 		.4byte	.LASF1
 4891 0045 02       		.uleb128 0x2
 4892 0046 610C0000 		.4byte	.LASF3
 4893 004a 04       		.byte	0x4
 4894 004b 1D       		.byte	0x1d
 4895 004c 50000000 		.4byte	0x50
 4896 0050 03       		.uleb128 0x3
 4897 0051 01       		.byte	0x1
 4898 0052 08       		.byte	0x8
 4899 0053 CC0D0000 		.4byte	.LASF4
 4900 0057 03       		.uleb128 0x3
 4901 0058 02       		.byte	0x2
 4902 0059 05       		.byte	0x5
 4903 005a 040B0000 		.4byte	.LASF5
 4904 005e 02       		.uleb128 0x2
 4905 005f E1040000 		.4byte	.LASF6
 4906 0063 04       		.byte	0x4
 4907 0064 2B       		.byte	0x2b
 4908 0065 69000000 		.4byte	0x69
 4909 0069 03       		.uleb128 0x3
ARM GAS  /tmp/cckqXCjj.s 			page 185


 4910 006a 02       		.byte	0x2
 4911 006b 07       		.byte	0x7
 4912 006c 6B0F0000 		.4byte	.LASF7
 4913 0070 03       		.uleb128 0x3
 4914 0071 04       		.byte	0x4
 4915 0072 05       		.byte	0x5
 4916 0073 3B0B0000 		.4byte	.LASF8
 4917 0077 02       		.uleb128 0x2
 4918 0078 F90D0000 		.4byte	.LASF9
 4919 007c 04       		.byte	0x4
 4920 007d 41       		.byte	0x41
 4921 007e 82000000 		.4byte	0x82
 4922 0082 03       		.uleb128 0x3
 4923 0083 04       		.byte	0x4
 4924 0084 07       		.byte	0x7
 4925 0085 120D0000 		.4byte	.LASF10
 4926 0089 03       		.uleb128 0x3
 4927 008a 08       		.byte	0x8
 4928 008b 05       		.byte	0x5
 4929 008c 39080000 		.4byte	.LASF11
 4930 0090 03       		.uleb128 0x3
 4931 0091 08       		.byte	0x8
 4932 0092 07       		.byte	0x7
 4933 0093 35040000 		.4byte	.LASF12
 4934 0097 02       		.uleb128 0x2
 4935 0098 4F020000 		.4byte	.LASF13
 4936 009c 05       		.byte	0x5
 4937 009d 07       		.byte	0x7
 4938 009e 37000000 		.4byte	0x37
 4939 00a2 02       		.uleb128 0x2
 4940 00a3 A20F0000 		.4byte	.LASF14
 4941 00a7 06       		.byte	0x6
 4942 00a8 2C       		.byte	0x2c
 4943 00a9 70000000 		.4byte	0x70
 4944 00ad 02       		.uleb128 0x2
 4945 00ae DB020000 		.4byte	.LASF15
 4946 00b2 06       		.byte	0x6
 4947 00b3 72       		.byte	0x72
 4948 00b4 70000000 		.4byte	0x70
 4949 00b8 05       		.uleb128 0x5
 4950 00b9 3D0D0000 		.4byte	.LASF16
 4951 00bd 03       		.byte	0x3
 4952 00be 6501     		.2byte	0x165
 4953 00c0 30000000 		.4byte	0x30
 4954 00c4 06       		.uleb128 0x6
 4955 00c5 04       		.byte	0x4
 4956 00c6 06       		.byte	0x6
 4957 00c7 A6       		.byte	0xa6
 4958 00c8 E3000000 		.4byte	0xe3
 4959 00cc 07       		.uleb128 0x7
 4960 00cd 78070000 		.4byte	.LASF17
 4961 00d1 06       		.byte	0x6
 4962 00d2 A8       		.byte	0xa8
 4963 00d3 B8000000 		.4byte	0xb8
 4964 00d7 07       		.uleb128 0x7
 4965 00d8 D90B0000 		.4byte	.LASF18
 4966 00dc 06       		.byte	0x6
ARM GAS  /tmp/cckqXCjj.s 			page 186


 4967 00dd A9       		.byte	0xa9
 4968 00de E3000000 		.4byte	0xe3
 4969 00e2 00       		.byte	0
 4970 00e3 08       		.uleb128 0x8
 4971 00e4 50000000 		.4byte	0x50
 4972 00e8 F3000000 		.4byte	0xf3
 4973 00ec 09       		.uleb128 0x9
 4974 00ed F3000000 		.4byte	0xf3
 4975 00f1 03       		.byte	0x3
 4976 00f2 00       		.byte	0
 4977 00f3 03       		.uleb128 0x3
 4978 00f4 04       		.byte	0x4
 4979 00f5 07       		.byte	0x7
 4980 00f6 F80C0000 		.4byte	.LASF19
 4981 00fa 0A       		.uleb128 0xa
 4982 00fb 08       		.byte	0x8
 4983 00fc 06       		.byte	0x6
 4984 00fd A3       		.byte	0xa3
 4985 00fe 1B010000 		.4byte	0x11b
 4986 0102 0B       		.uleb128 0xb
 4987 0103 A4030000 		.4byte	.LASF20
 4988 0107 06       		.byte	0x6
 4989 0108 A5       		.byte	0xa5
 4990 0109 37000000 		.4byte	0x37
 4991 010d 00       		.byte	0
 4992 010e 0B       		.uleb128 0xb
 4993 010f 23060000 		.4byte	.LASF21
 4994 0113 06       		.byte	0x6
 4995 0114 AA       		.byte	0xaa
 4996 0115 C4000000 		.4byte	0xc4
 4997 0119 04       		.byte	0x4
 4998 011a 00       		.byte	0
 4999 011b 02       		.uleb128 0x2
 5000 011c 6A090000 		.4byte	.LASF22
 5001 0120 06       		.byte	0x6
 5002 0121 AB       		.byte	0xab
 5003 0122 FA000000 		.4byte	0xfa
 5004 0126 02       		.uleb128 0x2
 5005 0127 54070000 		.4byte	.LASF23
 5006 012b 06       		.byte	0x6
 5007 012c AF       		.byte	0xaf
 5008 012d 97000000 		.4byte	0x97
 5009 0131 0C       		.uleb128 0xc
 5010 0132 04       		.byte	0x4
 5011 0133 0D       		.uleb128 0xd
 5012 0134 31010000 		.4byte	0x131
 5013 0138 0E       		.uleb128 0xe
 5014 0139 04       		.byte	0x4
 5015 013a 3E010000 		.4byte	0x13e
 5016 013e 03       		.uleb128 0x3
 5017 013f 01       		.byte	0x1
 5018 0140 08       		.byte	0x8
 5019 0141 99060000 		.4byte	.LASF24
 5020 0145 0D       		.uleb128 0xd
 5021 0146 3E010000 		.4byte	0x13e
 5022 014a 02       		.uleb128 0x2
 5023 014b 7E080000 		.4byte	.LASF25
ARM GAS  /tmp/cckqXCjj.s 			page 187


 5024 014f 07       		.byte	0x7
 5025 0150 16       		.byte	0x16
 5026 0151 82000000 		.4byte	0x82
 5027 0155 0F       		.uleb128 0xf
 5028 0156 13030000 		.4byte	.LASF30
 5029 015a 18       		.byte	0x18
 5030 015b 07       		.byte	0x7
 5031 015c 2D       		.byte	0x2d
 5032 015d A8010000 		.4byte	0x1a8
 5033 0161 0B       		.uleb128 0xb
 5034 0162 9F050000 		.4byte	.LASF26
 5035 0166 07       		.byte	0x7
 5036 0167 2F       		.byte	0x2f
 5037 0168 A8010000 		.4byte	0x1a8
 5038 016c 00       		.byte	0
 5039 016d 10       		.uleb128 0x10
 5040 016e 5F6B00   		.ascii	"_k\000"
 5041 0171 07       		.byte	0x7
 5042 0172 30       		.byte	0x30
 5043 0173 37000000 		.4byte	0x37
 5044 0177 04       		.byte	0x4
 5045 0178 0B       		.uleb128 0xb
 5046 0179 780C0000 		.4byte	.LASF27
 5047 017d 07       		.byte	0x7
 5048 017e 30       		.byte	0x30
 5049 017f 37000000 		.4byte	0x37
 5050 0183 08       		.byte	0x8
 5051 0184 0B       		.uleb128 0xb
 5052 0185 320A0000 		.4byte	.LASF28
 5053 0189 07       		.byte	0x7
 5054 018a 30       		.byte	0x30
 5055 018b 37000000 		.4byte	0x37
 5056 018f 0C       		.byte	0xc
 5057 0190 0B       		.uleb128 0xb
 5058 0191 8F040000 		.4byte	.LASF29
 5059 0195 07       		.byte	0x7
 5060 0196 30       		.byte	0x30
 5061 0197 37000000 		.4byte	0x37
 5062 019b 10       		.byte	0x10
 5063 019c 10       		.uleb128 0x10
 5064 019d 5F7800   		.ascii	"_x\000"
 5065 01a0 07       		.byte	0x7
 5066 01a1 31       		.byte	0x31
 5067 01a2 AE010000 		.4byte	0x1ae
 5068 01a6 14       		.byte	0x14
 5069 01a7 00       		.byte	0
 5070 01a8 0E       		.uleb128 0xe
 5071 01a9 04       		.byte	0x4
 5072 01aa 55010000 		.4byte	0x155
 5073 01ae 08       		.uleb128 0x8
 5074 01af 4A010000 		.4byte	0x14a
 5075 01b3 BE010000 		.4byte	0x1be
 5076 01b7 09       		.uleb128 0x9
 5077 01b8 F3000000 		.4byte	0xf3
 5078 01bc 00       		.byte	0
 5079 01bd 00       		.byte	0
 5080 01be 0F       		.uleb128 0xf
ARM GAS  /tmp/cckqXCjj.s 			page 188


 5081 01bf ED0C0000 		.4byte	.LASF31
 5082 01c3 24       		.byte	0x24
 5083 01c4 07       		.byte	0x7
 5084 01c5 35       		.byte	0x35
 5085 01c6 37020000 		.4byte	0x237
 5086 01ca 0B       		.uleb128 0xb
 5087 01cb 39050000 		.4byte	.LASF32
 5088 01cf 07       		.byte	0x7
 5089 01d0 37       		.byte	0x37
 5090 01d1 37000000 		.4byte	0x37
 5091 01d5 00       		.byte	0
 5092 01d6 0B       		.uleb128 0xb
 5093 01d7 E3030000 		.4byte	.LASF33
 5094 01db 07       		.byte	0x7
 5095 01dc 38       		.byte	0x38
 5096 01dd 37000000 		.4byte	0x37
 5097 01e1 04       		.byte	0x4
 5098 01e2 0B       		.uleb128 0xb
 5099 01e3 64030000 		.4byte	.LASF34
 5100 01e7 07       		.byte	0x7
 5101 01e8 39       		.byte	0x39
 5102 01e9 37000000 		.4byte	0x37
 5103 01ed 08       		.byte	0x8
 5104 01ee 0B       		.uleb128 0xb
 5105 01ef 9E060000 		.4byte	.LASF35
 5106 01f3 07       		.byte	0x7
 5107 01f4 3A       		.byte	0x3a
 5108 01f5 37000000 		.4byte	0x37
 5109 01f9 0C       		.byte	0xc
 5110 01fa 0B       		.uleb128 0xb
 5111 01fb 570A0000 		.4byte	.LASF36
 5112 01ff 07       		.byte	0x7
 5113 0200 3B       		.byte	0x3b
 5114 0201 37000000 		.4byte	0x37
 5115 0205 10       		.byte	0x10
 5116 0206 0B       		.uleb128 0xb
 5117 0207 010C0000 		.4byte	.LASF37
 5118 020b 07       		.byte	0x7
 5119 020c 3C       		.byte	0x3c
 5120 020d 37000000 		.4byte	0x37
 5121 0211 14       		.byte	0x14
 5122 0212 0B       		.uleb128 0xb
 5123 0213 1B030000 		.4byte	.LASF38
 5124 0217 07       		.byte	0x7
 5125 0218 3D       		.byte	0x3d
 5126 0219 37000000 		.4byte	0x37
 5127 021d 18       		.byte	0x18
 5128 021e 0B       		.uleb128 0xb
 5129 021f 4D050000 		.4byte	.LASF39
 5130 0223 07       		.byte	0x7
 5131 0224 3E       		.byte	0x3e
 5132 0225 37000000 		.4byte	0x37
 5133 0229 1C       		.byte	0x1c
 5134 022a 0B       		.uleb128 0xb
 5135 022b AE090000 		.4byte	.LASF40
 5136 022f 07       		.byte	0x7
 5137 0230 3F       		.byte	0x3f
ARM GAS  /tmp/cckqXCjj.s 			page 189


 5138 0231 37000000 		.4byte	0x37
 5139 0235 20       		.byte	0x20
 5140 0236 00       		.byte	0
 5141 0237 11       		.uleb128 0x11
 5142 0238 84000000 		.4byte	.LASF41
 5143 023c 0801     		.2byte	0x108
 5144 023e 07       		.byte	0x7
 5145 023f 48       		.byte	0x48
 5146 0240 77020000 		.4byte	0x277
 5147 0244 0B       		.uleb128 0xb
 5148 0245 390F0000 		.4byte	.LASF42
 5149 0249 07       		.byte	0x7
 5150 024a 49       		.byte	0x49
 5151 024b 77020000 		.4byte	0x277
 5152 024f 00       		.byte	0
 5153 0250 0B       		.uleb128 0xb
 5154 0251 520D0000 		.4byte	.LASF43
 5155 0255 07       		.byte	0x7
 5156 0256 4A       		.byte	0x4a
 5157 0257 77020000 		.4byte	0x277
 5158 025b 80       		.byte	0x80
 5159 025c 12       		.uleb128 0x12
 5160 025d 930F0000 		.4byte	.LASF44
 5161 0261 07       		.byte	0x7
 5162 0262 4C       		.byte	0x4c
 5163 0263 4A010000 		.4byte	0x14a
 5164 0267 0001     		.2byte	0x100
 5165 0269 12       		.uleb128 0x12
 5166 026a DD0F0000 		.4byte	.LASF45
 5167 026e 07       		.byte	0x7
 5168 026f 4F       		.byte	0x4f
 5169 0270 4A010000 		.4byte	0x14a
 5170 0274 0401     		.2byte	0x104
 5171 0276 00       		.byte	0
 5172 0277 08       		.uleb128 0x8
 5173 0278 31010000 		.4byte	0x131
 5174 027c 87020000 		.4byte	0x287
 5175 0280 09       		.uleb128 0x9
 5176 0281 F3000000 		.4byte	0xf3
 5177 0285 1F       		.byte	0x1f
 5178 0286 00       		.byte	0
 5179 0287 11       		.uleb128 0x11
 5180 0288 DD0A0000 		.4byte	.LASF46
 5181 028c 9001     		.2byte	0x190
 5182 028e 07       		.byte	0x7
 5183 028f 5B       		.byte	0x5b
 5184 0290 C5020000 		.4byte	0x2c5
 5185 0294 0B       		.uleb128 0xb
 5186 0295 9F050000 		.4byte	.LASF26
 5187 0299 07       		.byte	0x7
 5188 029a 5C       		.byte	0x5c
 5189 029b C5020000 		.4byte	0x2c5
 5190 029f 00       		.byte	0
 5191 02a0 0B       		.uleb128 0xb
 5192 02a1 5C050000 		.4byte	.LASF47
 5193 02a5 07       		.byte	0x7
 5194 02a6 5D       		.byte	0x5d
ARM GAS  /tmp/cckqXCjj.s 			page 190


 5195 02a7 37000000 		.4byte	0x37
 5196 02ab 04       		.byte	0x4
 5197 02ac 0B       		.uleb128 0xb
 5198 02ad E3020000 		.4byte	.LASF48
 5199 02b1 07       		.byte	0x7
 5200 02b2 5F       		.byte	0x5f
 5201 02b3 CB020000 		.4byte	0x2cb
 5202 02b7 08       		.byte	0x8
 5203 02b8 0B       		.uleb128 0xb
 5204 02b9 84000000 		.4byte	.LASF41
 5205 02bd 07       		.byte	0x7
 5206 02be 60       		.byte	0x60
 5207 02bf 37020000 		.4byte	0x237
 5208 02c3 88       		.byte	0x88
 5209 02c4 00       		.byte	0
 5210 02c5 0E       		.uleb128 0xe
 5211 02c6 04       		.byte	0x4
 5212 02c7 87020000 		.4byte	0x287
 5213 02cb 08       		.uleb128 0x8
 5214 02cc DB020000 		.4byte	0x2db
 5215 02d0 DB020000 		.4byte	0x2db
 5216 02d4 09       		.uleb128 0x9
 5217 02d5 F3000000 		.4byte	0xf3
 5218 02d9 1F       		.byte	0x1f
 5219 02da 00       		.byte	0
 5220 02db 0E       		.uleb128 0xe
 5221 02dc 04       		.byte	0x4
 5222 02dd E1020000 		.4byte	0x2e1
 5223 02e1 13       		.uleb128 0x13
 5224 02e2 0F       		.uleb128 0xf
 5225 02e3 9E0E0000 		.4byte	.LASF49
 5226 02e7 08       		.byte	0x8
 5227 02e8 07       		.byte	0x7
 5228 02e9 73       		.byte	0x73
 5229 02ea 07030000 		.4byte	0x307
 5230 02ee 0B       		.uleb128 0xb
 5231 02ef 47080000 		.4byte	.LASF50
 5232 02f3 07       		.byte	0x7
 5233 02f4 74       		.byte	0x74
 5234 02f5 07030000 		.4byte	0x307
 5235 02f9 00       		.byte	0
 5236 02fa 0B       		.uleb128 0xb
 5237 02fb 9C0F0000 		.4byte	.LASF51
 5238 02ff 07       		.byte	0x7
 5239 0300 75       		.byte	0x75
 5240 0301 37000000 		.4byte	0x37
 5241 0305 04       		.byte	0x4
 5242 0306 00       		.byte	0
 5243 0307 0E       		.uleb128 0xe
 5244 0308 04       		.byte	0x4
 5245 0309 50000000 		.4byte	0x50
 5246 030d 0F       		.uleb128 0xf
 5247 030e 87040000 		.4byte	.LASF52
 5248 0312 68       		.byte	0x68
 5249 0313 07       		.byte	0x7
 5250 0314 B3       		.byte	0xb3
 5251 0315 37040000 		.4byte	0x437
ARM GAS  /tmp/cckqXCjj.s 			page 191


 5252 0319 10       		.uleb128 0x10
 5253 031a 5F7000   		.ascii	"_p\000"
 5254 031d 07       		.byte	0x7
 5255 031e B4       		.byte	0xb4
 5256 031f 07030000 		.4byte	0x307
 5257 0323 00       		.byte	0
 5258 0324 10       		.uleb128 0x10
 5259 0325 5F7200   		.ascii	"_r\000"
 5260 0328 07       		.byte	0x7
 5261 0329 B5       		.byte	0xb5
 5262 032a 37000000 		.4byte	0x37
 5263 032e 04       		.byte	0x4
 5264 032f 10       		.uleb128 0x10
 5265 0330 5F7700   		.ascii	"_w\000"
 5266 0333 07       		.byte	0x7
 5267 0334 B6       		.byte	0xb6
 5268 0335 37000000 		.4byte	0x37
 5269 0339 08       		.byte	0x8
 5270 033a 0B       		.uleb128 0xb
 5271 033b C7010000 		.4byte	.LASF53
 5272 033f 07       		.byte	0x7
 5273 0340 B7       		.byte	0xb7
 5274 0341 57000000 		.4byte	0x57
 5275 0345 0C       		.byte	0xc
 5276 0346 0B       		.uleb128 0xb
 5277 0347 CA080000 		.4byte	.LASF54
 5278 034b 07       		.byte	0x7
 5279 034c B8       		.byte	0xb8
 5280 034d 57000000 		.4byte	0x57
 5281 0351 0E       		.byte	0xe
 5282 0352 10       		.uleb128 0x10
 5283 0353 5F626600 		.ascii	"_bf\000"
 5284 0357 07       		.byte	0x7
 5285 0358 B9       		.byte	0xb9
 5286 0359 E2020000 		.4byte	0x2e2
 5287 035d 10       		.byte	0x10
 5288 035e 0B       		.uleb128 0xb
 5289 035f BE010000 		.4byte	.LASF55
 5290 0363 07       		.byte	0x7
 5291 0364 BA       		.byte	0xba
 5292 0365 37000000 		.4byte	0x37
 5293 0369 18       		.byte	0x18
 5294 036a 0B       		.uleb128 0xb
 5295 036b F6020000 		.4byte	.LASF56
 5296 036f 07       		.byte	0x7
 5297 0370 C1       		.byte	0xc1
 5298 0371 31010000 		.4byte	0x131
 5299 0375 1C       		.byte	0x1c
 5300 0376 0B       		.uleb128 0xb
 5301 0377 6A020000 		.4byte	.LASF57
 5302 037b 07       		.byte	0x7
 5303 037c C3       		.byte	0xc3
 5304 037d 92050000 		.4byte	0x592
 5305 0381 20       		.byte	0x20
 5306 0382 0B       		.uleb128 0xb
 5307 0383 9A0A0000 		.4byte	.LASF58
 5308 0387 07       		.byte	0x7
ARM GAS  /tmp/cckqXCjj.s 			page 192


 5309 0388 C5       		.byte	0xc5
 5310 0389 C1050000 		.4byte	0x5c1
 5311 038d 24       		.byte	0x24
 5312 038e 0B       		.uleb128 0xb
 5313 038f 14100000 		.4byte	.LASF59
 5314 0393 07       		.byte	0x7
 5315 0394 C8       		.byte	0xc8
 5316 0395 E5050000 		.4byte	0x5e5
 5317 0399 28       		.byte	0x28
 5318 039a 0B       		.uleb128 0xb
 5319 039b 8C070000 		.4byte	.LASF60
 5320 039f 07       		.byte	0x7
 5321 03a0 C9       		.byte	0xc9
 5322 03a1 FF050000 		.4byte	0x5ff
 5323 03a5 2C       		.byte	0x2c
 5324 03a6 10       		.uleb128 0x10
 5325 03a7 5F756200 		.ascii	"_ub\000"
 5326 03ab 07       		.byte	0x7
 5327 03ac CC       		.byte	0xcc
 5328 03ad E2020000 		.4byte	0x2e2
 5329 03b1 30       		.byte	0x30
 5330 03b2 10       		.uleb128 0x10
 5331 03b3 5F757000 		.ascii	"_up\000"
 5332 03b7 07       		.byte	0x7
 5333 03b8 CD       		.byte	0xcd
 5334 03b9 07030000 		.4byte	0x307
 5335 03bd 38       		.byte	0x38
 5336 03be 10       		.uleb128 0x10
 5337 03bf 5F757200 		.ascii	"_ur\000"
 5338 03c3 07       		.byte	0x7
 5339 03c4 CE       		.byte	0xce
 5340 03c5 37000000 		.4byte	0x37
 5341 03c9 3C       		.byte	0x3c
 5342 03ca 0B       		.uleb128 0xb
 5343 03cb 44100000 		.4byte	.LASF61
 5344 03cf 07       		.byte	0x7
 5345 03d0 D1       		.byte	0xd1
 5346 03d1 05060000 		.4byte	0x605
 5347 03d5 40       		.byte	0x40
 5348 03d6 0B       		.uleb128 0xb
 5349 03d7 A90F0000 		.4byte	.LASF62
 5350 03db 07       		.byte	0x7
 5351 03dc D2       		.byte	0xd2
 5352 03dd 15060000 		.4byte	0x615
 5353 03e1 43       		.byte	0x43
 5354 03e2 10       		.uleb128 0x10
 5355 03e3 5F6C6200 		.ascii	"_lb\000"
 5356 03e7 07       		.byte	0x7
 5357 03e8 D5       		.byte	0xd5
 5358 03e9 E2020000 		.4byte	0x2e2
 5359 03ed 44       		.byte	0x44
 5360 03ee 0B       		.uleb128 0xb
 5361 03ef E40C0000 		.4byte	.LASF63
 5362 03f3 07       		.byte	0x7
 5363 03f4 D8       		.byte	0xd8
 5364 03f5 37000000 		.4byte	0x37
 5365 03f9 4C       		.byte	0x4c
ARM GAS  /tmp/cckqXCjj.s 			page 193


 5366 03fa 0B       		.uleb128 0xb
 5367 03fb FA040000 		.4byte	.LASF64
 5368 03ff 07       		.byte	0x7
 5369 0400 D9       		.byte	0xd9
 5370 0401 A2000000 		.4byte	0xa2
 5371 0405 50       		.byte	0x50
 5372 0406 0B       		.uleb128 0xb
 5373 0407 D30B0000 		.4byte	.LASF65
 5374 040b 07       		.byte	0x7
 5375 040c DC       		.byte	0xdc
 5376 040d 55040000 		.4byte	0x455
 5377 0411 54       		.byte	0x54
 5378 0412 0B       		.uleb128 0xb
 5379 0413 F20C0000 		.4byte	.LASF66
 5380 0417 07       		.byte	0x7
 5381 0418 E0       		.byte	0xe0
 5382 0419 26010000 		.4byte	0x126
 5383 041d 58       		.byte	0x58
 5384 041e 0B       		.uleb128 0xb
 5385 041f E50A0000 		.4byte	.LASF67
 5386 0423 07       		.byte	0x7
 5387 0424 E2       		.byte	0xe2
 5388 0425 1B010000 		.4byte	0x11b
 5389 0429 5C       		.byte	0x5c
 5390 042a 0B       		.uleb128 0xb
 5391 042b C90F0000 		.4byte	.LASF68
 5392 042f 07       		.byte	0x7
 5393 0430 E3       		.byte	0xe3
 5394 0431 37000000 		.4byte	0x37
 5395 0435 64       		.byte	0x64
 5396 0436 00       		.byte	0
 5397 0437 14       		.uleb128 0x14
 5398 0438 37000000 		.4byte	0x37
 5399 043c 55040000 		.4byte	0x455
 5400 0440 15       		.uleb128 0x15
 5401 0441 55040000 		.4byte	0x455
 5402 0445 15       		.uleb128 0x15
 5403 0446 31010000 		.4byte	0x131
 5404 044a 15       		.uleb128 0x15
 5405 044b 38010000 		.4byte	0x138
 5406 044f 15       		.uleb128 0x15
 5407 0450 37000000 		.4byte	0x37
 5408 0454 00       		.byte	0
 5409 0455 0E       		.uleb128 0xe
 5410 0456 04       		.byte	0x4
 5411 0457 60040000 		.4byte	0x460
 5412 045b 0D       		.uleb128 0xd
 5413 045c 55040000 		.4byte	0x455
 5414 0460 16       		.uleb128 0x16
 5415 0461 640F0000 		.4byte	.LASF69
 5416 0465 2804     		.2byte	0x428
 5417 0467 07       		.byte	0x7
 5418 0468 3802     		.2byte	0x238
 5419 046a 92050000 		.4byte	0x592
 5420 046e 17       		.uleb128 0x17
 5421 046f F9010000 		.4byte	.LASF70
 5422 0473 07       		.byte	0x7
ARM GAS  /tmp/cckqXCjj.s 			page 194


 5423 0474 3A02     		.2byte	0x23a
 5424 0476 37000000 		.4byte	0x37
 5425 047a 00       		.byte	0
 5426 047b 17       		.uleb128 0x17
 5427 047c 8B030000 		.4byte	.LASF71
 5428 0480 07       		.byte	0x7
 5429 0481 3F02     		.2byte	0x23f
 5430 0483 6C060000 		.4byte	0x66c
 5431 0487 04       		.byte	0x4
 5432 0488 17       		.uleb128 0x17
 5433 0489 C1020000 		.4byte	.LASF72
 5434 048d 07       		.byte	0x7
 5435 048e 3F02     		.2byte	0x23f
 5436 0490 6C060000 		.4byte	0x66c
 5437 0494 08       		.byte	0x8
 5438 0495 17       		.uleb128 0x17
 5439 0496 33100000 		.4byte	.LASF73
 5440 049a 07       		.byte	0x7
 5441 049b 3F02     		.2byte	0x23f
 5442 049d 6C060000 		.4byte	0x66c
 5443 04a1 0C       		.byte	0xc
 5444 04a2 17       		.uleb128 0x17
 5445 04a3 57050000 		.4byte	.LASF74
 5446 04a7 07       		.byte	0x7
 5447 04a8 4102     		.2byte	0x241
 5448 04aa 37000000 		.4byte	0x37
 5449 04ae 10       		.byte	0x10
 5450 04af 17       		.uleb128 0x17
 5451 04b0 12050000 		.4byte	.LASF75
 5452 04b4 07       		.byte	0x7
 5453 04b5 4202     		.2byte	0x242
 5454 04b7 4E080000 		.4byte	0x84e
 5455 04bb 14       		.byte	0x14
 5456 04bc 17       		.uleb128 0x17
 5457 04bd 8A0C0000 		.4byte	.LASF76
 5458 04c1 07       		.byte	0x7
 5459 04c2 4402     		.2byte	0x244
 5460 04c4 37000000 		.4byte	0x37
 5461 04c8 30       		.byte	0x30
 5462 04c9 17       		.uleb128 0x17
 5463 04ca B30B0000 		.4byte	.LASF77
 5464 04ce 07       		.byte	0x7
 5465 04cf 4502     		.2byte	0x245
 5466 04d1 B6050000 		.4byte	0x5b6
 5467 04d5 34       		.byte	0x34
 5468 04d6 17       		.uleb128 0x17
 5469 04d7 AA070000 		.4byte	.LASF78
 5470 04db 07       		.byte	0x7
 5471 04dc 4702     		.2byte	0x247
 5472 04de 37000000 		.4byte	0x37
 5473 04e2 38       		.byte	0x38
 5474 04e3 17       		.uleb128 0x17
 5475 04e4 47090000 		.4byte	.LASF79
 5476 04e8 07       		.byte	0x7
 5477 04e9 4902     		.2byte	0x249
 5478 04eb 69080000 		.4byte	0x869
 5479 04ef 3C       		.byte	0x3c
ARM GAS  /tmp/cckqXCjj.s 			page 195


 5480 04f0 17       		.uleb128 0x17
 5481 04f1 25030000 		.4byte	.LASF80
 5482 04f5 07       		.byte	0x7
 5483 04f6 4C02     		.2byte	0x24c
 5484 04f8 A8010000 		.4byte	0x1a8
 5485 04fc 40       		.byte	0x40
 5486 04fd 17       		.uleb128 0x17
 5487 04fe 2B040000 		.4byte	.LASF81
 5488 0502 07       		.byte	0x7
 5489 0503 4D02     		.2byte	0x24d
 5490 0505 37000000 		.4byte	0x37
 5491 0509 44       		.byte	0x44
 5492 050a 17       		.uleb128 0x17
 5493 050b 2B060000 		.4byte	.LASF82
 5494 050f 07       		.byte	0x7
 5495 0510 4E02     		.2byte	0x24e
 5496 0512 A8010000 		.4byte	0x1a8
 5497 0516 48       		.byte	0x48
 5498 0517 17       		.uleb128 0x17
 5499 0518 4D080000 		.4byte	.LASF83
 5500 051c 07       		.byte	0x7
 5501 051d 4F02     		.2byte	0x24f
 5502 051f 6F080000 		.4byte	0x86f
 5503 0523 4C       		.byte	0x4c
 5504 0524 17       		.uleb128 0x17
 5505 0525 700C0000 		.4byte	.LASF84
 5506 0529 07       		.byte	0x7
 5507 052a 5202     		.2byte	0x252
 5508 052c 37000000 		.4byte	0x37
 5509 0530 50       		.byte	0x50
 5510 0531 17       		.uleb128 0x17
 5511 0532 C40D0000 		.4byte	.LASF85
 5512 0536 07       		.byte	0x7
 5513 0537 5302     		.2byte	0x253
 5514 0539 38010000 		.4byte	0x138
 5515 053d 54       		.byte	0x54
 5516 053e 17       		.uleb128 0x17
 5517 053f 6B0C0000 		.4byte	.LASF86
 5518 0543 07       		.byte	0x7
 5519 0544 7602     		.2byte	0x276
 5520 0546 2C080000 		.4byte	0x82c
 5521 054a 58       		.byte	0x58
 5522 054b 18       		.uleb128 0x18
 5523 054c DD0A0000 		.4byte	.LASF46
 5524 0550 07       		.byte	0x7
 5525 0551 7A02     		.2byte	0x27a
 5526 0553 C5020000 		.4byte	0x2c5
 5527 0557 4801     		.2byte	0x148
 5528 0559 18       		.uleb128 0x18
 5529 055a CC060000 		.4byte	.LASF87
 5530 055e 07       		.byte	0x7
 5531 055f 7B02     		.2byte	0x27b
 5532 0561 87020000 		.4byte	0x287
 5533 0565 4C01     		.2byte	0x14c
 5534 0567 18       		.uleb128 0x18
 5535 0568 B3060000 		.4byte	.LASF88
 5536 056c 07       		.byte	0x7
ARM GAS  /tmp/cckqXCjj.s 			page 196


 5537 056d 7F02     		.2byte	0x27f
 5538 056f 80080000 		.4byte	0x880
 5539 0573 DC02     		.2byte	0x2dc
 5540 0575 18       		.uleb128 0x18
 5541 0576 F00E0000 		.4byte	.LASF89
 5542 057a 07       		.byte	0x7
 5543 057b 8402     		.2byte	0x284
 5544 057d 31060000 		.4byte	0x631
 5545 0581 E002     		.2byte	0x2e0
 5546 0583 18       		.uleb128 0x18
 5547 0584 960B0000 		.4byte	.LASF90
 5548 0588 07       		.byte	0x7
 5549 0589 8502     		.2byte	0x285
 5550 058b 8C080000 		.4byte	0x88c
 5551 058f EC02     		.2byte	0x2ec
 5552 0591 00       		.byte	0
 5553 0592 0E       		.uleb128 0xe
 5554 0593 04       		.byte	0x4
 5555 0594 37040000 		.4byte	0x437
 5556 0598 14       		.uleb128 0x14
 5557 0599 37000000 		.4byte	0x37
 5558 059d B6050000 		.4byte	0x5b6
 5559 05a1 15       		.uleb128 0x15
 5560 05a2 55040000 		.4byte	0x455
 5561 05a6 15       		.uleb128 0x15
 5562 05a7 31010000 		.4byte	0x131
 5563 05ab 15       		.uleb128 0x15
 5564 05ac B6050000 		.4byte	0x5b6
 5565 05b0 15       		.uleb128 0x15
 5566 05b1 37000000 		.4byte	0x37
 5567 05b5 00       		.byte	0
 5568 05b6 0E       		.uleb128 0xe
 5569 05b7 04       		.byte	0x4
 5570 05b8 45010000 		.4byte	0x145
 5571 05bc 0D       		.uleb128 0xd
 5572 05bd B6050000 		.4byte	0x5b6
 5573 05c1 0E       		.uleb128 0xe
 5574 05c2 04       		.byte	0x4
 5575 05c3 98050000 		.4byte	0x598
 5576 05c7 14       		.uleb128 0x14
 5577 05c8 AD000000 		.4byte	0xad
 5578 05cc E5050000 		.4byte	0x5e5
 5579 05d0 15       		.uleb128 0x15
 5580 05d1 55040000 		.4byte	0x455
 5581 05d5 15       		.uleb128 0x15
 5582 05d6 31010000 		.4byte	0x131
 5583 05da 15       		.uleb128 0x15
 5584 05db AD000000 		.4byte	0xad
 5585 05df 15       		.uleb128 0x15
 5586 05e0 37000000 		.4byte	0x37
 5587 05e4 00       		.byte	0
 5588 05e5 0E       		.uleb128 0xe
 5589 05e6 04       		.byte	0x4
 5590 05e7 C7050000 		.4byte	0x5c7
 5591 05eb 14       		.uleb128 0x14
 5592 05ec 37000000 		.4byte	0x37
 5593 05f0 FF050000 		.4byte	0x5ff
ARM GAS  /tmp/cckqXCjj.s 			page 197


 5594 05f4 15       		.uleb128 0x15
 5595 05f5 55040000 		.4byte	0x455
 5596 05f9 15       		.uleb128 0x15
 5597 05fa 31010000 		.4byte	0x131
 5598 05fe 00       		.byte	0
 5599 05ff 0E       		.uleb128 0xe
 5600 0600 04       		.byte	0x4
 5601 0601 EB050000 		.4byte	0x5eb
 5602 0605 08       		.uleb128 0x8
 5603 0606 50000000 		.4byte	0x50
 5604 060a 15060000 		.4byte	0x615
 5605 060e 09       		.uleb128 0x9
 5606 060f F3000000 		.4byte	0xf3
 5607 0613 02       		.byte	0x2
 5608 0614 00       		.byte	0
 5609 0615 08       		.uleb128 0x8
 5610 0616 50000000 		.4byte	0x50
 5611 061a 25060000 		.4byte	0x625
 5612 061e 09       		.uleb128 0x9
 5613 061f F3000000 		.4byte	0xf3
 5614 0623 00       		.byte	0
 5615 0624 00       		.byte	0
 5616 0625 05       		.uleb128 0x5
 5617 0626 EC040000 		.4byte	.LASF91
 5618 062a 07       		.byte	0x7
 5619 062b 1D01     		.2byte	0x11d
 5620 062d 0D030000 		.4byte	0x30d
 5621 0631 19       		.uleb128 0x19
 5622 0632 B20E0000 		.4byte	.LASF92
 5623 0636 0C       		.byte	0xc
 5624 0637 07       		.byte	0x7
 5625 0638 2101     		.2byte	0x121
 5626 063a 66060000 		.4byte	0x666
 5627 063e 17       		.uleb128 0x17
 5628 063f 9F050000 		.4byte	.LASF26
 5629 0643 07       		.byte	0x7
 5630 0644 2301     		.2byte	0x123
 5631 0646 66060000 		.4byte	0x666
 5632 064a 00       		.byte	0
 5633 064b 17       		.uleb128 0x17
 5634 064c 360D0000 		.4byte	.LASF93
 5635 0650 07       		.byte	0x7
 5636 0651 2401     		.2byte	0x124
 5637 0653 37000000 		.4byte	0x37
 5638 0657 04       		.byte	0x4
 5639 0658 17       		.uleb128 0x17
 5640 0659 7E070000 		.4byte	.LASF94
 5641 065d 07       		.byte	0x7
 5642 065e 2501     		.2byte	0x125
 5643 0660 6C060000 		.4byte	0x66c
 5644 0664 08       		.byte	0x8
 5645 0665 00       		.byte	0
 5646 0666 0E       		.uleb128 0xe
 5647 0667 04       		.byte	0x4
 5648 0668 31060000 		.4byte	0x631
 5649 066c 0E       		.uleb128 0xe
 5650 066d 04       		.byte	0x4
ARM GAS  /tmp/cckqXCjj.s 			page 198


 5651 066e 25060000 		.4byte	0x625
 5652 0672 19       		.uleb128 0x19
 5653 0673 FF030000 		.4byte	.LASF95
 5654 0677 0E       		.byte	0xe
 5655 0678 07       		.byte	0x7
 5656 0679 3D01     		.2byte	0x13d
 5657 067b A7060000 		.4byte	0x6a7
 5658 067f 17       		.uleb128 0x17
 5659 0680 F50F0000 		.4byte	.LASF96
 5660 0684 07       		.byte	0x7
 5661 0685 3E01     		.2byte	0x13e
 5662 0687 A7060000 		.4byte	0x6a7
 5663 068b 00       		.byte	0
 5664 068c 17       		.uleb128 0x17
 5665 068d 60080000 		.4byte	.LASF97
 5666 0691 07       		.byte	0x7
 5667 0692 3F01     		.2byte	0x13f
 5668 0694 A7060000 		.4byte	0x6a7
 5669 0698 06       		.byte	0x6
 5670 0699 17       		.uleb128 0x17
 5671 069a 3E0E0000 		.4byte	.LASF98
 5672 069e 07       		.byte	0x7
 5673 069f 4001     		.2byte	0x140
 5674 06a1 69000000 		.4byte	0x69
 5675 06a5 0C       		.byte	0xc
 5676 06a6 00       		.byte	0
 5677 06a7 08       		.uleb128 0x8
 5678 06a8 69000000 		.4byte	0x69
 5679 06ac B7060000 		.4byte	0x6b7
 5680 06b0 09       		.uleb128 0x9
 5681 06b1 F3000000 		.4byte	0xf3
 5682 06b5 02       		.byte	0x2
 5683 06b6 00       		.byte	0
 5684 06b7 1A       		.uleb128 0x1a
 5685 06b8 D0       		.byte	0xd0
 5686 06b9 07       		.byte	0x7
 5687 06ba 5702     		.2byte	0x257
 5688 06bc B8070000 		.4byte	0x7b8
 5689 06c0 17       		.uleb128 0x17
 5690 06c1 AF0F0000 		.4byte	.LASF99
 5691 06c5 07       		.byte	0x7
 5692 06c6 5902     		.2byte	0x259
 5693 06c8 30000000 		.4byte	0x30
 5694 06cc 00       		.byte	0
 5695 06cd 17       		.uleb128 0x17
 5696 06ce F80E0000 		.4byte	.LASF100
 5697 06d2 07       		.byte	0x7
 5698 06d3 5A02     		.2byte	0x25a
 5699 06d5 38010000 		.4byte	0x138
 5700 06d9 04       		.byte	0x4
 5701 06da 17       		.uleb128 0x17
 5702 06db 65040000 		.4byte	.LASF101
 5703 06df 07       		.byte	0x7
 5704 06e0 5B02     		.2byte	0x25b
 5705 06e2 B8070000 		.4byte	0x7b8
 5706 06e6 08       		.byte	0x8
 5707 06e7 17       		.uleb128 0x17
ARM GAS  /tmp/cckqXCjj.s 			page 199


 5708 06e8 4A0C0000 		.4byte	.LASF102
 5709 06ec 07       		.byte	0x7
 5710 06ed 5C02     		.2byte	0x25c
 5711 06ef BE010000 		.4byte	0x1be
 5712 06f3 24       		.byte	0x24
 5713 06f4 17       		.uleb128 0x17
 5714 06f5 2A080000 		.4byte	.LASF103
 5715 06f9 07       		.byte	0x7
 5716 06fa 5D02     		.2byte	0x25d
 5717 06fc 37000000 		.4byte	0x37
 5718 0700 48       		.byte	0x48
 5719 0701 17       		.uleb128 0x17
 5720 0702 FB0F0000 		.4byte	.LASF104
 5721 0706 07       		.byte	0x7
 5722 0707 5E02     		.2byte	0x25e
 5723 0709 90000000 		.4byte	0x90
 5724 070d 50       		.byte	0x50
 5725 070e 17       		.uleb128 0x17
 5726 070f DF000000 		.4byte	.LASF105
 5727 0713 07       		.byte	0x7
 5728 0714 5F02     		.2byte	0x25f
 5729 0716 72060000 		.4byte	0x672
 5730 071a 58       		.byte	0x58
 5731 071b 17       		.uleb128 0x17
 5732 071c 73060000 		.4byte	.LASF106
 5733 0720 07       		.byte	0x7
 5734 0721 6002     		.2byte	0x260
 5735 0723 1B010000 		.4byte	0x11b
 5736 0727 68       		.byte	0x68
 5737 0728 17       		.uleb128 0x17
 5738 0729 050F0000 		.4byte	.LASF107
 5739 072d 07       		.byte	0x7
 5740 072e 6102     		.2byte	0x261
 5741 0730 1B010000 		.4byte	0x11b
 5742 0734 70       		.byte	0x70
 5743 0735 17       		.uleb128 0x17
 5744 0736 A9000000 		.4byte	.LASF108
 5745 073a 07       		.byte	0x7
 5746 073b 6202     		.2byte	0x262
 5747 073d 1B010000 		.4byte	0x11b
 5748 0741 78       		.byte	0x78
 5749 0742 17       		.uleb128 0x17
 5750 0743 800C0000 		.4byte	.LASF109
 5751 0747 07       		.byte	0x7
 5752 0748 6302     		.2byte	0x263
 5753 074a C8070000 		.4byte	0x7c8
 5754 074e 80       		.byte	0x80
 5755 074f 17       		.uleb128 0x17
 5756 0750 5B010000 		.4byte	.LASF110
 5757 0754 07       		.byte	0x7
 5758 0755 6402     		.2byte	0x264
 5759 0757 D8070000 		.4byte	0x7d8
 5760 075b 88       		.byte	0x88
 5761 075c 17       		.uleb128 0x17
 5762 075d 120E0000 		.4byte	.LASF111
 5763 0761 07       		.byte	0x7
 5764 0762 6502     		.2byte	0x265
ARM GAS  /tmp/cckqXCjj.s 			page 200


 5765 0764 37000000 		.4byte	0x37
 5766 0768 A0       		.byte	0xa0
 5767 0769 17       		.uleb128 0x17
 5768 076a 94020000 		.4byte	.LASF112
 5769 076e 07       		.byte	0x7
 5770 076f 6602     		.2byte	0x266
 5771 0771 1B010000 		.4byte	0x11b
 5772 0775 A4       		.byte	0xa4
 5773 0776 17       		.uleb128 0x17
 5774 0777 BD060000 		.4byte	.LASF113
 5775 077b 07       		.byte	0x7
 5776 077c 6702     		.2byte	0x267
 5777 077e 1B010000 		.4byte	0x11b
 5778 0782 AC       		.byte	0xac
 5779 0783 17       		.uleb128 0x17
 5780 0784 B5050000 		.4byte	.LASF114
 5781 0788 07       		.byte	0x7
 5782 0789 6802     		.2byte	0x268
 5783 078b 1B010000 		.4byte	0x11b
 5784 078f B4       		.byte	0xb4
 5785 0790 17       		.uleb128 0x17
 5786 0791 9A080000 		.4byte	.LASF115
 5787 0795 07       		.byte	0x7
 5788 0796 6902     		.2byte	0x269
 5789 0798 1B010000 		.4byte	0x11b
 5790 079c BC       		.byte	0xbc
 5791 079d 17       		.uleb128 0x17
 5792 079e 62060000 		.4byte	.LASF116
 5793 07a2 07       		.byte	0x7
 5794 07a3 6A02     		.2byte	0x26a
 5795 07a5 1B010000 		.4byte	0x11b
 5796 07a9 C4       		.byte	0xc4
 5797 07aa 17       		.uleb128 0x17
 5798 07ab 150A0000 		.4byte	.LASF117
 5799 07af 07       		.byte	0x7
 5800 07b0 6B02     		.2byte	0x26b
 5801 07b2 37000000 		.4byte	0x37
 5802 07b6 CC       		.byte	0xcc
 5803 07b7 00       		.byte	0
 5804 07b8 08       		.uleb128 0x8
 5805 07b9 3E010000 		.4byte	0x13e
 5806 07bd C8070000 		.4byte	0x7c8
 5807 07c1 09       		.uleb128 0x9
 5808 07c2 F3000000 		.4byte	0xf3
 5809 07c6 19       		.byte	0x19
 5810 07c7 00       		.byte	0
 5811 07c8 08       		.uleb128 0x8
 5812 07c9 3E010000 		.4byte	0x13e
 5813 07cd D8070000 		.4byte	0x7d8
 5814 07d1 09       		.uleb128 0x9
 5815 07d2 F3000000 		.4byte	0xf3
 5816 07d6 07       		.byte	0x7
 5817 07d7 00       		.byte	0
 5818 07d8 08       		.uleb128 0x8
 5819 07d9 3E010000 		.4byte	0x13e
 5820 07dd E8070000 		.4byte	0x7e8
 5821 07e1 09       		.uleb128 0x9
ARM GAS  /tmp/cckqXCjj.s 			page 201


 5822 07e2 F3000000 		.4byte	0xf3
 5823 07e6 17       		.byte	0x17
 5824 07e7 00       		.byte	0
 5825 07e8 1A       		.uleb128 0x1a
 5826 07e9 F0       		.byte	0xf0
 5827 07ea 07       		.byte	0x7
 5828 07eb 7002     		.2byte	0x270
 5829 07ed 0C080000 		.4byte	0x80c
 5830 07f1 17       		.uleb128 0x17
 5831 07f2 F8030000 		.4byte	.LASF118
 5832 07f6 07       		.byte	0x7
 5833 07f7 7302     		.2byte	0x273
 5834 07f9 0C080000 		.4byte	0x80c
 5835 07fd 00       		.byte	0
 5836 07fe 17       		.uleb128 0x17
 5837 07ff 3B100000 		.4byte	.LASF119
 5838 0803 07       		.byte	0x7
 5839 0804 7402     		.2byte	0x274
 5840 0806 1C080000 		.4byte	0x81c
 5841 080a 78       		.byte	0x78
 5842 080b 00       		.byte	0
 5843 080c 08       		.uleb128 0x8
 5844 080d 07030000 		.4byte	0x307
 5845 0811 1C080000 		.4byte	0x81c
 5846 0815 09       		.uleb128 0x9
 5847 0816 F3000000 		.4byte	0xf3
 5848 081a 1D       		.byte	0x1d
 5849 081b 00       		.byte	0
 5850 081c 08       		.uleb128 0x8
 5851 081d 30000000 		.4byte	0x30
 5852 0821 2C080000 		.4byte	0x82c
 5853 0825 09       		.uleb128 0x9
 5854 0826 F3000000 		.4byte	0xf3
 5855 082a 1D       		.byte	0x1d
 5856 082b 00       		.byte	0
 5857 082c 1B       		.uleb128 0x1b
 5858 082d F0       		.byte	0xf0
 5859 082e 07       		.byte	0x7
 5860 082f 5502     		.2byte	0x255
 5861 0831 4E080000 		.4byte	0x84e
 5862 0835 1C       		.uleb128 0x1c
 5863 0836 640F0000 		.4byte	.LASF69
 5864 083a 07       		.byte	0x7
 5865 083b 6C02     		.2byte	0x26c
 5866 083d B7060000 		.4byte	0x6b7
 5867 0841 1C       		.uleb128 0x1c
 5868 0842 590C0000 		.4byte	.LASF120
 5869 0846 07       		.byte	0x7
 5870 0847 7502     		.2byte	0x275
 5871 0849 E8070000 		.4byte	0x7e8
 5872 084d 00       		.byte	0
 5873 084e 08       		.uleb128 0x8
 5874 084f 3E010000 		.4byte	0x13e
 5875 0853 5E080000 		.4byte	0x85e
 5876 0857 09       		.uleb128 0x9
 5877 0858 F3000000 		.4byte	0xf3
 5878 085c 18       		.byte	0x18
ARM GAS  /tmp/cckqXCjj.s 			page 202


 5879 085d 00       		.byte	0
 5880 085e 1D       		.uleb128 0x1d
 5881 085f 69080000 		.4byte	0x869
 5882 0863 15       		.uleb128 0x15
 5883 0864 55040000 		.4byte	0x455
 5884 0868 00       		.byte	0
 5885 0869 0E       		.uleb128 0xe
 5886 086a 04       		.byte	0x4
 5887 086b 5E080000 		.4byte	0x85e
 5888 086f 0E       		.uleb128 0xe
 5889 0870 04       		.byte	0x4
 5890 0871 A8010000 		.4byte	0x1a8
 5891 0875 1D       		.uleb128 0x1d
 5892 0876 80080000 		.4byte	0x880
 5893 087a 15       		.uleb128 0x15
 5894 087b 37000000 		.4byte	0x37
 5895 087f 00       		.byte	0
 5896 0880 0E       		.uleb128 0xe
 5897 0881 04       		.byte	0x4
 5898 0882 86080000 		.4byte	0x886
 5899 0886 0E       		.uleb128 0xe
 5900 0887 04       		.byte	0x4
 5901 0888 75080000 		.4byte	0x875
 5902 088c 08       		.uleb128 0x8
 5903 088d 25060000 		.4byte	0x625
 5904 0891 9C080000 		.4byte	0x89c
 5905 0895 09       		.uleb128 0x9
 5906 0896 F3000000 		.4byte	0xf3
 5907 089a 02       		.byte	0x2
 5908 089b 00       		.byte	0
 5909 089c 1E       		.uleb128 0x1e
 5910 089d EC030000 		.4byte	.LASF121
 5911 08a1 07       		.byte	0x7
 5912 08a2 FD02     		.2byte	0x2fd
 5913 08a4 55040000 		.4byte	0x455
 5914 08a8 1E       		.uleb128 0x1e
 5915 08a9 E00B0000 		.4byte	.LASF122
 5916 08ad 07       		.byte	0x7
 5917 08ae FE02     		.2byte	0x2fe
 5918 08b0 5B040000 		.4byte	0x45b
 5919 08b4 02       		.uleb128 0x2
 5920 08b5 84070000 		.4byte	.LASF123
 5921 08b9 08       		.byte	0x8
 5922 08ba 18       		.byte	0x18
 5923 08bb 45000000 		.4byte	0x45
 5924 08bf 1F       		.uleb128 0x1f
 5925 08c0 B4080000 		.4byte	0x8b4
 5926 08c4 02       		.uleb128 0x2
 5927 08c5 850A0000 		.4byte	.LASF124
 5928 08c9 08       		.byte	0x8
 5929 08ca 24       		.byte	0x24
 5930 08cb 5E000000 		.4byte	0x5e
 5931 08cf 0D       		.uleb128 0xd
 5932 08d0 C4080000 		.4byte	0x8c4
 5933 08d4 02       		.uleb128 0x2
 5934 08d5 44030000 		.4byte	.LASF125
 5935 08d9 08       		.byte	0x8
ARM GAS  /tmp/cckqXCjj.s 			page 203


 5936 08da 30       		.byte	0x30
 5937 08db 77000000 		.4byte	0x77
 5938 08df 1F       		.uleb128 0x1f
 5939 08e0 D4080000 		.4byte	0x8d4
 5940 08e4 0D       		.uleb128 0xd
 5941 08e5 D4080000 		.4byte	0x8d4
 5942 08e9 20       		.uleb128 0x20
 5943 08ea 2D000000 		.4byte	.LASF126
 5944 08ee 09       		.byte	0x9
 5945 08ef 2B       		.byte	0x2b
 5946 08f0 D4080000 		.4byte	0x8d4
 5947 08f4 02       		.uleb128 0x2
 5948 08f5 0A090000 		.4byte	.LASF127
 5949 08f9 0A       		.byte	0xa
 5950 08fa 23       		.byte	0x23
 5951 08fb FF080000 		.4byte	0x8ff
 5952 08ff 0E       		.uleb128 0xe
 5953 0900 04       		.byte	0x4
 5954 0901 05090000 		.4byte	0x905
 5955 0905 1D       		.uleb128 0x1d
 5956 0906 10090000 		.4byte	0x910
 5957 090a 15       		.uleb128 0x15
 5958 090b 31010000 		.4byte	0x131
 5959 090f 00       		.byte	0
 5960 0910 02       		.uleb128 0x2
 5961 0911 9A010000 		.4byte	.LASF128
 5962 0915 02       		.byte	0x2
 5963 0916 37       		.byte	0x37
 5964 0917 D4080000 		.4byte	0x8d4
 5965 091b 1F       		.uleb128 0x1f
 5966 091c 10090000 		.4byte	0x910
 5967 0920 02       		.uleb128 0x2
 5968 0921 A9080000 		.4byte	.LASF129
 5969 0925 02       		.byte	0x2
 5970 0926 38       		.byte	0x38
 5971 0927 70000000 		.4byte	0x70
 5972 092b 1F       		.uleb128 0x1f
 5973 092c 20090000 		.4byte	0x920
 5974 0930 0D       		.uleb128 0xd
 5975 0931 20090000 		.4byte	0x920
 5976 0935 02       		.uleb128 0x2
 5977 0936 FF060000 		.4byte	.LASF130
 5978 093a 02       		.byte	0x2
 5979 093b 39       		.byte	0x39
 5980 093c 82000000 		.4byte	0x82
 5981 0940 1F       		.uleb128 0x1f
 5982 0941 35090000 		.4byte	0x935
 5983 0945 02       		.uleb128 0x2
 5984 0946 380A0000 		.4byte	.LASF131
 5985 094a 02       		.byte	0x2
 5986 094b 3F       		.byte	0x3f
 5987 094c D4080000 		.4byte	0x8d4
 5988 0950 1F       		.uleb128 0x1f
 5989 0951 45090000 		.4byte	0x945
 5990 0955 0D       		.uleb128 0xd
 5991 0956 45090000 		.4byte	0x945
 5992 095a 0F       		.uleb128 0xf
ARM GAS  /tmp/cckqXCjj.s 			page 204


 5993 095b DC010000 		.4byte	.LASF132
 5994 095f 14       		.byte	0x14
 5995 0960 0B       		.byte	0xb
 5996 0961 8C       		.byte	0x8c
 5997 0962 A3090000 		.4byte	0x9a3
 5998 0966 0B       		.uleb128 0xb
 5999 0967 300B0000 		.4byte	.LASF133
 6000 096b 0B       		.byte	0xb
 6001 096c 8F       		.byte	0x8f
 6002 096d 45090000 		.4byte	0x945
 6003 0971 00       		.byte	0
 6004 0972 0B       		.uleb128 0xb
 6005 0973 19090000 		.4byte	.LASF134
 6006 0977 0B       		.byte	0xb
 6007 0978 90       		.byte	0x90
 6008 0979 A3090000 		.4byte	0x9a3
 6009 097d 04       		.byte	0x4
 6010 097e 0B       		.uleb128 0xb
 6011 097f BD040000 		.4byte	.LASF135
 6012 0983 0B       		.byte	0xb
 6013 0984 91       		.byte	0x91
 6014 0985 A3090000 		.4byte	0x9a3
 6015 0989 08       		.byte	0x8
 6016 098a 0B       		.uleb128 0xb
 6017 098b 6C0E0000 		.4byte	.LASF136
 6018 098f 0B       		.byte	0xb
 6019 0990 92       		.byte	0x92
 6020 0991 31010000 		.4byte	0x131
 6021 0995 0C       		.byte	0xc
 6022 0996 0B       		.uleb128 0xb
 6023 0997 C40A0000 		.4byte	.LASF137
 6024 099b 0B       		.byte	0xb
 6025 099c 93       		.byte	0x93
 6026 099d DA090000 		.4byte	0x9da
 6027 09a1 10       		.byte	0x10
 6028 09a2 00       		.byte	0
 6029 09a3 0E       		.uleb128 0xe
 6030 09a4 04       		.byte	0x4
 6031 09a5 5A090000 		.4byte	0x95a
 6032 09a9 0F       		.uleb128 0xf
 6033 09aa 89050000 		.4byte	.LASF138
 6034 09ae 14       		.byte	0x14
 6035 09af 0B       		.byte	0xb
 6036 09b0 A4       		.byte	0xa4
 6037 09b1 DA090000 		.4byte	0x9da
 6038 09b5 0B       		.uleb128 0xb
 6039 09b6 0B000000 		.4byte	.LASF139
 6040 09ba 0B       		.byte	0xb
 6041 09bb A7       		.byte	0xa7
 6042 09bc 40090000 		.4byte	0x940
 6043 09c0 00       		.byte	0
 6044 09c1 0B       		.uleb128 0xb
 6045 09c2 92010000 		.4byte	.LASF140
 6046 09c6 0B       		.byte	0xb
 6047 09c7 A8       		.byte	0xa8
 6048 09c8 270A0000 		.4byte	0xa27
 6049 09cc 04       		.byte	0x4
ARM GAS  /tmp/cckqXCjj.s 			page 205


 6050 09cd 0B       		.uleb128 0xb
 6051 09ce 3A070000 		.4byte	.LASF141
 6052 09d2 0B       		.byte	0xb
 6053 09d3 A9       		.byte	0xa9
 6054 09d4 1C0A0000 		.4byte	0xa1c
 6055 09d8 08       		.byte	0x8
 6056 09d9 00       		.byte	0
 6057 09da 0E       		.uleb128 0xe
 6058 09db 04       		.byte	0x4
 6059 09dc A9090000 		.4byte	0x9a9
 6060 09e0 02       		.uleb128 0x2
 6061 09e1 A8060000 		.4byte	.LASF142
 6062 09e5 0B       		.byte	0xb
 6063 09e6 96       		.byte	0x96
 6064 09e7 5A090000 		.4byte	0x95a
 6065 09eb 0F       		.uleb128 0xf
 6066 09ec 8F050000 		.4byte	.LASF143
 6067 09f0 0C       		.byte	0xc
 6068 09f1 0B       		.byte	0xb
 6069 09f2 98       		.byte	0x98
 6070 09f3 1C0A0000 		.4byte	0xa1c
 6071 09f7 0B       		.uleb128 0xb
 6072 09f8 300B0000 		.4byte	.LASF133
 6073 09fc 0B       		.byte	0xb
 6074 09fd 9B       		.byte	0x9b
 6075 09fe 45090000 		.4byte	0x945
 6076 0a02 00       		.byte	0
 6077 0a03 0B       		.uleb128 0xb
 6078 0a04 19090000 		.4byte	.LASF134
 6079 0a08 0B       		.byte	0xb
 6080 0a09 9C       		.byte	0x9c
 6081 0a0a A3090000 		.4byte	0x9a3
 6082 0a0e 04       		.byte	0x4
 6083 0a0f 0B       		.uleb128 0xb
 6084 0a10 BD040000 		.4byte	.LASF135
 6085 0a14 0B       		.byte	0xb
 6086 0a15 9D       		.byte	0x9d
 6087 0a16 A3090000 		.4byte	0x9a3
 6088 0a1a 08       		.byte	0x8
 6089 0a1b 00       		.byte	0
 6090 0a1c 02       		.uleb128 0x2
 6091 0a1d 5D070000 		.4byte	.LASF144
 6092 0a21 0B       		.byte	0xb
 6093 0a22 9F       		.byte	0x9f
 6094 0a23 EB090000 		.4byte	0x9eb
 6095 0a27 0E       		.uleb128 0xe
 6096 0a28 04       		.byte	0x4
 6097 0a29 E0090000 		.4byte	0x9e0
 6098 0a2d 02       		.uleb128 0x2
 6099 0a2e 1E0A0000 		.4byte	.LASF145
 6100 0a32 0B       		.byte	0xb
 6101 0a33 AB       		.byte	0xab
 6102 0a34 A9090000 		.4byte	0x9a9
 6103 0a38 0D       		.uleb128 0xd
 6104 0a39 2D0A0000 		.4byte	0xa2d
 6105 0a3d 02       		.uleb128 0x2
 6106 0a3e C6090000 		.4byte	.LASF146
ARM GAS  /tmp/cckqXCjj.s 			page 206


 6107 0a42 0C       		.byte	0xc
 6108 0a43 46       		.byte	0x46
 6109 0a44 4D0A0000 		.4byte	0xa4d
 6110 0a48 0D       		.uleb128 0xd
 6111 0a49 3D0A0000 		.4byte	0xa3d
 6112 0a4d 0E       		.uleb128 0xe
 6113 0a4e 04       		.byte	0x4
 6114 0a4f 530A0000 		.4byte	0xa53
 6115 0a53 0F       		.uleb128 0xf
 6116 0a54 B7000000 		.4byte	.LASF147
 6117 0a58 4C       		.byte	0x4c
 6118 0a59 01       		.byte	0x1
 6119 0a5a FC       		.byte	0xfc
 6120 0a5b C70A0000 		.4byte	0xac7
 6121 0a5f 0B       		.uleb128 0xb
 6122 0a60 BC0F0000 		.4byte	.LASF148
 6123 0a64 01       		.byte	0x1
 6124 0a65 FE       		.byte	0xfe
 6125 0a66 740B0000 		.4byte	0xb74
 6126 0a6a 00       		.byte	0
 6127 0a6b 17       		.uleb128 0x17
 6128 0a6c 7E0F0000 		.4byte	.LASF149
 6129 0a70 01       		.byte	0x1
 6130 0a71 0401     		.2byte	0x104
 6131 0a73 E0090000 		.4byte	0x9e0
 6132 0a77 04       		.byte	0x4
 6133 0a78 17       		.uleb128 0x17
 6134 0a79 2F0E0000 		.4byte	.LASF150
 6135 0a7d 01       		.byte	0x1
 6136 0a7e 0501     		.2byte	0x105
 6137 0a80 E0090000 		.4byte	0x9e0
 6138 0a84 18       		.byte	0x18
 6139 0a85 17       		.uleb128 0x17
 6140 0a86 92000000 		.4byte	.LASF151
 6141 0a8a 01       		.byte	0x1
 6142 0a8b 0601     		.2byte	0x106
 6143 0a8d 35090000 		.4byte	0x935
 6144 0a91 2C       		.byte	0x2c
 6145 0a92 17       		.uleb128 0x17
 6146 0a93 560B0000 		.4byte	.LASF152
 6147 0a97 01       		.byte	0x1
 6148 0a98 0701     		.2byte	0x107
 6149 0a9a 6E0B0000 		.4byte	0xb6e
 6150 0a9e 30       		.byte	0x30
 6151 0a9f 17       		.uleb128 0x17
 6152 0aa0 00000000 		.4byte	.LASF153
 6153 0aa4 01       		.byte	0x1
 6154 0aa5 0801     		.2byte	0x108
 6155 0aa7 7A0B0000 		.4byte	0xb7a
 6156 0aab 34       		.byte	0x34
 6157 0aac 17       		.uleb128 0x17
 6158 0aad 30060000 		.4byte	.LASF154
 6159 0ab1 01       		.byte	0x1
 6160 0ab2 3701     		.2byte	0x137
 6161 0ab4 DF080000 		.4byte	0x8df
 6162 0ab8 44       		.byte	0x44
 6163 0ab9 17       		.uleb128 0x17
ARM GAS  /tmp/cckqXCjj.s 			page 207


 6164 0aba 6E030000 		.4byte	.LASF155
 6165 0abe 01       		.byte	0x1
 6166 0abf 3801     		.2byte	0x138
 6167 0ac1 BF080000 		.4byte	0x8bf
 6168 0ac5 48       		.byte	0x48
 6169 0ac6 00       		.byte	0
 6170 0ac7 21       		.uleb128 0x21
 6171 0ac8 01       		.byte	0x1
 6172 0ac9 50000000 		.4byte	0x50
 6173 0acd 0C       		.byte	0xc
 6174 0ace 5B       		.byte	0x5b
 6175 0acf F20A0000 		.4byte	0xaf2
 6176 0ad3 22       		.uleb128 0x22
 6177 0ad4 2C010000 		.4byte	.LASF156
 6178 0ad8 00       		.byte	0
 6179 0ad9 22       		.uleb128 0x22
 6180 0ada 31070000 		.4byte	.LASF157
 6181 0ade 01       		.byte	0x1
 6182 0adf 22       		.uleb128 0x22
 6183 0ae0 42050000 		.4byte	.LASF158
 6184 0ae4 02       		.byte	0x2
 6185 0ae5 22       		.uleb128 0x22
 6186 0ae6 14040000 		.4byte	.LASF159
 6187 0aea 03       		.byte	0x3
 6188 0aeb 22       		.uleb128 0x22
 6189 0aec D5060000 		.4byte	.LASF160
 6190 0af0 04       		.byte	0x4
 6191 0af1 00       		.byte	0
 6192 0af2 02       		.uleb128 0x2
 6193 0af3 1D050000 		.4byte	.LASF161
 6194 0af7 0C       		.byte	0xc
 6195 0af8 61       		.byte	0x61
 6196 0af9 C70A0000 		.4byte	0xac7
 6197 0afd 0F       		.uleb128 0xf
 6198 0afe A6010000 		.4byte	.LASF162
 6199 0b02 08       		.byte	0x8
 6200 0b03 0C       		.byte	0xc
 6201 0b04 66       		.byte	0x66
 6202 0b05 220B0000 		.4byte	0xb22
 6203 0b09 0B       		.uleb128 0xb
 6204 0b0a A2020000 		.4byte	.LASF163
 6205 0b0e 0C       		.byte	0xc
 6206 0b0f 68       		.byte	0x68
 6207 0b10 20090000 		.4byte	0x920
 6208 0b14 00       		.byte	0
 6209 0b15 0B       		.uleb128 0xb
 6210 0b16 EC080000 		.4byte	.LASF164
 6211 0b1a 0C       		.byte	0xc
 6212 0b1b 69       		.byte	0x69
 6213 0b1c 45090000 		.4byte	0x945
 6214 0b20 04       		.byte	0x4
 6215 0b21 00       		.byte	0
 6216 0b22 02       		.uleb128 0x2
 6217 0b23 87090000 		.4byte	.LASF165
 6218 0b27 0C       		.byte	0xc
 6219 0b28 6A       		.byte	0x6a
 6220 0b29 FD0A0000 		.4byte	0xafd
ARM GAS  /tmp/cckqXCjj.s 			page 208


 6221 0b2d 0F       		.uleb128 0xf
 6222 0b2e 760A0000 		.4byte	.LASF166
 6223 0b32 0C       		.byte	0xc
 6224 0b33 0C       		.byte	0xc
 6225 0b34 6F       		.byte	0x6f
 6226 0b35 5E0B0000 		.4byte	0xb5e
 6227 0b39 0B       		.uleb128 0xb
 6228 0b3a A80D0000 		.4byte	.LASF167
 6229 0b3e 0C       		.byte	0xc
 6230 0b3f 71       		.byte	0x71
 6231 0b40 31010000 		.4byte	0x131
 6232 0b44 00       		.byte	0
 6233 0b45 0B       		.uleb128 0xb
 6234 0b46 AC0C0000 		.4byte	.LASF168
 6235 0b4a 0C       		.byte	0xc
 6236 0b4b 72       		.byte	0x72
 6237 0b4c D4080000 		.4byte	0x8d4
 6238 0b50 04       		.byte	0x4
 6239 0b51 0B       		.uleb128 0xb
 6240 0b52 00020000 		.4byte	.LASF169
 6241 0b56 0C       		.byte	0xc
 6242 0b57 73       		.byte	0x73
 6243 0b58 D4080000 		.4byte	0x8d4
 6244 0b5c 08       		.byte	0x8
 6245 0b5d 00       		.byte	0
 6246 0b5e 02       		.uleb128 0x2
 6247 0b5f C0070000 		.4byte	.LASF170
 6248 0b63 0C       		.byte	0xc
 6249 0b64 74       		.byte	0x74
 6250 0b65 2D0B0000 		.4byte	0xb2d
 6251 0b69 0D       		.uleb128 0xd
 6252 0b6a 5E0B0000 		.4byte	0xb5e
 6253 0b6e 0E       		.uleb128 0xe
 6254 0b6f 04       		.byte	0x4
 6255 0b70 10090000 		.4byte	0x910
 6256 0b74 0E       		.uleb128 0xe
 6257 0b75 04       		.byte	0x4
 6258 0b76 1B090000 		.4byte	0x91b
 6259 0b7a 08       		.uleb128 0x8
 6260 0b7b 3E010000 		.4byte	0x13e
 6261 0b7f 8A0B0000 		.4byte	0xb8a
 6262 0b83 09       		.uleb128 0x9
 6263 0b84 F3000000 		.4byte	0xf3
 6264 0b88 0F       		.byte	0xf
 6265 0b89 00       		.byte	0
 6266 0b8a 05       		.uleb128 0x5
 6267 0b8b 32050000 		.4byte	.LASF171
 6268 0b8f 01       		.byte	0x1
 6269 0b90 4901     		.2byte	0x149
 6270 0b92 530A0000 		.4byte	0xa53
 6271 0b96 05       		.uleb128 0x5
 6272 0b97 590E0000 		.4byte	.LASF172
 6273 0b9b 01       		.byte	0x1
 6274 0b9c 4D01     		.2byte	0x14d
 6275 0b9e 8A0B0000 		.4byte	0xb8a
 6276 0ba2 0D       		.uleb128 0xd
 6277 0ba3 960B0000 		.4byte	0xb96
ARM GAS  /tmp/cckqXCjj.s 			page 209


 6278 0ba7 23       		.uleb128 0x23
 6279 0ba8 D00A0000 		.4byte	.LASF173
 6280 0bac 01       		.byte	0x1
 6281 0bad 5101     		.2byte	0x151
 6282 0baf BF0B0000 		.4byte	0xbbf
 6283 0bb3 05       		.uleb128 0x5
 6284 0bb4 03       		.byte	0x3
 6285 0bb5 00000000 		.4byte	pxCurrentTCB
 6286 0bb9 0E       		.uleb128 0xe
 6287 0bba 04       		.byte	0x4
 6288 0bbb 960B0000 		.4byte	0xb96
 6289 0bbf 1F       		.uleb128 0x1f
 6290 0bc0 B90B0000 		.4byte	0xbb9
 6291 0bc4 0D       		.uleb128 0xd
 6292 0bc5 B90B0000 		.4byte	0xbb9
 6293 0bc9 08       		.uleb128 0x8
 6294 0bca 2D0A0000 		.4byte	0xa2d
 6295 0bce D90B0000 		.4byte	0xbd9
 6296 0bd2 09       		.uleb128 0x9
 6297 0bd3 F3000000 		.4byte	0xf3
 6298 0bd7 04       		.byte	0x4
 6299 0bd8 00       		.byte	0
 6300 0bd9 24       		.uleb128 0x24
 6301 0bda E7010000 		.4byte	.LASF174
 6302 0bde 01       		.byte	0x1
 6303 0bdf 5701     		.2byte	0x157
 6304 0be1 C90B0000 		.4byte	0xbc9
 6305 0be5 05       		.uleb128 0x5
 6306 0be6 03       		.byte	0x3
 6307 0be7 04000000 		.4byte	pxReadyTasksLists
 6308 0beb 24       		.uleb128 0x24
 6309 0bec 70020000 		.4byte	.LASF175
 6310 0bf0 01       		.byte	0x1
 6311 0bf1 5801     		.2byte	0x158
 6312 0bf3 2D0A0000 		.4byte	0xa2d
 6313 0bf7 05       		.uleb128 0x5
 6314 0bf8 03       		.byte	0x3
 6315 0bf9 68000000 		.4byte	xDelayedTaskList1
 6316 0bfd 24       		.uleb128 0x24
 6317 0bfe 82020000 		.4byte	.LASF176
 6318 0c02 01       		.byte	0x1
 6319 0c03 5901     		.2byte	0x159
 6320 0c05 2D0A0000 		.4byte	0xa2d
 6321 0c09 05       		.uleb128 0x5
 6322 0c0a 03       		.byte	0x3
 6323 0c0b 7C000000 		.4byte	xDelayedTaskList2
 6324 0c0f 24       		.uleb128 0x24
 6325 0c10 840B0000 		.4byte	.LASF177
 6326 0c14 01       		.byte	0x1
 6327 0c15 5A01     		.2byte	0x15a
 6328 0c17 270C0000 		.4byte	0xc27
 6329 0c1b 05       		.uleb128 0x5
 6330 0c1c 03       		.byte	0x3
 6331 0c1d 90000000 		.4byte	pxDelayedTaskList
 6332 0c21 0E       		.uleb128 0xe
 6333 0c22 04       		.byte	0x4
 6334 0c23 2D0A0000 		.4byte	0xa2d
ARM GAS  /tmp/cckqXCjj.s 			page 210


 6335 0c27 1F       		.uleb128 0x1f
 6336 0c28 210C0000 		.4byte	0xc21
 6337 0c2c 0D       		.uleb128 0xd
 6338 0c2d 210C0000 		.4byte	0xc21
 6339 0c31 24       		.uleb128 0x24
 6340 0c32 E0050000 		.4byte	.LASF178
 6341 0c36 01       		.byte	0x1
 6342 0c37 5B01     		.2byte	0x15b
 6343 0c39 270C0000 		.4byte	0xc27
 6344 0c3d 05       		.uleb128 0x5
 6345 0c3e 03       		.byte	0x3
 6346 0c3f 94000000 		.4byte	pxOverflowDelayedTaskList
 6347 0c43 24       		.uleb128 0x24
 6348 0c44 94040000 		.4byte	.LASF179
 6349 0c48 01       		.byte	0x1
 6350 0c49 5C01     		.2byte	0x15c
 6351 0c4b 2D0A0000 		.4byte	0xa2d
 6352 0c4f 05       		.uleb128 0x5
 6353 0c50 03       		.byte	0x3
 6354 0c51 98000000 		.4byte	xPendingReadyList
 6355 0c55 24       		.uleb128 0x24
 6356 0c56 C8040000 		.4byte	.LASF180
 6357 0c5a 01       		.byte	0x1
 6358 0c5b 6001     		.2byte	0x160
 6359 0c5d 2D0A0000 		.4byte	0xa2d
 6360 0c61 05       		.uleb128 0x5
 6361 0c62 03       		.byte	0x3
 6362 0c63 AC000000 		.4byte	xTasksWaitingTermination
 6363 0c67 24       		.uleb128 0x24
 6364 0c68 61050000 		.4byte	.LASF181
 6365 0c6c 01       		.byte	0x1
 6366 0c6d 6101     		.2byte	0x161
 6367 0c6f 40090000 		.4byte	0x940
 6368 0c73 05       		.uleb128 0x5
 6369 0c74 03       		.byte	0x3
 6370 0c75 C0000000 		.4byte	uxDeletedTasksWaitingCleanUp
 6371 0c79 24       		.uleb128 0x24
 6372 0c7a C6050000 		.4byte	.LASF182
 6373 0c7e 01       		.byte	0x1
 6374 0c7f 6701     		.2byte	0x167
 6375 0c81 2D0A0000 		.4byte	0xa2d
 6376 0c85 05       		.uleb128 0x5
 6377 0c86 03       		.byte	0x3
 6378 0c87 C4000000 		.4byte	xSuspendedTaskList
 6379 0c8b 24       		.uleb128 0x24
 6380 0c8c 130F0000 		.4byte	.LASF183
 6381 0c90 01       		.byte	0x1
 6382 0c91 7201     		.2byte	0x172
 6383 0c93 40090000 		.4byte	0x940
 6384 0c97 05       		.uleb128 0x5
 6385 0c98 03       		.byte	0x3
 6386 0c99 D8000000 		.4byte	uxCurrentNumberOfTasks
 6387 0c9d 24       		.uleb128 0x24
 6388 0c9e 7E050000 		.4byte	.LASF184
 6389 0ca2 01       		.byte	0x1
 6390 0ca3 7301     		.2byte	0x173
 6391 0ca5 50090000 		.4byte	0x950
ARM GAS  /tmp/cckqXCjj.s 			page 211


 6392 0ca9 05       		.uleb128 0x5
 6393 0caa 03       		.byte	0x3
 6394 0cab DC000000 		.4byte	xTickCount
 6395 0caf 24       		.uleb128 0x24
 6396 0cb0 36010000 		.4byte	.LASF185
 6397 0cb4 01       		.byte	0x1
 6398 0cb5 7401     		.2byte	0x174
 6399 0cb7 40090000 		.4byte	0x940
 6400 0cbb 05       		.uleb128 0x5
 6401 0cbc 03       		.byte	0x3
 6402 0cbd E0000000 		.4byte	uxTopReadyPriority
 6403 0cc1 24       		.uleb128 0x24
 6404 0cc2 80010000 		.4byte	.LASF186
 6405 0cc6 01       		.byte	0x1
 6406 0cc7 7501     		.2byte	0x175
 6407 0cc9 2B090000 		.4byte	0x92b
 6408 0ccd 05       		.uleb128 0x5
 6409 0cce 03       		.byte	0x3
 6410 0ccf E4000000 		.4byte	xSchedulerRunning
 6411 0cd3 24       		.uleb128 0x24
 6412 0cd4 A50E0000 		.4byte	.LASF187
 6413 0cd8 01       		.byte	0x1
 6414 0cd9 7601     		.2byte	0x176
 6415 0cdb 50090000 		.4byte	0x950
 6416 0cdf 05       		.uleb128 0x5
 6417 0ce0 03       		.byte	0x3
 6418 0ce1 E8000000 		.4byte	xPendedTicks
 6419 0ce5 24       		.uleb128 0x24
 6420 0ce6 69100000 		.4byte	.LASF188
 6421 0cea 01       		.byte	0x1
 6422 0ceb 7701     		.2byte	0x177
 6423 0ced 2B090000 		.4byte	0x92b
 6424 0cf1 05       		.uleb128 0x5
 6425 0cf2 03       		.byte	0x3
 6426 0cf3 EC000000 		.4byte	xYieldPending
 6427 0cf7 24       		.uleb128 0x24
 6428 0cf8 B40A0000 		.4byte	.LASF189
 6429 0cfc 01       		.byte	0x1
 6430 0cfd 7801     		.2byte	0x178
 6431 0cff 2B090000 		.4byte	0x92b
 6432 0d03 05       		.uleb128 0x5
 6433 0d04 03       		.byte	0x3
 6434 0d05 F0000000 		.4byte	xNumOfOverflows
 6435 0d09 24       		.uleb128 0x24
 6436 0d0a B9090000 		.4byte	.LASF190
 6437 0d0e 01       		.byte	0x1
 6438 0d0f 7901     		.2byte	0x179
 6439 0d11 35090000 		.4byte	0x935
 6440 0d15 05       		.uleb128 0x5
 6441 0d16 03       		.byte	0x3
 6442 0d17 F4000000 		.4byte	uxTaskNumber
 6443 0d1b 24       		.uleb128 0x24
 6444 0d1c CF070000 		.4byte	.LASF191
 6445 0d20 01       		.byte	0x1
 6446 0d21 7A01     		.2byte	0x17a
 6447 0d23 50090000 		.4byte	0x950
 6448 0d27 05       		.uleb128 0x5
ARM GAS  /tmp/cckqXCjj.s 			page 212


 6449 0d28 03       		.byte	0x3
 6450 0d29 F8000000 		.4byte	xNextTaskUnblockTime
 6451 0d2d 24       		.uleb128 0x24
 6452 0d2e 9C0C0000 		.4byte	.LASF192
 6453 0d32 01       		.byte	0x1
 6454 0d33 7B01     		.2byte	0x17b
 6455 0d35 3D0A0000 		.4byte	0xa3d
 6456 0d39 05       		.uleb128 0x5
 6457 0d3a 03       		.byte	0x3
 6458 0d3b FC000000 		.4byte	xIdleTaskHandle
 6459 0d3f 24       		.uleb128 0x24
 6460 0d40 BF030000 		.4byte	.LASF193
 6461 0d44 01       		.byte	0x1
 6462 0d45 8501     		.2byte	0x185
 6463 0d47 40090000 		.4byte	0x940
 6464 0d4b 05       		.uleb128 0x5
 6465 0d4c 03       		.byte	0x3
 6466 0d4d 00010000 		.4byte	uxSchedulerSuspended
 6467 0d51 25       		.uleb128 0x25
 6468 0d52 D10E0000 		.4byte	.LASF223
 6469 0d56 01       		.byte	0x1
 6470 0d57 3914     		.2byte	0x1439
 6471 0d59 50160000 		.4byte	.LFB51
 6472 0d5d CC000000 		.4byte	.LFE51-.LFB51
 6473 0d61 01       		.uleb128 0x1
 6474 0d62 9C       		.byte	0x9c
 6475 0d63 A40D0000 		.4byte	0xda4
 6476 0d67 26       		.uleb128 0x26
 6477 0d68 5F0E0000 		.4byte	.LASF194
 6478 0d6c 01       		.byte	0x1
 6479 0d6d 3914     		.2byte	0x1439
 6480 0d6f 45090000 		.4byte	0x945
 6481 0d73 02       		.uleb128 0x2
 6482 0d74 91       		.byte	0x91
 6483 0d75 6C       		.sleb128 -20
 6484 0d76 26       		.uleb128 0x26
 6485 0d77 920D0000 		.4byte	.LASF195
 6486 0d7b 01       		.byte	0x1
 6487 0d7c 3914     		.2byte	0x1439
 6488 0d7e 30090000 		.4byte	0x930
 6489 0d82 02       		.uleb128 0x2
 6490 0d83 91       		.byte	0x91
 6491 0d84 68       		.sleb128 -24
 6492 0d85 24       		.uleb128 0x24
 6493 0d86 FE020000 		.4byte	.LASF196
 6494 0d8a 01       		.byte	0x1
 6495 0d8b 3B14     		.2byte	0x143b
 6496 0d8d 45090000 		.4byte	0x945
 6497 0d91 02       		.uleb128 0x2
 6498 0d92 91       		.byte	0x91
 6499 0d93 70       		.sleb128 -16
 6500 0d94 24       		.uleb128 0x24
 6501 0d95 A5050000 		.4byte	.LASF197
 6502 0d99 01       		.byte	0x1
 6503 0d9a 3C14     		.2byte	0x143c
 6504 0d9c 55090000 		.4byte	0x955
 6505 0da0 02       		.uleb128 0x2
ARM GAS  /tmp/cckqXCjj.s 			page 213


 6506 0da1 91       		.byte	0x91
 6507 0da2 74       		.sleb128 -12
 6508 0da3 00       		.byte	0
 6509 0da4 27       		.uleb128 0x27
 6510 0da5 4D0F0000 		.4byte	.LASF202
 6511 0da9 01       		.byte	0x1
 6512 0daa 1714     		.2byte	0x1417
 6513 0dac D4080000 		.4byte	0x8d4
 6514 0db0 08160000 		.4byte	.LFB50
 6515 0db4 48000000 		.4byte	.LFE50-.LFB50
 6516 0db8 01       		.uleb128 0x1
 6517 0db9 9C       		.byte	0x9c
 6518 0dba FB0D0000 		.4byte	0xdfb
 6519 0dbe 26       		.uleb128 0x26
 6520 0dbf 510A0000 		.4byte	.LASF198
 6521 0dc3 01       		.byte	0x1
 6522 0dc4 1714     		.2byte	0x1417
 6523 0dc6 3D0A0000 		.4byte	0xa3d
 6524 0dca 02       		.uleb128 0x2
 6525 0dcb 91       		.byte	0x91
 6526 0dcc 6C       		.sleb128 -20
 6527 0dcd 26       		.uleb128 0x26
 6528 0dce B0010000 		.4byte	.LASF199
 6529 0dd2 01       		.byte	0x1
 6530 0dd3 1714     		.2byte	0x1417
 6531 0dd5 D4080000 		.4byte	0x8d4
 6532 0dd9 02       		.uleb128 0x2
 6533 0dda 91       		.byte	0x91
 6534 0ddb 68       		.sleb128 -24
 6535 0ddc 24       		.uleb128 0x24
 6536 0ddd 8D0F0000 		.4byte	.LASF200
 6537 0de1 01       		.byte	0x1
 6538 0de2 1914     		.2byte	0x1419
 6539 0de4 B90B0000 		.4byte	0xbb9
 6540 0de8 02       		.uleb128 0x2
 6541 0de9 91       		.byte	0x91
 6542 0dea 74       		.sleb128 -12
 6543 0deb 24       		.uleb128 0x24
 6544 0dec 57080000 		.4byte	.LASF201
 6545 0df0 01       		.byte	0x1
 6546 0df1 1A14     		.2byte	0x141a
 6547 0df3 D4080000 		.4byte	0x8d4
 6548 0df7 02       		.uleb128 0x2
 6549 0df8 91       		.byte	0x91
 6550 0df9 70       		.sleb128 -16
 6551 0dfa 00       		.byte	0
 6552 0dfb 27       		.uleb128 0x27
 6553 0dfc 02060000 		.4byte	.LASF203
 6554 0e00 01       		.byte	0x1
 6555 0e01 F813     		.2byte	0x13f8
 6556 0e03 20090000 		.4byte	0x920
 6557 0e07 BC150000 		.4byte	.LFB49
 6558 0e0b 4C000000 		.4byte	.LFE49-.LFB49
 6559 0e0f 01       		.uleb128 0x1
 6560 0e10 9C       		.byte	0x9c
 6561 0e11 430E0000 		.4byte	0xe43
 6562 0e15 26       		.uleb128 0x26
ARM GAS  /tmp/cckqXCjj.s 			page 214


 6563 0e16 510A0000 		.4byte	.LASF198
 6564 0e1a 01       		.byte	0x1
 6565 0e1b F813     		.2byte	0x13f8
 6566 0e1d 3D0A0000 		.4byte	0xa3d
 6567 0e21 02       		.uleb128 0x2
 6568 0e22 91       		.byte	0x91
 6569 0e23 6C       		.sleb128 -20
 6570 0e24 24       		.uleb128 0x24
 6571 0e25 8D0F0000 		.4byte	.LASF200
 6572 0e29 01       		.byte	0x1
 6573 0e2a FA13     		.2byte	0x13fa
 6574 0e2c B90B0000 		.4byte	0xbb9
 6575 0e30 02       		.uleb128 0x2
 6576 0e31 91       		.byte	0x91
 6577 0e32 70       		.sleb128 -16
 6578 0e33 24       		.uleb128 0x24
 6579 0e34 FA050000 		.4byte	.LASF204
 6580 0e38 01       		.byte	0x1
 6581 0e39 FB13     		.2byte	0x13fb
 6582 0e3b 20090000 		.4byte	0x920
 6583 0e3f 02       		.uleb128 0x2
 6584 0e40 91       		.byte	0x91
 6585 0e41 74       		.sleb128 -12
 6586 0e42 00       		.byte	0
 6587 0e43 28       		.uleb128 0x28
 6588 0e44 6D0B0000 		.4byte	.LASF234
 6589 0e48 01       		.byte	0x1
 6590 0e49 A213     		.2byte	0x13a2
 6591 0e4b D8140000 		.4byte	.LFB48
 6592 0e4f E4000000 		.4byte	.LFE48-.LFB48
 6593 0e53 01       		.uleb128 0x1
 6594 0e54 9C       		.byte	0x9c
 6595 0e55 ED0E0000 		.4byte	0xeed
 6596 0e59 26       		.uleb128 0x26
 6597 0e5a 430A0000 		.4byte	.LASF205
 6598 0e5e 01       		.byte	0x1
 6599 0e5f A213     		.2byte	0x13a2
 6600 0e61 3D0A0000 		.4byte	0xa3d
 6601 0e65 02       		.uleb128 0x2
 6602 0e66 91       		.byte	0x91
 6603 0e67 5C       		.sleb128 -36
 6604 0e68 26       		.uleb128 0x26
 6605 0e69 12010000 		.4byte	.LASF206
 6606 0e6d 01       		.byte	0x1
 6607 0e6e A213     		.2byte	0x13a2
 6608 0e70 ED0E0000 		.4byte	0xeed
 6609 0e74 02       		.uleb128 0x2
 6610 0e75 91       		.byte	0x91
 6611 0e76 58       		.sleb128 -40
 6612 0e77 24       		.uleb128 0x24
 6613 0e78 8D0F0000 		.4byte	.LASF200
 6614 0e7c 01       		.byte	0x1
 6615 0e7d A413     		.2byte	0x13a4
 6616 0e7f B90B0000 		.4byte	0xbb9
 6617 0e83 02       		.uleb128 0x2
 6618 0e84 91       		.byte	0x91
 6619 0e85 74       		.sleb128 -12
ARM GAS  /tmp/cckqXCjj.s 			page 215


 6620 0e86 24       		.uleb128 0x24
 6621 0e87 600A0000 		.4byte	.LASF207
 6622 0e8b 01       		.byte	0x1
 6623 0e8c A513     		.2byte	0x13a5
 6624 0e8e B4080000 		.4byte	0x8b4
 6625 0e92 02       		.uleb128 0x2
 6626 0e93 91       		.byte	0x91
 6627 0e94 6F       		.sleb128 -17
 6628 0e95 24       		.uleb128 0x24
 6629 0e96 2D030000 		.4byte	.LASF208
 6630 0e9a 01       		.byte	0x1
 6631 0e9b A613     		.2byte	0x13a6
 6632 0e9d 35090000 		.4byte	0x935
 6633 0ea1 02       		.uleb128 0x2
 6634 0ea2 91       		.byte	0x91
 6635 0ea3 70       		.sleb128 -16
 6636 0ea4 29       		.uleb128 0x29
 6637 0ea5 2D1C0000 		.4byte	0x1c2d
 6638 0ea9 E6140000 		.4byte	.LBB53
 6639 0ead 1A000000 		.4byte	.LBE53-.LBB53
 6640 0eb1 01       		.byte	0x1
 6641 0eb2 BE13     		.2byte	0x13be
 6642 0eb4 D30E0000 		.4byte	0xed3
 6643 0eb8 2A       		.uleb128 0x2a
 6644 0eb9 E6140000 		.4byte	.LBB54
 6645 0ebd 1A000000 		.4byte	.LBE54-.LBB54
 6646 0ec1 2B       		.uleb128 0x2b
 6647 0ec2 3D1C0000 		.4byte	0x1c3d
 6648 0ec6 02       		.uleb128 0x2
 6649 0ec7 91       		.byte	0x91
 6650 0ec8 68       		.sleb128 -24
 6651 0ec9 2B       		.uleb128 0x2b
 6652 0eca 481C0000 		.4byte	0x1c48
 6653 0ece 02       		.uleb128 0x2
 6654 0ecf 91       		.byte	0x91
 6655 0ed0 64       		.sleb128 -28
 6656 0ed1 00       		.byte	0
 6657 0ed2 00       		.byte	0
 6658 0ed3 2C       		.uleb128 0x2c
 6659 0ed4 151C0000 		.4byte	0x1c15
 6660 0ed8 94150000 		.4byte	.LBB55
 6661 0edc 06000000 		.4byte	.LBE55-.LBB55
 6662 0ee0 01       		.byte	0x1
 6663 0ee1 F013     		.2byte	0x13f0
 6664 0ee3 2D       		.uleb128 0x2d
 6665 0ee4 211C0000 		.4byte	0x1c21
 6666 0ee8 02       		.uleb128 0x2
 6667 0ee9 91       		.byte	0x91
 6668 0eea 60       		.sleb128 -32
 6669 0eeb 00       		.byte	0
 6670 0eec 00       		.byte	0
 6671 0eed 0E       		.uleb128 0xe
 6672 0eee 04       		.byte	0x4
 6673 0eef 20090000 		.4byte	0x920
 6674 0ef3 27       		.uleb128 0x27
 6675 0ef4 22020000 		.4byte	.LASF209
 6676 0ef8 01       		.byte	0x1
ARM GAS  /tmp/cckqXCjj.s 			page 216


 6677 0ef9 2113     		.2byte	0x1321
 6678 0efb 20090000 		.4byte	0x920
 6679 0eff 88130000 		.4byte	.LFB47
 6680 0f03 50010000 		.4byte	.LFE47-.LFB47
 6681 0f07 01       		.uleb128 0x1
 6682 0f08 9C       		.byte	0x9c
 6683 0f09 DD0F0000 		.4byte	0xfdd
 6684 0f0d 26       		.uleb128 0x26
 6685 0f0e 430A0000 		.4byte	.LASF205
 6686 0f12 01       		.byte	0x1
 6687 0f13 2113     		.2byte	0x1321
 6688 0f15 3D0A0000 		.4byte	0xa3d
 6689 0f19 02       		.uleb128 0x2
 6690 0f1a 91       		.byte	0x91
 6691 0f1b 54       		.sleb128 -44
 6692 0f1c 26       		.uleb128 0x26
 6693 0f1d 0B0C0000 		.4byte	.LASF210
 6694 0f21 01       		.byte	0x1
 6695 0f22 2113     		.2byte	0x1321
 6696 0f24 D4080000 		.4byte	0x8d4
 6697 0f28 02       		.uleb128 0x2
 6698 0f29 91       		.byte	0x91
 6699 0f2a 50       		.sleb128 -48
 6700 0f2b 26       		.uleb128 0x26
 6701 0f2c D3090000 		.4byte	.LASF211
 6702 0f30 01       		.byte	0x1
 6703 0f31 2113     		.2byte	0x1321
 6704 0f33 F20A0000 		.4byte	0xaf2
 6705 0f37 02       		.uleb128 0x2
 6706 0f38 91       		.byte	0x91
 6707 0f39 4F       		.sleb128 -49
 6708 0f3a 26       		.uleb128 0x26
 6709 0f3b 20090000 		.4byte	.LASF212
 6710 0f3f 01       		.byte	0x1
 6711 0f40 2113     		.2byte	0x1321
 6712 0f42 DD0F0000 		.4byte	0xfdd
 6713 0f46 02       		.uleb128 0x2
 6714 0f47 91       		.byte	0x91
 6715 0f48 48       		.sleb128 -56
 6716 0f49 26       		.uleb128 0x26
 6717 0f4a 12010000 		.4byte	.LASF206
 6718 0f4e 01       		.byte	0x1
 6719 0f4f 2113     		.2byte	0x1321
 6720 0f51 ED0E0000 		.4byte	0xeed
 6721 0f55 02       		.uleb128 0x2
 6722 0f56 91       		.byte	0x91
 6723 0f57 00       		.sleb128 0
 6724 0f58 24       		.uleb128 0x24
 6725 0f59 8D0F0000 		.4byte	.LASF200
 6726 0f5d 01       		.byte	0x1
 6727 0f5e 2313     		.2byte	0x1323
 6728 0f60 B90B0000 		.4byte	0xbb9
 6729 0f64 02       		.uleb128 0x2
 6730 0f65 91       		.byte	0x91
 6731 0f66 70       		.sleb128 -16
 6732 0f67 24       		.uleb128 0x24
 6733 0f68 600A0000 		.4byte	.LASF207
ARM GAS  /tmp/cckqXCjj.s 			page 217


 6734 0f6c 01       		.byte	0x1
 6735 0f6d 2413     		.2byte	0x1324
 6736 0f6f B4080000 		.4byte	0x8b4
 6737 0f73 02       		.uleb128 0x2
 6738 0f74 91       		.byte	0x91
 6739 0f75 6B       		.sleb128 -21
 6740 0f76 24       		.uleb128 0x24
 6741 0f77 FA050000 		.4byte	.LASF204
 6742 0f7b 01       		.byte	0x1
 6743 0f7c 2513     		.2byte	0x1325
 6744 0f7e 20090000 		.4byte	0x920
 6745 0f82 02       		.uleb128 0x2
 6746 0f83 91       		.byte	0x91
 6747 0f84 74       		.sleb128 -12
 6748 0f85 24       		.uleb128 0x24
 6749 0f86 2D030000 		.4byte	.LASF208
 6750 0f8a 01       		.byte	0x1
 6751 0f8b 2613     		.2byte	0x1326
 6752 0f8d 35090000 		.4byte	0x935
 6753 0f91 02       		.uleb128 0x2
 6754 0f92 91       		.byte	0x91
 6755 0f93 6C       		.sleb128 -20
 6756 0f94 29       		.uleb128 0x29
 6757 0f95 2D1C0000 		.4byte	0x1c2d
 6758 0f99 A0130000 		.4byte	.LBB49
 6759 0f9d 1A000000 		.4byte	.LBE49-.LBB49
 6760 0fa1 01       		.byte	0x1
 6761 0fa2 3E13     		.2byte	0x133e
 6762 0fa4 C30F0000 		.4byte	0xfc3
 6763 0fa8 2A       		.uleb128 0x2a
 6764 0fa9 A0130000 		.4byte	.LBB50
 6765 0fad 1A000000 		.4byte	.LBE50-.LBB50
 6766 0fb1 2B       		.uleb128 0x2b
 6767 0fb2 3D1C0000 		.4byte	0x1c3d
 6768 0fb6 02       		.uleb128 0x2
 6769 0fb7 91       		.byte	0x91
 6770 0fb8 64       		.sleb128 -28
 6771 0fb9 2B       		.uleb128 0x2b
 6772 0fba 481C0000 		.4byte	0x1c48
 6773 0fbe 02       		.uleb128 0x2
 6774 0fbf 91       		.byte	0x91
 6775 0fc0 60       		.sleb128 -32
 6776 0fc1 00       		.byte	0
 6777 0fc2 00       		.byte	0
 6778 0fc3 2C       		.uleb128 0x2c
 6779 0fc4 151C0000 		.4byte	0x1c15
 6780 0fc8 B0140000 		.4byte	.LBB51
 6781 0fcc 06000000 		.4byte	.LBE51-.LBB51
 6782 0fd0 01       		.byte	0x1
 6783 0fd1 9813     		.2byte	0x1398
 6784 0fd3 2D       		.uleb128 0x2d
 6785 0fd4 211C0000 		.4byte	0x1c21
 6786 0fd8 02       		.uleb128 0x2
 6787 0fd9 91       		.byte	0x91
 6788 0fda 5C       		.sleb128 -36
 6789 0fdb 00       		.byte	0
 6790 0fdc 00       		.byte	0
ARM GAS  /tmp/cckqXCjj.s 			page 218


 6791 0fdd 0E       		.uleb128 0xe
 6792 0fde 04       		.byte	0x4
 6793 0fdf D4080000 		.4byte	0x8d4
 6794 0fe3 27       		.uleb128 0x27
 6795 0fe4 AC030000 		.4byte	.LASF213
 6796 0fe8 01       		.byte	0x1
 6797 0fe9 AF12     		.2byte	0x12af
 6798 0feb 20090000 		.4byte	0x920
 6799 0fef 78120000 		.4byte	.LFB46
 6800 0ff3 10010000 		.4byte	.LFE46-.LFB46
 6801 0ff7 01       		.uleb128 0x1
 6802 0ff8 9C       		.byte	0x9c
 6803 0ff9 67100000 		.4byte	0x1067
 6804 0ffd 26       		.uleb128 0x26
 6805 0ffe 430A0000 		.4byte	.LASF205
 6806 1002 01       		.byte	0x1
 6807 1003 AF12     		.2byte	0x12af
 6808 1005 3D0A0000 		.4byte	0xa3d
 6809 1009 02       		.uleb128 0x2
 6810 100a 91       		.byte	0x91
 6811 100b 64       		.sleb128 -28
 6812 100c 26       		.uleb128 0x26
 6813 100d 0B0C0000 		.4byte	.LASF210
 6814 1011 01       		.byte	0x1
 6815 1012 AF12     		.2byte	0x12af
 6816 1014 D4080000 		.4byte	0x8d4
 6817 1018 02       		.uleb128 0x2
 6818 1019 91       		.byte	0x91
 6819 101a 60       		.sleb128 -32
 6820 101b 26       		.uleb128 0x26
 6821 101c D3090000 		.4byte	.LASF211
 6822 1020 01       		.byte	0x1
 6823 1021 AF12     		.2byte	0x12af
 6824 1023 F20A0000 		.4byte	0xaf2
 6825 1027 02       		.uleb128 0x2
 6826 1028 91       		.byte	0x91
 6827 1029 5F       		.sleb128 -33
 6828 102a 26       		.uleb128 0x26
 6829 102b 20090000 		.4byte	.LASF212
 6830 102f 01       		.byte	0x1
 6831 1030 AF12     		.2byte	0x12af
 6832 1032 DD0F0000 		.4byte	0xfdd
 6833 1036 02       		.uleb128 0x2
 6834 1037 91       		.byte	0x91
 6835 1038 58       		.sleb128 -40
 6836 1039 24       		.uleb128 0x24
 6837 103a 8D0F0000 		.4byte	.LASF200
 6838 103e 01       		.byte	0x1
 6839 103f B112     		.2byte	0x12b1
 6840 1041 B90B0000 		.4byte	0xbb9
 6841 1045 02       		.uleb128 0x2
 6842 1046 91       		.byte	0x91
 6843 1047 70       		.sleb128 -16
 6844 1048 24       		.uleb128 0x24
 6845 1049 FA050000 		.4byte	.LASF204
 6846 104d 01       		.byte	0x1
 6847 104e B212     		.2byte	0x12b2
ARM GAS  /tmp/cckqXCjj.s 			page 219


 6848 1050 20090000 		.4byte	0x920
 6849 1054 02       		.uleb128 0x2
 6850 1055 91       		.byte	0x91
 6851 1056 74       		.sleb128 -12
 6852 1057 24       		.uleb128 0x24
 6853 1058 600A0000 		.4byte	.LASF207
 6854 105c 01       		.byte	0x1
 6855 105d B312     		.2byte	0x12b3
 6856 105f B4080000 		.4byte	0x8b4
 6857 1063 02       		.uleb128 0x2
 6858 1064 91       		.byte	0x91
 6859 1065 6F       		.sleb128 -17
 6860 1066 00       		.byte	0
 6861 1067 27       		.uleb128 0x27
 6862 1068 EF060000 		.4byte	.LASF214
 6863 106c 01       		.byte	0x1
 6864 106d 5F12     		.2byte	0x125f
 6865 106f 20090000 		.4byte	0x920
 6866 1073 C4110000 		.4byte	.LFB45
 6867 1077 B4000000 		.4byte	.LFE45-.LFB45
 6868 107b 01       		.uleb128 0x1
 6869 107c 9C       		.byte	0x9c
 6870 107d CD100000 		.4byte	0x10cd
 6871 1081 26       		.uleb128 0x26
 6872 1082 72040000 		.4byte	.LASF215
 6873 1086 01       		.byte	0x1
 6874 1087 5F12     		.2byte	0x125f
 6875 1089 D4080000 		.4byte	0x8d4
 6876 108d 02       		.uleb128 0x2
 6877 108e 91       		.byte	0x91
 6878 108f 6C       		.sleb128 -20
 6879 1090 26       		.uleb128 0x26
 6880 1091 CB000000 		.4byte	.LASF216
 6881 1095 01       		.byte	0x1
 6882 1096 5F12     		.2byte	0x125f
 6883 1098 D4080000 		.4byte	0x8d4
 6884 109c 02       		.uleb128 0x2
 6885 109d 91       		.byte	0x91
 6886 109e 68       		.sleb128 -24
 6887 109f 26       		.uleb128 0x26
 6888 10a0 CF0C0000 		.4byte	.LASF217
 6889 10a4 01       		.byte	0x1
 6890 10a5 5F12     		.2byte	0x125f
 6891 10a7 DD0F0000 		.4byte	0xfdd
 6892 10ab 02       		.uleb128 0x2
 6893 10ac 91       		.byte	0x91
 6894 10ad 64       		.sleb128 -28
 6895 10ae 26       		.uleb128 0x26
 6896 10af 5F0E0000 		.4byte	.LASF194
 6897 10b3 01       		.byte	0x1
 6898 10b4 5F12     		.2byte	0x125f
 6899 10b6 45090000 		.4byte	0x945
 6900 10ba 02       		.uleb128 0x2
 6901 10bb 91       		.byte	0x91
 6902 10bc 60       		.sleb128 -32
 6903 10bd 24       		.uleb128 0x24
 6904 10be FA050000 		.4byte	.LASF204
ARM GAS  /tmp/cckqXCjj.s 			page 220


 6905 10c2 01       		.byte	0x1
 6906 10c3 6112     		.2byte	0x1261
 6907 10c5 20090000 		.4byte	0x920
 6908 10c9 02       		.uleb128 0x2
 6909 10ca 91       		.byte	0x91
 6910 10cb 74       		.sleb128 -12
 6911 10cc 00       		.byte	0
 6912 10cd 27       		.uleb128 0x27
 6913 10ce 43070000 		.4byte	.LASF218
 6914 10d2 01       		.byte	0x1
 6915 10d3 1B12     		.2byte	0x121b
 6916 10d5 D4080000 		.4byte	0x8d4
 6917 10d9 34110000 		.4byte	.LFB44
 6918 10dd 90000000 		.4byte	.LFE44-.LFB44
 6919 10e1 01       		.uleb128 0x1
 6920 10e2 9C       		.byte	0x9c
 6921 10e3 15110000 		.4byte	0x1115
 6922 10e7 26       		.uleb128 0x26
 6923 10e8 440B0000 		.4byte	.LASF219
 6924 10ec 01       		.byte	0x1
 6925 10ed 1B12     		.2byte	0x121b
 6926 10ef 20090000 		.4byte	0x920
 6927 10f3 02       		.uleb128 0x2
 6928 10f4 91       		.byte	0x91
 6929 10f5 6C       		.sleb128 -20
 6930 10f6 26       		.uleb128 0x26
 6931 10f7 5F0E0000 		.4byte	.LASF194
 6932 10fb 01       		.byte	0x1
 6933 10fc 1B12     		.2byte	0x121b
 6934 10fe 45090000 		.4byte	0x945
 6935 1102 02       		.uleb128 0x2
 6936 1103 91       		.byte	0x91
 6937 1104 68       		.sleb128 -24
 6938 1105 24       		.uleb128 0x24
 6939 1106 57080000 		.4byte	.LASF201
 6940 110a 01       		.byte	0x1
 6941 110b 1D12     		.2byte	0x121d
 6942 110d D4080000 		.4byte	0x8d4
 6943 1111 02       		.uleb128 0x2
 6944 1112 91       		.byte	0x91
 6945 1113 74       		.sleb128 -12
 6946 1114 00       		.byte	0
 6947 1115 2E       		.uleb128 0x2e
 6948 1116 EA090000 		.4byte	.LASF220
 6949 111a 01       		.byte	0x1
 6950 111b FA11     		.2byte	0x11fa
 6951 111d 45090000 		.4byte	0x945
 6952 1121 04110000 		.4byte	.LFB43
 6953 1125 30000000 		.4byte	.LFE43-.LFB43
 6954 1129 01       		.uleb128 0x1
 6955 112a 9C       		.byte	0x9c
 6956 112b 3F110000 		.4byte	0x113f
 6957 112f 24       		.uleb128 0x24
 6958 1130 0A030000 		.4byte	.LASF221
 6959 1134 01       		.byte	0x1
 6960 1135 FC11     		.2byte	0x11fc
 6961 1137 45090000 		.4byte	0x945
ARM GAS  /tmp/cckqXCjj.s 			page 221


 6962 113b 02       		.uleb128 0x2
 6963 113c 91       		.byte	0x91
 6964 113d 74       		.sleb128 -12
 6965 113e 00       		.byte	0
 6966 113f 2E       		.uleb128 0x2e
 6967 1140 FB000000 		.4byte	.LASF222
 6968 1144 01       		.byte	0x1
 6969 1145 920F     		.2byte	0xf92
 6970 1147 20090000 		.4byte	0x920
 6971 114b C8100000 		.4byte	.LFB42
 6972 114f 3C000000 		.4byte	.LFE42-.LFB42
 6973 1153 01       		.uleb128 0x1
 6974 1154 9C       		.byte	0x9c
 6975 1155 69110000 		.4byte	0x1169
 6976 1159 24       		.uleb128 0x24
 6977 115a FA050000 		.4byte	.LASF204
 6978 115e 01       		.byte	0x1
 6979 115f 940F     		.2byte	0xf94
 6980 1161 20090000 		.4byte	0x920
 6981 1165 02       		.uleb128 0x2
 6982 1166 91       		.byte	0x91
 6983 1167 74       		.sleb128 -12
 6984 1168 00       		.byte	0
 6985 1169 2F       		.uleb128 0x2f
 6986 116a D0080000 		.4byte	.LASF224
 6987 116e 01       		.byte	0x1
 6988 116f 670F     		.2byte	0xf67
 6989 1171 88100000 		.4byte	.LFB41
 6990 1175 40000000 		.4byte	.LFE41-.LFB41
 6991 1179 01       		.uleb128 0x1
 6992 117a 9C       		.byte	0x9c
 6993 117b 8F110000 		.4byte	0x118f
 6994 117f 24       		.uleb128 0x24
 6995 1180 8D0F0000 		.4byte	.LASF200
 6996 1184 01       		.byte	0x1
 6997 1185 690F     		.2byte	0xf69
 6998 1187 B90B0000 		.4byte	0xbb9
 6999 118b 02       		.uleb128 0x2
 7000 118c 91       		.byte	0x91
 7001 118d 74       		.sleb128 -12
 7002 118e 00       		.byte	0
 7003 118f 25       		.uleb128 0x25
 7004 1190 740E0000 		.4byte	.LASF225
 7005 1194 01       		.byte	0x1
 7006 1195 2F0F     		.2byte	0xf2f
 7007 1197 68100000 		.4byte	.LFB40
 7008 119b 20000000 		.4byte	.LFE40-.LFB40
 7009 119f 01       		.uleb128 0x1
 7010 11a0 9C       		.byte	0x9c
 7011 11a1 B5110000 		.4byte	0x11b5
 7012 11a5 26       		.uleb128 0x26
 7013 11a6 8D0F0000 		.4byte	.LASF200
 7014 11aa 01       		.byte	0x1
 7015 11ab 2F0F     		.2byte	0xf2f
 7016 11ad B90B0000 		.4byte	0xbb9
 7017 11b1 02       		.uleb128 0x2
 7018 11b2 91       		.byte	0x91
ARM GAS  /tmp/cckqXCjj.s 			page 222


 7019 11b3 74       		.sleb128 -12
 7020 11b4 00       		.byte	0
 7021 11b5 25       		.uleb128 0x25
 7022 11b6 720D0000 		.4byte	.LASF226
 7023 11ba 01       		.byte	0x1
 7024 11bb 370E     		.2byte	0xe37
 7025 11bd 10100000 		.4byte	.LFB39
 7026 11c1 58000000 		.4byte	.LFE39-.LFB39
 7027 11c5 01       		.uleb128 0x1
 7028 11c6 9C       		.byte	0x9c
 7029 11c7 E5110000 		.4byte	0x11e5
 7030 11cb 2A       		.uleb128 0x2a
 7031 11cc 16100000 		.4byte	.LBB48
 7032 11d0 3E000000 		.4byte	.LBE48-.LBB48
 7033 11d4 24       		.uleb128 0x24
 7034 11d5 8D0F0000 		.4byte	.LASF200
 7035 11d9 01       		.byte	0x1
 7036 11da 3E0E     		.2byte	0xe3e
 7037 11dc B90B0000 		.4byte	0xbb9
 7038 11e0 02       		.uleb128 0x2
 7039 11e1 91       		.byte	0x91
 7040 11e2 74       		.sleb128 -12
 7041 11e3 00       		.byte	0
 7042 11e4 00       		.byte	0
 7043 11e5 25       		.uleb128 0x25
 7044 11e6 A6040000 		.4byte	.LASF227
 7045 11ea 01       		.byte	0x1
 7046 11eb 170E     		.2byte	0xe17
 7047 11ed 900F0000 		.4byte	.LFB38
 7048 11f1 80000000 		.4byte	.LFE38-.LFB38
 7049 11f5 01       		.uleb128 0x1
 7050 11f6 9C       		.byte	0x9c
 7051 11f7 0B120000 		.4byte	0x120b
 7052 11fb 24       		.uleb128 0x24
 7053 11fc 92000000 		.4byte	.LASF151
 7054 1200 01       		.byte	0x1
 7055 1201 190E     		.2byte	0xe19
 7056 1203 35090000 		.4byte	0x935
 7057 1207 02       		.uleb128 0x2
 7058 1208 91       		.byte	0x91
 7059 1209 74       		.sleb128 -12
 7060 120a 00       		.byte	0
 7061 120b 25       		.uleb128 0x25
 7062 120c 25070000 		.4byte	.LASF228
 7063 1210 01       		.byte	0x1
 7064 1211 400D     		.2byte	0xd40
 7065 1213 600F0000 		.4byte	.LFB37
 7066 1217 30000000 		.4byte	.LFE37-.LFB37
 7067 121b 01       		.uleb128 0x1
 7068 121c 9C       		.byte	0x9c
 7069 121d 31120000 		.4byte	0x1231
 7070 1221 26       		.uleb128 0x26
 7071 1222 230B0000 		.4byte	.LASF229
 7072 1226 01       		.byte	0x1
 7073 1227 400D     		.2byte	0xd40
 7074 1229 31010000 		.4byte	0x131
 7075 122d 02       		.uleb128 0x2
ARM GAS  /tmp/cckqXCjj.s 			page 223


 7076 122e 91       		.byte	0x91
 7077 122f 74       		.sleb128 -12
 7078 1230 00       		.byte	0
 7079 1231 30       		.uleb128 0x30
 7080 1232 010D0000 		.4byte	.LASF261
 7081 1236 01       		.byte	0x1
 7082 1237 090D     		.2byte	0xd09
 7083 1239 480F0000 		.4byte	.LFB36
 7084 123d 18000000 		.4byte	.LFE36-.LFB36
 7085 1241 01       		.uleb128 0x1
 7086 1242 9C       		.byte	0x9c
 7087 1243 27       		.uleb128 0x27
 7088 1244 220C0000 		.4byte	.LASF230
 7089 1248 01       		.byte	0x1
 7090 1249 CA0C     		.2byte	0xcca
 7091 124b 20090000 		.4byte	0x920
 7092 124f BC0E0000 		.4byte	.LFB35
 7093 1253 8C000000 		.4byte	.LFE35-.LFB35
 7094 1257 01       		.uleb128 0x1
 7095 1258 9C       		.byte	0x9c
 7096 1259 B3120000 		.4byte	0x12b3
 7097 125d 26       		.uleb128 0x26
 7098 125e 3D090000 		.4byte	.LASF231
 7099 1262 01       		.byte	0x1
 7100 1263 CA0C     		.2byte	0xcca
 7101 1265 B9120000 		.4byte	0x12b9
 7102 1269 02       		.uleb128 0x2
 7103 126a 91       		.byte	0x91
 7104 126b 64       		.sleb128 -28
 7105 126c 26       		.uleb128 0x26
 7106 126d 040E0000 		.4byte	.LASF232
 7107 1271 01       		.byte	0x1
 7108 1272 CA0C     		.2byte	0xcca
 7109 1274 C4120000 		.4byte	0x12c4
 7110 1278 02       		.uleb128 0x2
 7111 1279 91       		.byte	0x91
 7112 127a 60       		.sleb128 -32
 7113 127b 24       		.uleb128 0x24
 7114 127c FA050000 		.4byte	.LASF204
 7115 1280 01       		.byte	0x1
 7116 1281 CC0C     		.2byte	0xccc
 7117 1283 20090000 		.4byte	0x920
 7118 1287 02       		.uleb128 0x2
 7119 1288 91       		.byte	0x91
 7120 1289 74       		.sleb128 -12
 7121 128a 2A       		.uleb128 0x2a
 7122 128b CA0E0000 		.4byte	.LBB47
 7123 128f 68000000 		.4byte	.LBE47-.LBB47
 7124 1293 24       		.uleb128 0x24
 7125 1294 A5050000 		.4byte	.LASF197
 7126 1298 01       		.byte	0x1
 7127 1299 D40C     		.2byte	0xcd4
 7128 129b 55090000 		.4byte	0x955
 7129 129f 02       		.uleb128 0x2
 7130 12a0 91       		.byte	0x91
 7131 12a1 70       		.sleb128 -16
 7132 12a2 24       		.uleb128 0x24
ARM GAS  /tmp/cckqXCjj.s 			page 224


 7133 12a3 07040000 		.4byte	.LASF233
 7134 12a7 01       		.byte	0x1
 7135 12a8 D50C     		.2byte	0xcd5
 7136 12aa 55090000 		.4byte	0x955
 7137 12ae 02       		.uleb128 0x2
 7138 12af 91       		.byte	0x91
 7139 12b0 6C       		.sleb128 -20
 7140 12b1 00       		.byte	0
 7141 12b2 00       		.byte	0
 7142 12b3 0E       		.uleb128 0xe
 7143 12b4 04       		.byte	0x4
 7144 12b5 220B0000 		.4byte	0xb22
 7145 12b9 0D       		.uleb128 0xd
 7146 12ba B3120000 		.4byte	0x12b3
 7147 12be 0E       		.uleb128 0xe
 7148 12bf 04       		.byte	0x4
 7149 12c0 45090000 		.4byte	0x945
 7150 12c4 0D       		.uleb128 0xd
 7151 12c5 BE120000 		.4byte	0x12be
 7152 12c9 31       		.uleb128 0x31
 7153 12ca 91090000 		.4byte	.LASF235
 7154 12ce 01       		.byte	0x1
 7155 12cf C20C     		.2byte	0xcc2
 7156 12d1 900E0000 		.4byte	.LFB34
 7157 12d5 2C000000 		.4byte	.LFE34-.LFB34
 7158 12d9 01       		.uleb128 0x1
 7159 12da 9C       		.byte	0x9c
 7160 12db EF120000 		.4byte	0x12ef
 7161 12df 26       		.uleb128 0x26
 7162 12e0 3D090000 		.4byte	.LASF231
 7163 12e4 01       		.byte	0x1
 7164 12e5 C20C     		.2byte	0xcc2
 7165 12e7 B9120000 		.4byte	0x12b9
 7166 12eb 02       		.uleb128 0x2
 7167 12ec 91       		.byte	0x91
 7168 12ed 74       		.sleb128 -12
 7169 12ee 00       		.byte	0
 7170 12ef 28       		.uleb128 0x28
 7171 12f0 0D020000 		.4byte	.LASF236
 7172 12f4 01       		.byte	0x1
 7173 12f5 B60C     		.2byte	0xcb6
 7174 12f7 600E0000 		.4byte	.LFB33
 7175 12fb 30000000 		.4byte	.LFE33-.LFB33
 7176 12ff 01       		.uleb128 0x1
 7177 1300 9C       		.byte	0x9c
 7178 1301 15130000 		.4byte	0x1315
 7179 1305 26       		.uleb128 0x26
 7180 1306 3D090000 		.4byte	.LASF231
 7181 130a 01       		.byte	0x1
 7182 130b B60C     		.2byte	0xcb6
 7183 130d B9120000 		.4byte	0x12b9
 7184 1311 02       		.uleb128 0x2
 7185 1312 91       		.byte	0x91
 7186 1313 74       		.sleb128 -12
 7187 1314 00       		.byte	0
 7188 1315 28       		.uleb128 0x28
 7189 1316 40060000 		.4byte	.LASF237
ARM GAS  /tmp/cckqXCjj.s 			page 225


 7190 131a 01       		.byte	0x1
 7191 131b 860C     		.2byte	0xc86
 7192 131d DC0D0000 		.4byte	.LFB32
 7193 1321 84000000 		.4byte	.LFE32-.LFB32
 7194 1325 01       		.uleb128 0x1
 7195 1326 9C       		.byte	0x9c
 7196 1327 59130000 		.4byte	0x1359
 7197 132b 26       		.uleb128 0x26
 7198 132c E50F0000 		.4byte	.LASF238
 7199 1330 01       		.byte	0x1
 7200 1331 860C     		.2byte	0xc86
 7201 1333 270A0000 		.4byte	0xa27
 7202 1337 02       		.uleb128 0x2
 7203 1338 91       		.byte	0x91
 7204 1339 6C       		.sleb128 -20
 7205 133a 26       		.uleb128 0x26
 7206 133b 300B0000 		.4byte	.LASF133
 7207 133f 01       		.byte	0x1
 7208 1340 860C     		.2byte	0xc86
 7209 1342 55090000 		.4byte	0x955
 7210 1346 02       		.uleb128 0x2
 7211 1347 91       		.byte	0x91
 7212 1348 68       		.sleb128 -24
 7213 1349 24       		.uleb128 0x24
 7214 134a D4030000 		.4byte	.LASF239
 7215 134e 01       		.byte	0x1
 7216 134f 880C     		.2byte	0xc88
 7217 1351 B90B0000 		.4byte	0xbb9
 7218 1355 02       		.uleb128 0x2
 7219 1356 91       		.byte	0x91
 7220 1357 74       		.sleb128 -12
 7221 1358 00       		.byte	0
 7222 1359 27       		.uleb128 0x27
 7223 135a 80060000 		.4byte	.LASF240
 7224 135e 01       		.byte	0x1
 7225 135f 420C     		.2byte	0xc42
 7226 1361 20090000 		.4byte	0x920
 7227 1365 340D0000 		.4byte	.LFB31
 7228 1369 A8000000 		.4byte	.LFE31-.LFB31
 7229 136d 01       		.uleb128 0x1
 7230 136e 9C       		.byte	0x9c
 7231 136f A1130000 		.4byte	0x13a1
 7232 1373 26       		.uleb128 0x26
 7233 1374 74010000 		.4byte	.LASF241
 7234 1378 01       		.byte	0x1
 7235 1379 420C     		.2byte	0xc42
 7236 137b A7130000 		.4byte	0x13a7
 7237 137f 02       		.uleb128 0x2
 7238 1380 91       		.byte	0x91
 7239 1381 6C       		.sleb128 -20
 7240 1382 24       		.uleb128 0x24
 7241 1383 D4030000 		.4byte	.LASF239
 7242 1387 01       		.byte	0x1
 7243 1388 440C     		.2byte	0xc44
 7244 138a B90B0000 		.4byte	0xbb9
 7245 138e 02       		.uleb128 0x2
 7246 138f 91       		.byte	0x91
ARM GAS  /tmp/cckqXCjj.s 			page 226


 7247 1390 70       		.sleb128 -16
 7248 1391 24       		.uleb128 0x24
 7249 1392 FA050000 		.4byte	.LASF204
 7250 1396 01       		.byte	0x1
 7251 1397 450C     		.2byte	0xc45
 7252 1399 20090000 		.4byte	0x920
 7253 139d 02       		.uleb128 0x2
 7254 139e 91       		.byte	0x91
 7255 139f 74       		.sleb128 -12
 7256 13a0 00       		.byte	0
 7257 13a1 0E       		.uleb128 0xe
 7258 13a2 04       		.byte	0x4
 7259 13a3 380A0000 		.4byte	0xa38
 7260 13a7 0D       		.uleb128 0xd
 7261 13a8 A1130000 		.4byte	0x13a1
 7262 13ac 28       		.uleb128 0x28
 7263 13ad DA0D0000 		.4byte	.LASF242
 7264 13b1 01       		.byte	0x1
 7265 13b2 090C     		.2byte	0xc09
 7266 13b4 F80C0000 		.4byte	.LFB30
 7267 13b8 3C000000 		.4byte	.LFE30-.LFB30
 7268 13bc 01       		.uleb128 0x1
 7269 13bd 9C       		.byte	0x9c
 7270 13be F0130000 		.4byte	0x13f0
 7271 13c2 26       		.uleb128 0x26
 7272 13c3 74010000 		.4byte	.LASF241
 7273 13c7 01       		.byte	0x1
 7274 13c8 090C     		.2byte	0xc09
 7275 13ca 210C0000 		.4byte	0xc21
 7276 13ce 02       		.uleb128 0x2
 7277 13cf 91       		.byte	0x91
 7278 13d0 74       		.sleb128 -12
 7279 13d1 26       		.uleb128 0x26
 7280 13d2 300B0000 		.4byte	.LASF133
 7281 13d6 01       		.byte	0x1
 7282 13d7 090C     		.2byte	0xc09
 7283 13d9 55090000 		.4byte	0x955
 7284 13dd 02       		.uleb128 0x2
 7285 13de 91       		.byte	0x91
 7286 13df 70       		.sleb128 -16
 7287 13e0 26       		.uleb128 0x26
 7288 13e1 5F0E0000 		.4byte	.LASF194
 7289 13e5 01       		.byte	0x1
 7290 13e6 090C     		.2byte	0xc09
 7291 13e8 55090000 		.4byte	0x955
 7292 13ec 02       		.uleb128 0x2
 7293 13ed 91       		.byte	0x91
 7294 13ee 6C       		.sleb128 -20
 7295 13ef 00       		.byte	0
 7296 13f0 28       		.uleb128 0x28
 7297 13f1 EE0A0000 		.4byte	.LASF243
 7298 13f5 01       		.byte	0x1
 7299 13f6 F80B     		.2byte	0xbf8
 7300 13f8 CC0C0000 		.4byte	.LFB29
 7301 13fc 2C000000 		.4byte	.LFE29-.LFB29
 7302 1400 01       		.uleb128 0x1
 7303 1401 9C       		.byte	0x9c
ARM GAS  /tmp/cckqXCjj.s 			page 227


 7304 1402 25140000 		.4byte	0x1425
 7305 1406 26       		.uleb128 0x26
 7306 1407 74010000 		.4byte	.LASF241
 7307 140b 01       		.byte	0x1
 7308 140c F80B     		.2byte	0xbf8
 7309 140e 2C0C0000 		.4byte	0xc2c
 7310 1412 02       		.uleb128 0x2
 7311 1413 91       		.byte	0x91
 7312 1414 74       		.sleb128 -12
 7313 1415 26       		.uleb128 0x26
 7314 1416 5F0E0000 		.4byte	.LASF194
 7315 141a 01       		.byte	0x1
 7316 141b F80B     		.2byte	0xbf8
 7317 141d 55090000 		.4byte	0x955
 7318 1421 02       		.uleb128 0x2
 7319 1422 91       		.byte	0x91
 7320 1423 70       		.sleb128 -16
 7321 1424 00       		.byte	0
 7322 1425 31       		.uleb128 0x31
 7323 1426 A10A0000 		.4byte	.LASF244
 7324 142a 01       		.byte	0x1
 7325 142b AD0B     		.2byte	0xbad
 7326 142d 400C0000 		.4byte	.LFB28
 7327 1431 8C000000 		.4byte	.LFE28-.LFB28
 7328 1435 01       		.uleb128 0x1
 7329 1436 9C       		.byte	0x9c
 7330 1437 9D140000 		.4byte	0x149d
 7331 143b 2A       		.uleb128 0x2a
 7332 143c 5C0C0000 		.4byte	.LBB43
 7333 1440 50000000 		.4byte	.LBE43-.LBB43
 7334 1444 24       		.uleb128 0x24
 7335 1445 9C070000 		.4byte	.LASF245
 7336 1449 01       		.byte	0x1
 7337 144a E10B     		.2byte	0xbe1
 7338 144c 35090000 		.4byte	0x935
 7339 1450 02       		.uleb128 0x2
 7340 1451 91       		.byte	0x91
 7341 1452 74       		.sleb128 -12
 7342 1453 32       		.uleb128 0x32
 7343 1454 720C0000 		.4byte	.LBB46
 7344 1458 3A000000 		.4byte	.LBE46-.LBB46
 7345 145c 70140000 		.4byte	0x1470
 7346 1460 24       		.uleb128 0x24
 7347 1461 9D000000 		.4byte	.LASF246
 7348 1465 01       		.byte	0x1
 7349 1466 E10B     		.2byte	0xbe1
 7350 1468 2C0C0000 		.4byte	0xc2c
 7351 146c 02       		.uleb128 0x2
 7352 146d 91       		.byte	0x91
 7353 146e 70       		.sleb128 -16
 7354 146f 00       		.byte	0
 7355 1470 2C       		.uleb128 0x2c
 7356 1471 6C1C0000 		.4byte	0x1c6c
 7357 1475 620C0000 		.4byte	.LBB44
 7358 1479 0A000000 		.4byte	.LBE44-.LBB44
 7359 147d 01       		.byte	0x1
 7360 147e E10B     		.2byte	0xbe1
ARM GAS  /tmp/cckqXCjj.s 			page 228


 7361 1480 2D       		.uleb128 0x2d
 7362 1481 781C0000 		.4byte	0x1c78
 7363 1485 02       		.uleb128 0x2
 7364 1486 91       		.byte	0x91
 7365 1487 6C       		.sleb128 -20
 7366 1488 2A       		.uleb128 0x2a
 7367 1489 620C0000 		.4byte	.LBB45
 7368 148d 0A000000 		.4byte	.LBE45-.LBB45
 7369 1491 2B       		.uleb128 0x2b
 7370 1492 831C0000 		.4byte	0x1c83
 7371 1496 02       		.uleb128 0x2
 7372 1497 91       		.byte	0x91
 7373 1498 6B       		.sleb128 -21
 7374 1499 00       		.byte	0
 7375 149a 00       		.byte	0
 7376 149b 00       		.byte	0
 7377 149c 00       		.byte	0
 7378 149d 27       		.uleb128 0x27
 7379 149e 3C020000 		.4byte	.LASF247
 7380 14a2 01       		.byte	0x1
 7381 14a3 930A     		.2byte	0xa93
 7382 14a5 20090000 		.4byte	0x920
 7383 14a9 F00A0000 		.4byte	.LFB27
 7384 14ad 50010000 		.4byte	.LFE27-.LFB27
 7385 14b1 01       		.uleb128 0x1
 7386 14b2 9C       		.byte	0x9c
 7387 14b3 17150000 		.4byte	0x1517
 7388 14b7 24       		.uleb128 0x24
 7389 14b8 8D0F0000 		.4byte	.LASF200
 7390 14bc 01       		.byte	0x1
 7391 14bd 950A     		.2byte	0xa95
 7392 14bf B90B0000 		.4byte	0xbb9
 7393 14c3 02       		.uleb128 0x2
 7394 14c4 91       		.byte	0x91
 7395 14c5 68       		.sleb128 -24
 7396 14c6 24       		.uleb128 0x24
 7397 14c7 300B0000 		.4byte	.LASF133
 7398 14cb 01       		.byte	0x1
 7399 14cc 960A     		.2byte	0xa96
 7400 14ce 45090000 		.4byte	0x945
 7401 14d2 02       		.uleb128 0x2
 7402 14d3 91       		.byte	0x91
 7403 14d4 64       		.sleb128 -28
 7404 14d5 24       		.uleb128 0x24
 7405 14d6 C30B0000 		.4byte	.LASF248
 7406 14da 01       		.byte	0x1
 7407 14db 970A     		.2byte	0xa97
 7408 14dd 20090000 		.4byte	0x920
 7409 14e1 02       		.uleb128 0x2
 7410 14e2 91       		.byte	0x91
 7411 14e3 74       		.sleb128 -12
 7412 14e4 2A       		.uleb128 0x2a
 7413 14e5 020B0000 		.4byte	.LBB41
 7414 14e9 FC000000 		.4byte	.LBE41-.LBB41
 7415 14ed 24       		.uleb128 0x24
 7416 14ee A5050000 		.4byte	.LASF197
 7417 14f2 01       		.byte	0x1
ARM GAS  /tmp/cckqXCjj.s 			page 229


 7418 14f3 A10A     		.2byte	0xaa1
 7419 14f5 55090000 		.4byte	0x955
 7420 14f9 02       		.uleb128 0x2
 7421 14fa 91       		.byte	0x91
 7422 14fb 70       		.sleb128 -16
 7423 14fc 2A       		.uleb128 0x2a
 7424 14fd 160B0000 		.4byte	.LBB42
 7425 1501 22000000 		.4byte	.LBE42-.LBB42
 7426 1505 24       		.uleb128 0x24
 7427 1506 F3040000 		.4byte	.LASF249
 7428 150a 01       		.byte	0x1
 7429 150b A90A     		.2byte	0xaa9
 7430 150d 210C0000 		.4byte	0xc21
 7431 1511 02       		.uleb128 0x2
 7432 1512 91       		.byte	0x91
 7433 1513 6C       		.sleb128 -20
 7434 1514 00       		.byte	0
 7435 1515 00       		.byte	0
 7436 1516 00       		.byte	0
 7437 1517 27       		.uleb128 0x27
 7438 1518 C9020000 		.4byte	.LASF250
 7439 151c 01       		.byte	0x1
 7440 151d 310A     		.2byte	0xa31
 7441 151f 20090000 		.4byte	0x920
 7442 1523 C00A0000 		.4byte	.LFB26
 7443 1527 30000000 		.4byte	.LFE26-.LFB26
 7444 152b 01       		.uleb128 0x1
 7445 152c 9C       		.byte	0x9c
 7446 152d 50150000 		.4byte	0x1550
 7447 1531 26       		.uleb128 0x26
 7448 1532 B80E0000 		.4byte	.LASF251
 7449 1536 01       		.byte	0x1
 7450 1537 310A     		.2byte	0xa31
 7451 1539 45090000 		.4byte	0x945
 7452 153d 02       		.uleb128 0x2
 7453 153e 91       		.byte	0x91
 7454 153f 6C       		.sleb128 -20
 7455 1540 24       		.uleb128 0x24
 7456 1541 7C030000 		.4byte	.LASF252
 7457 1545 01       		.byte	0x1
 7458 1546 330A     		.2byte	0xa33
 7459 1548 20090000 		.4byte	0x920
 7460 154c 02       		.uleb128 0x2
 7461 154d 91       		.byte	0x91
 7462 154e 74       		.sleb128 -12
 7463 154f 00       		.byte	0
 7464 1550 2E       		.uleb128 0x2e
 7465 1551 440D0000 		.4byte	.LASF253
 7466 1555 01       		.byte	0x1
 7467 1556 3609     		.2byte	0x936
 7468 1558 38010000 		.4byte	0x138
 7469 155c 940A0000 		.4byte	.LFB25
 7470 1560 2C000000 		.4byte	.LFE25-.LFB25
 7471 1564 01       		.uleb128 0x1
 7472 1565 9C       		.byte	0x9c
 7473 1566 89150000 		.4byte	0x1589
 7474 156a 26       		.uleb128 0x26
ARM GAS  /tmp/cckqXCjj.s 			page 230


 7475 156b 250A0000 		.4byte	.LASF254
 7476 156f 01       		.byte	0x1
 7477 1570 3609     		.2byte	0x936
 7478 1572 3D0A0000 		.4byte	0xa3d
 7479 1576 02       		.uleb128 0x2
 7480 1577 91       		.byte	0x91
 7481 1578 6C       		.sleb128 -20
 7482 1579 24       		.uleb128 0x24
 7483 157a 8D0F0000 		.4byte	.LASF200
 7484 157e 01       		.byte	0x1
 7485 157f 3809     		.2byte	0x938
 7486 1581 B90B0000 		.4byte	0xbb9
 7487 1585 02       		.uleb128 0x2
 7488 1586 91       		.byte	0x91
 7489 1587 74       		.sleb128 -12
 7490 1588 00       		.byte	0
 7491 1589 33       		.uleb128 0x33
 7492 158a E4000000 		.4byte	.LASF306
 7493 158e 01       		.byte	0x1
 7494 158f 2E09     		.2byte	0x92e
 7495 1591 35090000 		.4byte	0x935
 7496 1595 800A0000 		.4byte	.LFB24
 7497 1599 14000000 		.4byte	.LFE24-.LFB24
 7498 159d 01       		.uleb128 0x1
 7499 159e 9C       		.byte	0x9c
 7500 159f 2E       		.uleb128 0x2e
 7501 15a0 4C040000 		.4byte	.LASF255
 7502 15a4 01       		.byte	0x1
 7503 15a5 0F09     		.2byte	0x90f
 7504 15a7 45090000 		.4byte	0x945
 7505 15ab 600A0000 		.4byte	.LFB23
 7506 15af 20000000 		.4byte	.LFE23-.LFB23
 7507 15b3 01       		.uleb128 0x1
 7508 15b4 9C       		.byte	0x9c
 7509 15b5 D8150000 		.4byte	0x15d8
 7510 15b9 24       		.uleb128 0x24
 7511 15ba FA050000 		.4byte	.LASF204
 7512 15be 01       		.byte	0x1
 7513 15bf 1109     		.2byte	0x911
 7514 15c1 45090000 		.4byte	0x945
 7515 15c5 02       		.uleb128 0x2
 7516 15c6 91       		.byte	0x91
 7517 15c7 70       		.sleb128 -16
 7518 15c8 24       		.uleb128 0x24
 7519 15c9 2D030000 		.4byte	.LASF208
 7520 15cd 01       		.byte	0x1
 7521 15ce 1209     		.2byte	0x912
 7522 15d0 35090000 		.4byte	0x935
 7523 15d4 02       		.uleb128 0x2
 7524 15d5 91       		.byte	0x91
 7525 15d6 74       		.sleb128 -12
 7526 15d7 00       		.byte	0
 7527 15d8 2E       		.uleb128 0x2e
 7528 15d9 75090000 		.4byte	.LASF256
 7529 15dd 01       		.byte	0x1
 7530 15de 0009     		.2byte	0x900
 7531 15e0 45090000 		.4byte	0x945
ARM GAS  /tmp/cckqXCjj.s 			page 231


 7532 15e4 440A0000 		.4byte	.LFB22
 7533 15e8 1C000000 		.4byte	.LFE22-.LFB22
 7534 15ec 01       		.uleb128 0x1
 7535 15ed 9C       		.byte	0x9c
 7536 15ee 02160000 		.4byte	0x1602
 7537 15f2 24       		.uleb128 0x24
 7538 15f3 86080000 		.4byte	.LASF257
 7539 15f7 01       		.byte	0x1
 7540 15f8 0209     		.2byte	0x902
 7541 15fa 45090000 		.4byte	0x945
 7542 15fe 02       		.uleb128 0x2
 7543 15ff 91       		.byte	0x91
 7544 1600 74       		.sleb128 -12
 7545 1601 00       		.byte	0
 7546 1602 27       		.uleb128 0x27
 7547 1603 5E0B0000 		.4byte	.LASF258
 7548 1607 01       		.byte	0x1
 7549 1608 9208     		.2byte	0x892
 7550 160a 20090000 		.4byte	0x920
 7551 160e 28090000 		.4byte	.LFB21
 7552 1612 1C010000 		.4byte	.LFE21-.LFB21
 7553 1616 01       		.uleb128 0x1
 7554 1617 9C       		.byte	0x9c
 7555 1618 54160000 		.4byte	0x1654
 7556 161c 24       		.uleb128 0x24
 7557 161d 8D0F0000 		.4byte	.LASF200
 7558 1621 01       		.byte	0x1
 7559 1622 9408     		.2byte	0x894
 7560 1624 B90B0000 		.4byte	0xbb9
 7561 1628 02       		.uleb128 0x2
 7562 1629 91       		.byte	0x91
 7563 162a 74       		.sleb128 -12
 7564 162b 24       		.uleb128 0x24
 7565 162c 8E0E0000 		.4byte	.LASF259
 7566 1630 01       		.byte	0x1
 7567 1631 9508     		.2byte	0x895
 7568 1633 20090000 		.4byte	0x920
 7569 1637 02       		.uleb128 0x2
 7570 1638 91       		.byte	0x91
 7571 1639 70       		.sleb128 -16
 7572 163a 2A       		.uleb128 0x2a
 7573 163b C6090000 		.4byte	.LBB40
 7574 163f 2E000000 		.4byte	.LBE40-.LBB40
 7575 1643 24       		.uleb128 0x24
 7576 1644 CE010000 		.4byte	.LASF260
 7577 1648 01       		.byte	0x1
 7578 1649 CD08     		.2byte	0x8cd
 7579 164b 45090000 		.4byte	0x945
 7580 164f 02       		.uleb128 0x2
 7581 1650 91       		.byte	0x91
 7582 1651 6C       		.sleb128 -20
 7583 1652 00       		.byte	0
 7584 1653 00       		.byte	0
 7585 1654 30       		.uleb128 0x30
 7586 1655 02050000 		.4byte	.LASF262
 7587 1659 01       		.byte	0x1
 7588 165a 3E08     		.2byte	0x83e
ARM GAS  /tmp/cckqXCjj.s 			page 232


 7589 165c 0C090000 		.4byte	.LFB20
 7590 1660 1C000000 		.4byte	.LFE20-.LFB20
 7591 1664 01       		.uleb128 0x1
 7592 1665 9C       		.byte	0x9c
 7593 1666 28       		.uleb128 0x28
 7594 1667 1B000000 		.4byte	.LASF263
 7595 166b 01       		.byte	0x1
 7596 166c 3308     		.2byte	0x833
 7597 166e DC080000 		.4byte	.LFB19
 7598 1672 30000000 		.4byte	.LFE19-.LFB19
 7599 1676 01       		.uleb128 0x1
 7600 1677 9C       		.byte	0x9c
 7601 1678 A0160000 		.4byte	0x16a0
 7602 167c 2C       		.uleb128 0x2c
 7603 167d 541C0000 		.4byte	0x1c54
 7604 1681 E2080000 		.4byte	.LBB38
 7605 1685 12000000 		.4byte	.LBE38-.LBB38
 7606 1689 01       		.byte	0x1
 7607 168a 3808     		.2byte	0x838
 7608 168c 2A       		.uleb128 0x2a
 7609 168d E2080000 		.4byte	.LBB39
 7610 1691 12000000 		.4byte	.LBE39-.LBB39
 7611 1695 2B       		.uleb128 0x2b
 7612 1696 601C0000 		.4byte	0x1c60
 7613 169a 02       		.uleb128 0x2
 7614 169b 91       		.byte	0x91
 7615 169c 74       		.sleb128 -12
 7616 169d 00       		.byte	0
 7617 169e 00       		.byte	0
 7618 169f 00       		.byte	0
 7619 16a0 28       		.uleb128 0x28
 7620 16a1 5E0D0000 		.4byte	.LASF264
 7621 16a5 01       		.byte	0x1
 7622 16a6 B707     		.2byte	0x7b7
 7623 16a8 70080000 		.4byte	.LFB18
 7624 16ac 6C000000 		.4byte	.LFE18-.LFB18
 7625 16b0 01       		.uleb128 0x1
 7626 16b1 9C       		.byte	0x9c
 7627 16b2 E9160000 		.4byte	0x16e9
 7628 16b6 24       		.uleb128 0x24
 7629 16b7 FA050000 		.4byte	.LASF204
 7630 16bb 01       		.byte	0x1
 7631 16bc B907     		.2byte	0x7b9
 7632 16be 20090000 		.4byte	0x920
 7633 16c2 02       		.uleb128 0x2
 7634 16c3 91       		.byte	0x91
 7635 16c4 74       		.sleb128 -12
 7636 16c5 2C       		.uleb128 0x2c
 7637 16c6 541C0000 		.4byte	0x1c54
 7638 16ca 92080000 		.4byte	.LBB36
 7639 16ce 12000000 		.4byte	.LBE36-.LBB36
 7640 16d2 01       		.byte	0x1
 7641 16d3 FF07     		.2byte	0x7ff
 7642 16d5 2A       		.uleb128 0x2a
 7643 16d6 92080000 		.4byte	.LBB37
 7644 16da 12000000 		.4byte	.LBE37-.LBB37
 7645 16de 2B       		.uleb128 0x2b
ARM GAS  /tmp/cckqXCjj.s 			page 233


 7646 16df 601C0000 		.4byte	0x1c60
 7647 16e3 02       		.uleb128 0x2
 7648 16e4 91       		.byte	0x91
 7649 16e5 70       		.sleb128 -16
 7650 16e6 00       		.byte	0
 7651 16e7 00       		.byte	0
 7652 16e8 00       		.byte	0
 7653 16e9 27       		.uleb128 0x27
 7654 16ea BC0C0000 		.4byte	.LASF265
 7655 16ee 01       		.byte	0x1
 7656 16ef 7107     		.2byte	0x771
 7657 16f1 20090000 		.4byte	0x920
 7658 16f5 B0070000 		.4byte	.LFB17
 7659 16f9 C0000000 		.4byte	.LFE17-.LFB17
 7660 16fd 01       		.uleb128 0x1
 7661 16fe 9C       		.byte	0x9c
 7662 16ff 88170000 		.4byte	0x1788
 7663 1703 26       		.uleb128 0x26
 7664 1704 E8020000 		.4byte	.LASF266
 7665 1708 01       		.byte	0x1
 7666 1709 7107     		.2byte	0x771
 7667 170b 3D0A0000 		.4byte	0xa3d
 7668 170f 02       		.uleb128 0x2
 7669 1710 91       		.byte	0x91
 7670 1711 5C       		.sleb128 -36
 7671 1712 24       		.uleb128 0x24
 7672 1713 7C030000 		.4byte	.LASF252
 7673 1717 01       		.byte	0x1
 7674 1718 7307     		.2byte	0x773
 7675 171a 20090000 		.4byte	0x920
 7676 171e 02       		.uleb128 0x2
 7677 171f 91       		.byte	0x91
 7678 1720 74       		.sleb128 -12
 7679 1721 24       		.uleb128 0x24
 7680 1722 8D0F0000 		.4byte	.LASF200
 7681 1726 01       		.byte	0x1
 7682 1727 7407     		.2byte	0x774
 7683 1729 C40B0000 		.4byte	0xbc4
 7684 172d 02       		.uleb128 0x2
 7685 172e 91       		.byte	0x91
 7686 172f 70       		.sleb128 -16
 7687 1730 24       		.uleb128 0x24
 7688 1731 2D030000 		.4byte	.LASF208
 7689 1735 01       		.byte	0x1
 7690 1736 7507     		.2byte	0x775
 7691 1738 35090000 		.4byte	0x935
 7692 173c 02       		.uleb128 0x2
 7693 173d 91       		.byte	0x91
 7694 173e 6C       		.sleb128 -20
 7695 173f 29       		.uleb128 0x29
 7696 1740 2D1C0000 		.4byte	0x1c2d
 7697 1744 C0070000 		.4byte	.LBB32
 7698 1748 1A000000 		.4byte	.LBE32-.LBB32
 7699 174c 01       		.byte	0x1
 7700 174d 8B07     		.2byte	0x78b
 7701 174f 6E170000 		.4byte	0x176e
 7702 1753 2A       		.uleb128 0x2a
ARM GAS  /tmp/cckqXCjj.s 			page 234


 7703 1754 C0070000 		.4byte	.LBB33
 7704 1758 1A000000 		.4byte	.LBE33-.LBB33
 7705 175c 2B       		.uleb128 0x2b
 7706 175d 3D1C0000 		.4byte	0x1c3d
 7707 1761 02       		.uleb128 0x2
 7708 1762 91       		.byte	0x91
 7709 1763 68       		.sleb128 -24
 7710 1764 2B       		.uleb128 0x2b
 7711 1765 481C0000 		.4byte	0x1c48
 7712 1769 02       		.uleb128 0x2
 7713 176a 91       		.byte	0x91
 7714 176b 64       		.sleb128 -28
 7715 176c 00       		.byte	0
 7716 176d 00       		.byte	0
 7717 176e 2C       		.uleb128 0x2c
 7718 176f 151C0000 		.4byte	0x1c15
 7719 1773 4C080000 		.4byte	.LBB34
 7720 1777 06000000 		.4byte	.LBE34-.LBB34
 7721 177b 01       		.byte	0x1
 7722 177c AF07     		.2byte	0x7af
 7723 177e 2D       		.uleb128 0x2d
 7724 177f 211C0000 		.4byte	0x1c21
 7725 1783 02       		.uleb128 0x2
 7726 1784 91       		.byte	0x91
 7727 1785 60       		.sleb128 -32
 7728 1786 00       		.byte	0
 7729 1787 00       		.byte	0
 7730 1788 28       		.uleb128 0x28
 7731 1789 D10F0000 		.4byte	.LASF267
 7732 178d 01       		.byte	0x1
 7733 178e 3B07     		.2byte	0x73b
 7734 1790 10070000 		.4byte	.LFB16
 7735 1794 A0000000 		.4byte	.LFE16-.LFB16
 7736 1798 01       		.uleb128 0x1
 7737 1799 9C       		.byte	0x9c
 7738 179a BD170000 		.4byte	0x17bd
 7739 179e 26       		.uleb128 0x26
 7740 179f E8020000 		.4byte	.LASF266
 7741 17a3 01       		.byte	0x1
 7742 17a4 3B07     		.2byte	0x73b
 7743 17a6 3D0A0000 		.4byte	0xa3d
 7744 17aa 02       		.uleb128 0x2
 7745 17ab 91       		.byte	0x91
 7746 17ac 6C       		.sleb128 -20
 7747 17ad 24       		.uleb128 0x24
 7748 17ae 8D0F0000 		.4byte	.LASF200
 7749 17b2 01       		.byte	0x1
 7750 17b3 3D07     		.2byte	0x73d
 7751 17b5 C40B0000 		.4byte	0xbc4
 7752 17b9 02       		.uleb128 0x2
 7753 17ba 91       		.byte	0x91
 7754 17bb 74       		.sleb128 -12
 7755 17bc 00       		.byte	0
 7756 17bd 34       		.uleb128 0x34
 7757 17be 4D030000 		.4byte	.LASF307
 7758 17c2 01       		.byte	0x1
 7759 17c3 0D07     		.2byte	0x70d
ARM GAS  /tmp/cckqXCjj.s 			page 235


 7760 17c5 20090000 		.4byte	0x920
 7761 17c9 CC060000 		.4byte	.LFB15
 7762 17cd 44000000 		.4byte	.LFE15-.LFB15
 7763 17d1 01       		.uleb128 0x1
 7764 17d2 9C       		.byte	0x9c
 7765 17d3 05180000 		.4byte	0x1805
 7766 17d7 26       		.uleb128 0x26
 7767 17d8 510A0000 		.4byte	.LASF198
 7768 17dc 01       		.byte	0x1
 7769 17dd 0D07     		.2byte	0x70d
 7770 17df 480A0000 		.4byte	0xa48
 7771 17e3 02       		.uleb128 0x2
 7772 17e4 91       		.byte	0x91
 7773 17e5 6C       		.sleb128 -20
 7774 17e6 24       		.uleb128 0x24
 7775 17e7 FA050000 		.4byte	.LASF204
 7776 17eb 01       		.byte	0x1
 7777 17ec 0F07     		.2byte	0x70f
 7778 17ee 20090000 		.4byte	0x920
 7779 17f2 02       		.uleb128 0x2
 7780 17f3 91       		.byte	0x91
 7781 17f4 74       		.sleb128 -12
 7782 17f5 24       		.uleb128 0x24
 7783 17f6 8D0F0000 		.4byte	.LASF200
 7784 17fa 01       		.byte	0x1
 7785 17fb 1007     		.2byte	0x710
 7786 17fd 0B180000 		.4byte	0x180b
 7787 1801 02       		.uleb128 0x2
 7788 1802 91       		.byte	0x91
 7789 1803 70       		.sleb128 -16
 7790 1804 00       		.byte	0
 7791 1805 0E       		.uleb128 0xe
 7792 1806 04       		.byte	0x4
 7793 1807 A20B0000 		.4byte	0xba2
 7794 180b 0D       		.uleb128 0xd
 7795 180c 05180000 		.4byte	0x1805
 7796 1810 28       		.uleb128 0x28
 7797 1811 810E0000 		.4byte	.LASF268
 7798 1815 01       		.byte	0x1
 7799 1816 A806     		.2byte	0x6a8
 7800 1818 C8050000 		.4byte	.LFB14
 7801 181c 04010000 		.4byte	.LFE14-.LFB14
 7802 1820 01       		.uleb128 0x1
 7803 1821 9C       		.byte	0x9c
 7804 1822 45180000 		.4byte	0x1845
 7805 1826 26       		.uleb128 0x26
 7806 1827 130C0000 		.4byte	.LASF269
 7807 182b 01       		.byte	0x1
 7808 182c A806     		.2byte	0x6a8
 7809 182e 3D0A0000 		.4byte	0xa3d
 7810 1832 02       		.uleb128 0x2
 7811 1833 91       		.byte	0x91
 7812 1834 6C       		.sleb128 -20
 7813 1835 24       		.uleb128 0x24
 7814 1836 8D0F0000 		.4byte	.LASF200
 7815 183a 01       		.byte	0x1
 7816 183b AA06     		.2byte	0x6aa
ARM GAS  /tmp/cckqXCjj.s 			page 236


 7817 183d B90B0000 		.4byte	0xbb9
 7818 1841 02       		.uleb128 0x2
 7819 1842 91       		.byte	0x91
 7820 1843 74       		.sleb128 -12
 7821 1844 00       		.byte	0
 7822 1845 28       		.uleb128 0x28
 7823 1846 040A0000 		.4byte	.LASF270
 7824 184a 01       		.byte	0x1
 7825 184b 0406     		.2byte	0x604
 7826 184d A4040000 		.4byte	.LFB13
 7827 1851 24010000 		.4byte	.LFE13-.LFB13
 7828 1855 01       		.uleb128 0x1
 7829 1856 9C       		.byte	0x9c
 7830 1857 B6180000 		.4byte	0x18b6
 7831 185b 26       		.uleb128 0x26
 7832 185c 510A0000 		.4byte	.LASF198
 7833 1860 01       		.byte	0x1
 7834 1861 0406     		.2byte	0x604
 7835 1863 3D0A0000 		.4byte	0xa3d
 7836 1867 02       		.uleb128 0x2
 7837 1868 91       		.byte	0x91
 7838 1869 64       		.sleb128 -28
 7839 186a 26       		.uleb128 0x26
 7840 186b FC080000 		.4byte	.LASF271
 7841 186f 01       		.byte	0x1
 7842 1870 0406     		.2byte	0x604
 7843 1872 35090000 		.4byte	0x935
 7844 1876 02       		.uleb128 0x2
 7845 1877 91       		.byte	0x91
 7846 1878 60       		.sleb128 -32
 7847 1879 24       		.uleb128 0x24
 7848 187a 8D0F0000 		.4byte	.LASF200
 7849 187e 01       		.byte	0x1
 7850 187f 0606     		.2byte	0x606
 7851 1881 B90B0000 		.4byte	0xbb9
 7852 1885 02       		.uleb128 0x2
 7853 1886 91       		.byte	0x91
 7854 1887 70       		.sleb128 -16
 7855 1888 24       		.uleb128 0x24
 7856 1889 53100000 		.4byte	.LASF272
 7857 188d 01       		.byte	0x1
 7858 188e 0706     		.2byte	0x607
 7859 1890 35090000 		.4byte	0x935
 7860 1894 02       		.uleb128 0x2
 7861 1895 91       		.byte	0x91
 7862 1896 6C       		.sleb128 -20
 7863 1897 24       		.uleb128 0x24
 7864 1898 430E0000 		.4byte	.LASF273
 7865 189c 01       		.byte	0x1
 7866 189d 0706     		.2byte	0x607
 7867 189f 35090000 		.4byte	0x935
 7868 18a3 02       		.uleb128 0x2
 7869 18a4 91       		.byte	0x91
 7870 18a5 68       		.sleb128 -24
 7871 18a6 24       		.uleb128 0x24
 7872 18a7 7C030000 		.4byte	.LASF252
 7873 18ab 01       		.byte	0x1
ARM GAS  /tmp/cckqXCjj.s 			page 237


 7874 18ac 0806     		.2byte	0x608
 7875 18ae 20090000 		.4byte	0x920
 7876 18b2 02       		.uleb128 0x2
 7877 18b3 91       		.byte	0x91
 7878 18b4 74       		.sleb128 -12
 7879 18b5 00       		.byte	0
 7880 18b6 2E       		.uleb128 0x2e
 7881 18b7 51090000 		.4byte	.LASF274
 7882 18bb 01       		.byte	0x1
 7883 18bc DC05     		.2byte	0x5dc
 7884 18be 35090000 		.4byte	0x935
 7885 18c2 50040000 		.4byte	.LFB12
 7886 18c6 54000000 		.4byte	.LFE12-.LFB12
 7887 18ca 01       		.uleb128 0x1
 7888 18cb 9C       		.byte	0x9c
 7889 18cc 55190000 		.4byte	0x1955
 7890 18d0 26       		.uleb128 0x26
 7891 18d1 510A0000 		.4byte	.LASF198
 7892 18d5 01       		.byte	0x1
 7893 18d6 DC05     		.2byte	0x5dc
 7894 18d8 480A0000 		.4byte	0xa48
 7895 18dc 02       		.uleb128 0x2
 7896 18dd 91       		.byte	0x91
 7897 18de 5C       		.sleb128 -36
 7898 18df 24       		.uleb128 0x24
 7899 18e0 8D0F0000 		.4byte	.LASF200
 7900 18e4 01       		.byte	0x1
 7901 18e5 DE05     		.2byte	0x5de
 7902 18e7 05180000 		.4byte	0x1805
 7903 18eb 02       		.uleb128 0x2
 7904 18ec 91       		.byte	0x91
 7905 18ed 70       		.sleb128 -16
 7906 18ee 24       		.uleb128 0x24
 7907 18ef 0A030000 		.4byte	.LASF221
 7908 18f3 01       		.byte	0x1
 7909 18f4 DF05     		.2byte	0x5df
 7910 18f6 35090000 		.4byte	0x935
 7911 18fa 02       		.uleb128 0x2
 7912 18fb 91       		.byte	0x91
 7913 18fc 6C       		.sleb128 -20
 7914 18fd 24       		.uleb128 0x24
 7915 18fe B4080000 		.4byte	.LASF275
 7916 1902 01       		.byte	0x1
 7917 1903 DF05     		.2byte	0x5df
 7918 1905 35090000 		.4byte	0x935
 7919 1909 02       		.uleb128 0x2
 7920 190a 91       		.byte	0x91
 7921 190b 74       		.sleb128 -12
 7922 190c 29       		.uleb128 0x29
 7923 190d 2D1C0000 		.4byte	0x1c2d
 7924 1911 58040000 		.4byte	.LBB28
 7925 1915 1A000000 		.4byte	.LBE28-.LBB28
 7926 1919 01       		.byte	0x1
 7927 191a F305     		.2byte	0x5f3
 7928 191c 3B190000 		.4byte	0x193b
 7929 1920 2A       		.uleb128 0x2a
 7930 1921 58040000 		.4byte	.LBB29
ARM GAS  /tmp/cckqXCjj.s 			page 238


 7931 1925 1A000000 		.4byte	.LBE29-.LBB29
 7932 1929 2B       		.uleb128 0x2b
 7933 192a 3D1C0000 		.4byte	0x1c3d
 7934 192e 02       		.uleb128 0x2
 7935 192f 91       		.byte	0x91
 7936 1930 68       		.sleb128 -24
 7937 1931 2B       		.uleb128 0x2b
 7938 1932 481C0000 		.4byte	0x1c48
 7939 1936 02       		.uleb128 0x2
 7940 1937 91       		.byte	0x91
 7941 1938 64       		.sleb128 -28
 7942 1939 00       		.byte	0
 7943 193a 00       		.byte	0
 7944 193b 2C       		.uleb128 0x2c
 7945 193c 151C0000 		.4byte	0x1c15
 7946 1940 8E040000 		.4byte	.LBB30
 7947 1944 06000000 		.4byte	.LBE30-.LBB30
 7948 1948 01       		.byte	0x1
 7949 1949 FA05     		.2byte	0x5fa
 7950 194b 2D       		.uleb128 0x2d
 7951 194c 211C0000 		.4byte	0x1c21
 7952 1950 02       		.uleb128 0x2
 7953 1951 91       		.byte	0x91
 7954 1952 60       		.sleb128 -32
 7955 1953 00       		.byte	0
 7956 1954 00       		.byte	0
 7957 1955 27       		.uleb128 0x27
 7958 1956 49010000 		.4byte	.LASF276
 7959 195a 01       		.byte	0x1
 7960 195b C605     		.2byte	0x5c6
 7961 195d 35090000 		.4byte	0x935
 7962 1961 1C040000 		.4byte	.LFB11
 7963 1965 34000000 		.4byte	.LFE11-.LFB11
 7964 1969 01       		.uleb128 0x1
 7965 196a 9C       		.byte	0x9c
 7966 196b 9D190000 		.4byte	0x199d
 7967 196f 26       		.uleb128 0x26
 7968 1970 510A0000 		.4byte	.LASF198
 7969 1974 01       		.byte	0x1
 7970 1975 C605     		.2byte	0x5c6
 7971 1977 480A0000 		.4byte	0xa48
 7972 197b 02       		.uleb128 0x2
 7973 197c 91       		.byte	0x91
 7974 197d 6C       		.sleb128 -20
 7975 197e 24       		.uleb128 0x24
 7976 197f 8D0F0000 		.4byte	.LASF200
 7977 1983 01       		.byte	0x1
 7978 1984 C805     		.2byte	0x5c8
 7979 1986 05180000 		.4byte	0x1805
 7980 198a 02       		.uleb128 0x2
 7981 198b 91       		.byte	0x91
 7982 198c 74       		.sleb128 -12
 7983 198d 24       		.uleb128 0x24
 7984 198e 0A030000 		.4byte	.LASF221
 7985 1992 01       		.byte	0x1
 7986 1993 C905     		.2byte	0x5c9
 7987 1995 35090000 		.4byte	0x935
ARM GAS  /tmp/cckqXCjj.s 			page 239


 7988 1999 02       		.uleb128 0x2
 7989 199a 91       		.byte	0x91
 7990 199b 70       		.sleb128 -16
 7991 199c 00       		.byte	0
 7992 199d 28       		.uleb128 0x28
 7993 199e 18060000 		.4byte	.LASF277
 7994 19a2 01       		.byte	0x1
 7995 19a3 3D05     		.2byte	0x53d
 7996 19a5 D4030000 		.4byte	.LFB10
 7997 19a9 48000000 		.4byte	.LFE10-.LFB10
 7998 19ad 01       		.uleb128 0x1
 7999 19ae 9C       		.byte	0x9c
 8000 19af D2190000 		.4byte	0x19d2
 8001 19b3 26       		.uleb128 0x26
 8002 19b4 B60D0000 		.4byte	.LASF278
 8003 19b8 01       		.byte	0x1
 8004 19b9 3D05     		.2byte	0x53d
 8005 19bb 55090000 		.4byte	0x955
 8006 19bf 02       		.uleb128 0x2
 8007 19c0 91       		.byte	0x91
 8008 19c1 6C       		.sleb128 -20
 8009 19c2 24       		.uleb128 0x24
 8010 19c3 8E0E0000 		.4byte	.LASF259
 8011 19c7 01       		.byte	0x1
 8012 19c8 3F05     		.2byte	0x53f
 8013 19ca 20090000 		.4byte	0x920
 8014 19ce 02       		.uleb128 0x2
 8015 19cf 91       		.byte	0x91
 8016 19d0 74       		.sleb128 -12
 8017 19d1 00       		.byte	0
 8018 19d2 28       		.uleb128 0x28
 8019 19d3 1F0E0000 		.4byte	.LASF279
 8020 19d7 01       		.byte	0x1
 8021 19d8 E904     		.2byte	0x4e9
 8022 19da 34030000 		.4byte	.LFB9
 8023 19de A0000000 		.4byte	.LFE9-.LFB9
 8024 19e2 01       		.uleb128 0x1
 8025 19e3 9C       		.byte	0x9c
 8026 19e4 4D1A0000 		.4byte	0x1a4d
 8027 19e8 26       		.uleb128 0x26
 8028 19e9 370C0000 		.4byte	.LASF280
 8029 19ed 01       		.byte	0x1
 8030 19ee E904     		.2byte	0x4e9
 8031 19f0 C4120000 		.4byte	0x12c4
 8032 19f4 02       		.uleb128 0x2
 8033 19f5 91       		.byte	0x91
 8034 19f6 64       		.sleb128 -28
 8035 19f7 26       		.uleb128 0x26
 8036 19f8 2A0F0000 		.4byte	.LASF281
 8037 19fc 01       		.byte	0x1
 8038 19fd E904     		.2byte	0x4e9
 8039 19ff 55090000 		.4byte	0x955
 8040 1a03 02       		.uleb128 0x2
 8041 1a04 91       		.byte	0x91
 8042 1a05 60       		.sleb128 -32
 8043 1a06 24       		.uleb128 0x24
 8044 1a07 FE020000 		.4byte	.LASF196
ARM GAS  /tmp/cckqXCjj.s 			page 240


 8045 1a0b 01       		.byte	0x1
 8046 1a0c EB04     		.2byte	0x4eb
 8047 1a0e 45090000 		.4byte	0x945
 8048 1a12 02       		.uleb128 0x2
 8049 1a13 91       		.byte	0x91
 8050 1a14 6C       		.sleb128 -20
 8051 1a15 24       		.uleb128 0x24
 8052 1a16 8E0E0000 		.4byte	.LASF259
 8053 1a1a 01       		.byte	0x1
 8054 1a1b EC04     		.2byte	0x4ec
 8055 1a1d 20090000 		.4byte	0x920
 8056 1a21 02       		.uleb128 0x2
 8057 1a22 91       		.byte	0x91
 8058 1a23 68       		.sleb128 -24
 8059 1a24 24       		.uleb128 0x24
 8060 1a25 18070000 		.4byte	.LASF282
 8061 1a29 01       		.byte	0x1
 8062 1a2a EC04     		.2byte	0x4ec
 8063 1a2c 20090000 		.4byte	0x920
 8064 1a30 02       		.uleb128 0x2
 8065 1a31 91       		.byte	0x91
 8066 1a32 74       		.sleb128 -12
 8067 1a33 2A       		.uleb128 0x2a
 8068 1a34 46030000 		.4byte	.LBB27
 8069 1a38 62000000 		.4byte	.LBE27-.LBB27
 8070 1a3c 24       		.uleb128 0x24
 8071 1a3d A5050000 		.4byte	.LASF197
 8072 1a41 01       		.byte	0x1
 8073 1a42 F604     		.2byte	0x4f6
 8074 1a44 55090000 		.4byte	0x955
 8075 1a48 02       		.uleb128 0x2
 8076 1a49 91       		.byte	0x91
 8077 1a4a 70       		.sleb128 -16
 8078 1a4b 00       		.byte	0
 8079 1a4c 00       		.byte	0
 8080 1a4d 28       		.uleb128 0x28
 8081 1a4e 8E0A0000 		.4byte	.LASF283
 8082 1a52 01       		.byte	0x1
 8083 1a53 8A04     		.2byte	0x48a
 8084 1a55 38020000 		.4byte	.LFB8
 8085 1a59 FC000000 		.4byte	.LFE8-.LFB8
 8086 1a5d 01       		.uleb128 0x1
 8087 1a5e 9C       		.byte	0x9c
 8088 1a5f 821A0000 		.4byte	0x1a82
 8089 1a63 26       		.uleb128 0x26
 8090 1a64 F30B0000 		.4byte	.LASF284
 8091 1a68 01       		.byte	0x1
 8092 1a69 8A04     		.2byte	0x48a
 8093 1a6b 3D0A0000 		.4byte	0xa3d
 8094 1a6f 02       		.uleb128 0x2
 8095 1a70 91       		.byte	0x91
 8096 1a71 6C       		.sleb128 -20
 8097 1a72 24       		.uleb128 0x24
 8098 1a73 8D0F0000 		.4byte	.LASF200
 8099 1a77 01       		.byte	0x1
 8100 1a78 8C04     		.2byte	0x48c
 8101 1a7a B90B0000 		.4byte	0xbb9
ARM GAS  /tmp/cckqXCjj.s 			page 241


 8102 1a7e 02       		.uleb128 0x2
 8103 1a7f 91       		.byte	0x91
 8104 1a80 74       		.sleb128 -12
 8105 1a81 00       		.byte	0
 8106 1a82 25       		.uleb128 0x25
 8107 1a83 1A100000 		.4byte	.LASF285
 8108 1a87 01       		.byte	0x1
 8109 1a88 3504     		.2byte	0x435
 8110 1a8a 64010000 		.4byte	.LFB7
 8111 1a8e D4000000 		.4byte	.LFE7-.LFB7
 8112 1a92 01       		.uleb128 0x1
 8113 1a93 9C       		.byte	0x9c
 8114 1a94 A81A0000 		.4byte	0x1aa8
 8115 1a98 26       		.uleb128 0x26
 8116 1a99 93070000 		.4byte	.LASF286
 8117 1a9d 01       		.byte	0x1
 8118 1a9e 3504     		.2byte	0x435
 8119 1aa0 B90B0000 		.4byte	0xbb9
 8120 1aa4 02       		.uleb128 0x2
 8121 1aa5 91       		.byte	0x91
 8122 1aa6 74       		.sleb128 -12
 8123 1aa7 00       		.byte	0
 8124 1aa8 25       		.uleb128 0x25
 8125 1aa9 0E0B0000 		.4byte	.LASF287
 8126 1aad 01       		.byte	0x1
 8127 1aae 3803     		.2byte	0x338
 8128 1ab0 82000000 		.4byte	.LFB6
 8129 1ab4 E2000000 		.4byte	.LFE6-.LFB6
 8130 1ab8 01       		.uleb128 0x1
 8131 1ab9 9C       		.byte	0x9c
 8132 1aba 531B0000 		.4byte	0x1b53
 8133 1abe 26       		.uleb128 0x26
 8134 1abf B5070000 		.4byte	.LASF288
 8135 1ac3 01       		.byte	0x1
 8136 1ac4 3803     		.2byte	0x338
 8137 1ac6 F4080000 		.4byte	0x8f4
 8138 1aca 02       		.uleb128 0x2
 8139 1acb 91       		.byte	0x91
 8140 1acc 6C       		.sleb128 -20
 8141 1acd 26       		.uleb128 0x26
 8142 1ace D9050000 		.4byte	.LASF289
 8143 1ad2 01       		.byte	0x1
 8144 1ad3 3903     		.2byte	0x339
 8145 1ad5 BC050000 		.4byte	0x5bc
 8146 1ad9 02       		.uleb128 0x2
 8147 1ada 91       		.byte	0x91
 8148 1adb 68       		.sleb128 -24
 8149 1adc 26       		.uleb128 0x26
 8150 1add 0B070000 		.4byte	.LASF290
 8151 1ae1 01       		.byte	0x1
 8152 1ae2 3A03     		.2byte	0x33a
 8153 1ae4 E4080000 		.4byte	0x8e4
 8154 1ae8 02       		.uleb128 0x2
 8155 1ae9 91       		.byte	0x91
 8156 1aea 64       		.sleb128 -28
 8157 1aeb 26       		.uleb128 0x26
 8158 1aec 230B0000 		.4byte	.LASF229
ARM GAS  /tmp/cckqXCjj.s 			page 242


 8159 1af0 01       		.byte	0x1
 8160 1af1 3B03     		.2byte	0x33b
 8161 1af3 33010000 		.4byte	0x133
 8162 1af7 02       		.uleb128 0x2
 8163 1af8 91       		.byte	0x91
 8164 1af9 60       		.sleb128 -32
 8165 1afa 26       		.uleb128 0x26
 8166 1afb 92000000 		.4byte	.LASF151
 8167 1aff 01       		.byte	0x1
 8168 1b00 3C03     		.2byte	0x33c
 8169 1b02 35090000 		.4byte	0x935
 8170 1b06 02       		.uleb128 0x2
 8171 1b07 91       		.byte	0x91
 8172 1b08 00       		.sleb128 0
 8173 1b09 26       		.uleb128 0x26
 8174 1b0a 06100000 		.4byte	.LASF291
 8175 1b0e 01       		.byte	0x1
 8176 1b0f 3D03     		.2byte	0x33d
 8177 1b11 591B0000 		.4byte	0x1b59
 8178 1b15 02       		.uleb128 0x2
 8179 1b16 91       		.byte	0x91
 8180 1b17 04       		.sleb128 4
 8181 1b18 26       		.uleb128 0x26
 8182 1b19 93070000 		.4byte	.LASF286
 8183 1b1d 01       		.byte	0x1
 8184 1b1e 3E03     		.2byte	0x33e
 8185 1b20 B90B0000 		.4byte	0xbb9
 8186 1b24 02       		.uleb128 0x2
 8187 1b25 91       		.byte	0x91
 8188 1b26 08       		.sleb128 8
 8189 1b27 26       		.uleb128 0x26
 8190 1b28 C80E0000 		.4byte	.LASF292
 8191 1b2c 01       		.byte	0x1
 8192 1b2d 3F03     		.2byte	0x33f
 8193 1b2f 641B0000 		.4byte	0x1b64
 8194 1b33 02       		.uleb128 0x2
 8195 1b34 91       		.byte	0x91
 8196 1b35 0C       		.sleb128 12
 8197 1b36 24       		.uleb128 0x24
 8198 1b37 BC0F0000 		.4byte	.LASF148
 8199 1b3b 01       		.byte	0x1
 8200 1b3c 4103     		.2byte	0x341
 8201 1b3e 6E0B0000 		.4byte	0xb6e
 8202 1b42 02       		.uleb128 0x2
 8203 1b43 91       		.byte	0x91
 8204 1b44 70       		.sleb128 -16
 8205 1b45 35       		.uleb128 0x35
 8206 1b46 7800     		.ascii	"x\000"
 8207 1b48 01       		.byte	0x1
 8208 1b49 4203     		.2byte	0x342
 8209 1b4b 35090000 		.4byte	0x935
 8210 1b4f 02       		.uleb128 0x2
 8211 1b50 91       		.byte	0x91
 8212 1b51 74       		.sleb128 -12
 8213 1b52 00       		.byte	0
 8214 1b53 0E       		.uleb128 0xe
 8215 1b54 04       		.byte	0x4
ARM GAS  /tmp/cckqXCjj.s 			page 243


 8216 1b55 3D0A0000 		.4byte	0xa3d
 8217 1b59 0D       		.uleb128 0xd
 8218 1b5a 531B0000 		.4byte	0x1b53
 8219 1b5e 0E       		.uleb128 0xe
 8220 1b5f 04       		.byte	0x4
 8221 1b60 690B0000 		.4byte	0xb69
 8222 1b64 0D       		.uleb128 0xd
 8223 1b65 5E1B0000 		.4byte	0x1b5e
 8224 1b69 27       		.uleb128 0x27
 8225 1b6a 6C070000 		.4byte	.LASF293
 8226 1b6e 01       		.byte	0x1
 8227 1b6f DD02     		.2byte	0x2dd
 8228 1b71 20090000 		.4byte	0x920
 8229 1b75 00000000 		.4byte	.LFB5
 8230 1b79 82000000 		.4byte	.LFE5-.LFB5
 8231 1b7d 01       		.uleb128 0x1
 8232 1b7e 9C       		.byte	0x9c
 8233 1b7f 151C0000 		.4byte	0x1c15
 8234 1b83 26       		.uleb128 0x26
 8235 1b84 B5070000 		.4byte	.LASF288
 8236 1b88 01       		.byte	0x1
 8237 1b89 DD02     		.2byte	0x2dd
 8238 1b8b F4080000 		.4byte	0x8f4
 8239 1b8f 02       		.uleb128 0x2
 8240 1b90 91       		.byte	0x91
 8241 1b91 64       		.sleb128 -28
 8242 1b92 26       		.uleb128 0x26
 8243 1b93 D9050000 		.4byte	.LASF289
 8244 1b97 01       		.byte	0x1
 8245 1b98 DE02     		.2byte	0x2de
 8246 1b9a BC050000 		.4byte	0x5bc
 8247 1b9e 02       		.uleb128 0x2
 8248 1b9f 91       		.byte	0x91
 8249 1ba0 60       		.sleb128 -32
 8250 1ba1 26       		.uleb128 0x26
 8251 1ba2 F7070000 		.4byte	.LASF294
 8252 1ba6 01       		.byte	0x1
 8253 1ba7 DF02     		.2byte	0x2df
 8254 1ba9 CF080000 		.4byte	0x8cf
 8255 1bad 02       		.uleb128 0x2
 8256 1bae 91       		.byte	0x91
 8257 1baf 5E       		.sleb128 -34
 8258 1bb0 26       		.uleb128 0x26
 8259 1bb1 230B0000 		.4byte	.LASF229
 8260 1bb5 01       		.byte	0x1
 8261 1bb6 E002     		.2byte	0x2e0
 8262 1bb8 33010000 		.4byte	0x133
 8263 1bbc 02       		.uleb128 0x2
 8264 1bbd 91       		.byte	0x91
 8265 1bbe 58       		.sleb128 -40
 8266 1bbf 26       		.uleb128 0x26
 8267 1bc0 92000000 		.4byte	.LASF151
 8268 1bc4 01       		.byte	0x1
 8269 1bc5 E102     		.2byte	0x2e1
 8270 1bc7 35090000 		.4byte	0x935
 8271 1bcb 02       		.uleb128 0x2
 8272 1bcc 91       		.byte	0x91
ARM GAS  /tmp/cckqXCjj.s 			page 244


 8273 1bcd 00       		.sleb128 0
 8274 1bce 26       		.uleb128 0x26
 8275 1bcf 06100000 		.4byte	.LASF291
 8276 1bd3 01       		.byte	0x1
 8277 1bd4 E202     		.2byte	0x2e2
 8278 1bd6 591B0000 		.4byte	0x1b59
 8279 1bda 02       		.uleb128 0x2
 8280 1bdb 91       		.byte	0x91
 8281 1bdc 04       		.sleb128 4
 8282 1bdd 24       		.uleb128 0x24
 8283 1bde 93070000 		.4byte	.LASF286
 8284 1be2 01       		.byte	0x1
 8285 1be3 E402     		.2byte	0x2e4
 8286 1be5 B90B0000 		.4byte	0xbb9
 8287 1be9 02       		.uleb128 0x2
 8288 1bea 91       		.byte	0x91
 8289 1beb 74       		.sleb128 -12
 8290 1bec 24       		.uleb128 0x24
 8291 1bed FA050000 		.4byte	.LASF204
 8292 1bf1 01       		.byte	0x1
 8293 1bf2 E502     		.2byte	0x2e5
 8294 1bf4 20090000 		.4byte	0x920
 8295 1bf8 02       		.uleb128 0x2
 8296 1bf9 91       		.byte	0x91
 8297 1bfa 70       		.sleb128 -16
 8298 1bfb 2A       		.uleb128 0x2a
 8299 1bfc 10000000 		.4byte	.LBB26
 8300 1c00 34000000 		.4byte	.LBE26-.LBB26
 8301 1c04 24       		.uleb128 0x24
 8302 1c05 560B0000 		.4byte	.LASF152
 8303 1c09 01       		.byte	0x1
 8304 1c0a 0203     		.2byte	0x302
 8305 1c0c 6E0B0000 		.4byte	0xb6e
 8306 1c10 02       		.uleb128 0x2
 8307 1c11 91       		.byte	0x91
 8308 1c12 6C       		.sleb128 -20
 8309 1c13 00       		.byte	0
 8310 1c14 00       		.byte	0
 8311 1c15 36       		.uleb128 0x36
 8312 1c16 B1020000 		.4byte	.LASF297
 8313 1c1a 02       		.byte	0x2
 8314 1c1b E5       		.byte	0xe5
 8315 1c1c 03       		.byte	0x3
 8316 1c1d 2D1C0000 		.4byte	0x1c2d
 8317 1c21 37       		.uleb128 0x37
 8318 1c22 DB090000 		.4byte	.LASF300
 8319 1c26 02       		.byte	0x2
 8320 1c27 E5       		.byte	0xe5
 8321 1c28 D4080000 		.4byte	0x8d4
 8322 1c2c 00       		.byte	0
 8323 1c2d 38       		.uleb128 0x38
 8324 1c2e E4070000 		.4byte	.LASF308
 8325 1c32 02       		.byte	0x2
 8326 1c33 D1       		.byte	0xd1
 8327 1c34 D4080000 		.4byte	0x8d4
 8328 1c38 03       		.byte	0x3
 8329 1c39 541C0000 		.4byte	0x1c54
ARM GAS  /tmp/cckqXCjj.s 			page 245


 8330 1c3d 39       		.uleb128 0x39
 8331 1c3e 92030000 		.4byte	.LASF295
 8332 1c42 02       		.byte	0x2
 8333 1c43 D3       		.byte	0xd3
 8334 1c44 D4080000 		.4byte	0x8d4
 8335 1c48 39       		.uleb128 0x39
 8336 1c49 8D080000 		.4byte	.LASF296
 8337 1c4d 02       		.byte	0x2
 8338 1c4e D3       		.byte	0xd3
 8339 1c4f D4080000 		.4byte	0x8d4
 8340 1c53 00       		.byte	0
 8341 1c54 36       		.uleb128 0x36
 8342 1c55 240D0000 		.4byte	.LASF298
 8343 1c59 02       		.byte	0x2
 8344 1c5a C1       		.byte	0xc1
 8345 1c5b 03       		.byte	0x3
 8346 1c5c 6C1C0000 		.4byte	0x1c6c
 8347 1c60 39       		.uleb128 0x39
 8348 1c61 8D080000 		.4byte	.LASF296
 8349 1c65 02       		.byte	0x2
 8350 1c66 C3       		.byte	0xc3
 8351 1c67 D4080000 		.4byte	0x8d4
 8352 1c6b 00       		.byte	0
 8353 1c6c 3A       		.uleb128 0x3a
 8354 1c6d 66080000 		.4byte	.LASF299
 8355 1c71 02       		.byte	0x2
 8356 1c72 82       		.byte	0x82
 8357 1c73 B4080000 		.4byte	0x8b4
 8358 1c77 03       		.byte	0x3
 8359 1c78 37       		.uleb128 0x37
 8360 1c79 61020000 		.4byte	.LASF301
 8361 1c7d 02       		.byte	0x2
 8362 1c7e 82       		.byte	0x82
 8363 1c7f D4080000 		.4byte	0x8d4
 8364 1c83 39       		.uleb128 0x39
 8365 1c84 4A100000 		.4byte	.LASF302
 8366 1c88 02       		.byte	0x2
 8367 1c89 84       		.byte	0x84
 8368 1c8a B4080000 		.4byte	0x8b4
 8369 1c8e 00       		.byte	0
 8370 1c8f 00       		.byte	0
 8371              		.section	.debug_abbrev,"",%progbits
 8372              	.Ldebug_abbrev0:
 8373 0000 01       		.uleb128 0x1
 8374 0001 11       		.uleb128 0x11
 8375 0002 01       		.byte	0x1
 8376 0003 25       		.uleb128 0x25
 8377 0004 0E       		.uleb128 0xe
 8378 0005 13       		.uleb128 0x13
 8379 0006 0B       		.uleb128 0xb
 8380 0007 03       		.uleb128 0x3
 8381 0008 0E       		.uleb128 0xe
 8382 0009 1B       		.uleb128 0x1b
 8383 000a 0E       		.uleb128 0xe
 8384 000b 11       		.uleb128 0x11
 8385 000c 01       		.uleb128 0x1
 8386 000d 12       		.uleb128 0x12
ARM GAS  /tmp/cckqXCjj.s 			page 246


 8387 000e 06       		.uleb128 0x6
 8388 000f 10       		.uleb128 0x10
 8389 0010 17       		.uleb128 0x17
 8390 0011 00       		.byte	0
 8391 0012 00       		.byte	0
 8392 0013 02       		.uleb128 0x2
 8393 0014 16       		.uleb128 0x16
 8394 0015 00       		.byte	0
 8395 0016 03       		.uleb128 0x3
 8396 0017 0E       		.uleb128 0xe
 8397 0018 3A       		.uleb128 0x3a
 8398 0019 0B       		.uleb128 0xb
 8399 001a 3B       		.uleb128 0x3b
 8400 001b 0B       		.uleb128 0xb
 8401 001c 49       		.uleb128 0x49
 8402 001d 13       		.uleb128 0x13
 8403 001e 00       		.byte	0
 8404 001f 00       		.byte	0
 8405 0020 03       		.uleb128 0x3
 8406 0021 24       		.uleb128 0x24
 8407 0022 00       		.byte	0
 8408 0023 0B       		.uleb128 0xb
 8409 0024 0B       		.uleb128 0xb
 8410 0025 3E       		.uleb128 0x3e
 8411 0026 0B       		.uleb128 0xb
 8412 0027 03       		.uleb128 0x3
 8413 0028 0E       		.uleb128 0xe
 8414 0029 00       		.byte	0
 8415 002a 00       		.byte	0
 8416 002b 04       		.uleb128 0x4
 8417 002c 24       		.uleb128 0x24
 8418 002d 00       		.byte	0
 8419 002e 0B       		.uleb128 0xb
 8420 002f 0B       		.uleb128 0xb
 8421 0030 3E       		.uleb128 0x3e
 8422 0031 0B       		.uleb128 0xb
 8423 0032 03       		.uleb128 0x3
 8424 0033 08       		.uleb128 0x8
 8425 0034 00       		.byte	0
 8426 0035 00       		.byte	0
 8427 0036 05       		.uleb128 0x5
 8428 0037 16       		.uleb128 0x16
 8429 0038 00       		.byte	0
 8430 0039 03       		.uleb128 0x3
 8431 003a 0E       		.uleb128 0xe
 8432 003b 3A       		.uleb128 0x3a
 8433 003c 0B       		.uleb128 0xb
 8434 003d 3B       		.uleb128 0x3b
 8435 003e 05       		.uleb128 0x5
 8436 003f 49       		.uleb128 0x49
 8437 0040 13       		.uleb128 0x13
 8438 0041 00       		.byte	0
 8439 0042 00       		.byte	0
 8440 0043 06       		.uleb128 0x6
 8441 0044 17       		.uleb128 0x17
 8442 0045 01       		.byte	0x1
 8443 0046 0B       		.uleb128 0xb
ARM GAS  /tmp/cckqXCjj.s 			page 247


 8444 0047 0B       		.uleb128 0xb
 8445 0048 3A       		.uleb128 0x3a
 8446 0049 0B       		.uleb128 0xb
 8447 004a 3B       		.uleb128 0x3b
 8448 004b 0B       		.uleb128 0xb
 8449 004c 01       		.uleb128 0x1
 8450 004d 13       		.uleb128 0x13
 8451 004e 00       		.byte	0
 8452 004f 00       		.byte	0
 8453 0050 07       		.uleb128 0x7
 8454 0051 0D       		.uleb128 0xd
 8455 0052 00       		.byte	0
 8456 0053 03       		.uleb128 0x3
 8457 0054 0E       		.uleb128 0xe
 8458 0055 3A       		.uleb128 0x3a
 8459 0056 0B       		.uleb128 0xb
 8460 0057 3B       		.uleb128 0x3b
 8461 0058 0B       		.uleb128 0xb
 8462 0059 49       		.uleb128 0x49
 8463 005a 13       		.uleb128 0x13
 8464 005b 00       		.byte	0
 8465 005c 00       		.byte	0
 8466 005d 08       		.uleb128 0x8
 8467 005e 01       		.uleb128 0x1
 8468 005f 01       		.byte	0x1
 8469 0060 49       		.uleb128 0x49
 8470 0061 13       		.uleb128 0x13
 8471 0062 01       		.uleb128 0x1
 8472 0063 13       		.uleb128 0x13
 8473 0064 00       		.byte	0
 8474 0065 00       		.byte	0
 8475 0066 09       		.uleb128 0x9
 8476 0067 21       		.uleb128 0x21
 8477 0068 00       		.byte	0
 8478 0069 49       		.uleb128 0x49
 8479 006a 13       		.uleb128 0x13
 8480 006b 2F       		.uleb128 0x2f
 8481 006c 0B       		.uleb128 0xb
 8482 006d 00       		.byte	0
 8483 006e 00       		.byte	0
 8484 006f 0A       		.uleb128 0xa
 8485 0070 13       		.uleb128 0x13
 8486 0071 01       		.byte	0x1
 8487 0072 0B       		.uleb128 0xb
 8488 0073 0B       		.uleb128 0xb
 8489 0074 3A       		.uleb128 0x3a
 8490 0075 0B       		.uleb128 0xb
 8491 0076 3B       		.uleb128 0x3b
 8492 0077 0B       		.uleb128 0xb
 8493 0078 01       		.uleb128 0x1
 8494 0079 13       		.uleb128 0x13
 8495 007a 00       		.byte	0
 8496 007b 00       		.byte	0
 8497 007c 0B       		.uleb128 0xb
 8498 007d 0D       		.uleb128 0xd
 8499 007e 00       		.byte	0
 8500 007f 03       		.uleb128 0x3
ARM GAS  /tmp/cckqXCjj.s 			page 248


 8501 0080 0E       		.uleb128 0xe
 8502 0081 3A       		.uleb128 0x3a
 8503 0082 0B       		.uleb128 0xb
 8504 0083 3B       		.uleb128 0x3b
 8505 0084 0B       		.uleb128 0xb
 8506 0085 49       		.uleb128 0x49
 8507 0086 13       		.uleb128 0x13
 8508 0087 38       		.uleb128 0x38
 8509 0088 0B       		.uleb128 0xb
 8510 0089 00       		.byte	0
 8511 008a 00       		.byte	0
 8512 008b 0C       		.uleb128 0xc
 8513 008c 0F       		.uleb128 0xf
 8514 008d 00       		.byte	0
 8515 008e 0B       		.uleb128 0xb
 8516 008f 0B       		.uleb128 0xb
 8517 0090 00       		.byte	0
 8518 0091 00       		.byte	0
 8519 0092 0D       		.uleb128 0xd
 8520 0093 26       		.uleb128 0x26
 8521 0094 00       		.byte	0
 8522 0095 49       		.uleb128 0x49
 8523 0096 13       		.uleb128 0x13
 8524 0097 00       		.byte	0
 8525 0098 00       		.byte	0
 8526 0099 0E       		.uleb128 0xe
 8527 009a 0F       		.uleb128 0xf
 8528 009b 00       		.byte	0
 8529 009c 0B       		.uleb128 0xb
 8530 009d 0B       		.uleb128 0xb
 8531 009e 49       		.uleb128 0x49
 8532 009f 13       		.uleb128 0x13
 8533 00a0 00       		.byte	0
 8534 00a1 00       		.byte	0
 8535 00a2 0F       		.uleb128 0xf
 8536 00a3 13       		.uleb128 0x13
 8537 00a4 01       		.byte	0x1
 8538 00a5 03       		.uleb128 0x3
 8539 00a6 0E       		.uleb128 0xe
 8540 00a7 0B       		.uleb128 0xb
 8541 00a8 0B       		.uleb128 0xb
 8542 00a9 3A       		.uleb128 0x3a
 8543 00aa 0B       		.uleb128 0xb
 8544 00ab 3B       		.uleb128 0x3b
 8545 00ac 0B       		.uleb128 0xb
 8546 00ad 01       		.uleb128 0x1
 8547 00ae 13       		.uleb128 0x13
 8548 00af 00       		.byte	0
 8549 00b0 00       		.byte	0
 8550 00b1 10       		.uleb128 0x10
 8551 00b2 0D       		.uleb128 0xd
 8552 00b3 00       		.byte	0
 8553 00b4 03       		.uleb128 0x3
 8554 00b5 08       		.uleb128 0x8
 8555 00b6 3A       		.uleb128 0x3a
 8556 00b7 0B       		.uleb128 0xb
 8557 00b8 3B       		.uleb128 0x3b
ARM GAS  /tmp/cckqXCjj.s 			page 249


 8558 00b9 0B       		.uleb128 0xb
 8559 00ba 49       		.uleb128 0x49
 8560 00bb 13       		.uleb128 0x13
 8561 00bc 38       		.uleb128 0x38
 8562 00bd 0B       		.uleb128 0xb
 8563 00be 00       		.byte	0
 8564 00bf 00       		.byte	0
 8565 00c0 11       		.uleb128 0x11
 8566 00c1 13       		.uleb128 0x13
 8567 00c2 01       		.byte	0x1
 8568 00c3 03       		.uleb128 0x3
 8569 00c4 0E       		.uleb128 0xe
 8570 00c5 0B       		.uleb128 0xb
 8571 00c6 05       		.uleb128 0x5
 8572 00c7 3A       		.uleb128 0x3a
 8573 00c8 0B       		.uleb128 0xb
 8574 00c9 3B       		.uleb128 0x3b
 8575 00ca 0B       		.uleb128 0xb
 8576 00cb 01       		.uleb128 0x1
 8577 00cc 13       		.uleb128 0x13
 8578 00cd 00       		.byte	0
 8579 00ce 00       		.byte	0
 8580 00cf 12       		.uleb128 0x12
 8581 00d0 0D       		.uleb128 0xd
 8582 00d1 00       		.byte	0
 8583 00d2 03       		.uleb128 0x3
 8584 00d3 0E       		.uleb128 0xe
 8585 00d4 3A       		.uleb128 0x3a
 8586 00d5 0B       		.uleb128 0xb
 8587 00d6 3B       		.uleb128 0x3b
 8588 00d7 0B       		.uleb128 0xb
 8589 00d8 49       		.uleb128 0x49
 8590 00d9 13       		.uleb128 0x13
 8591 00da 38       		.uleb128 0x38
 8592 00db 05       		.uleb128 0x5
 8593 00dc 00       		.byte	0
 8594 00dd 00       		.byte	0
 8595 00de 13       		.uleb128 0x13
 8596 00df 15       		.uleb128 0x15
 8597 00e0 00       		.byte	0
 8598 00e1 27       		.uleb128 0x27
 8599 00e2 19       		.uleb128 0x19
 8600 00e3 00       		.byte	0
 8601 00e4 00       		.byte	0
 8602 00e5 14       		.uleb128 0x14
 8603 00e6 15       		.uleb128 0x15
 8604 00e7 01       		.byte	0x1
 8605 00e8 27       		.uleb128 0x27
 8606 00e9 19       		.uleb128 0x19
 8607 00ea 49       		.uleb128 0x49
 8608 00eb 13       		.uleb128 0x13
 8609 00ec 01       		.uleb128 0x1
 8610 00ed 13       		.uleb128 0x13
 8611 00ee 00       		.byte	0
 8612 00ef 00       		.byte	0
 8613 00f0 15       		.uleb128 0x15
 8614 00f1 05       		.uleb128 0x5
ARM GAS  /tmp/cckqXCjj.s 			page 250


 8615 00f2 00       		.byte	0
 8616 00f3 49       		.uleb128 0x49
 8617 00f4 13       		.uleb128 0x13
 8618 00f5 00       		.byte	0
 8619 00f6 00       		.byte	0
 8620 00f7 16       		.uleb128 0x16
 8621 00f8 13       		.uleb128 0x13
 8622 00f9 01       		.byte	0x1
 8623 00fa 03       		.uleb128 0x3
 8624 00fb 0E       		.uleb128 0xe
 8625 00fc 0B       		.uleb128 0xb
 8626 00fd 05       		.uleb128 0x5
 8627 00fe 3A       		.uleb128 0x3a
 8628 00ff 0B       		.uleb128 0xb
 8629 0100 3B       		.uleb128 0x3b
 8630 0101 05       		.uleb128 0x5
 8631 0102 01       		.uleb128 0x1
 8632 0103 13       		.uleb128 0x13
 8633 0104 00       		.byte	0
 8634 0105 00       		.byte	0
 8635 0106 17       		.uleb128 0x17
 8636 0107 0D       		.uleb128 0xd
 8637 0108 00       		.byte	0
 8638 0109 03       		.uleb128 0x3
 8639 010a 0E       		.uleb128 0xe
 8640 010b 3A       		.uleb128 0x3a
 8641 010c 0B       		.uleb128 0xb
 8642 010d 3B       		.uleb128 0x3b
 8643 010e 05       		.uleb128 0x5
 8644 010f 49       		.uleb128 0x49
 8645 0110 13       		.uleb128 0x13
 8646 0111 38       		.uleb128 0x38
 8647 0112 0B       		.uleb128 0xb
 8648 0113 00       		.byte	0
 8649 0114 00       		.byte	0
 8650 0115 18       		.uleb128 0x18
 8651 0116 0D       		.uleb128 0xd
 8652 0117 00       		.byte	0
 8653 0118 03       		.uleb128 0x3
 8654 0119 0E       		.uleb128 0xe
 8655 011a 3A       		.uleb128 0x3a
 8656 011b 0B       		.uleb128 0xb
 8657 011c 3B       		.uleb128 0x3b
 8658 011d 05       		.uleb128 0x5
 8659 011e 49       		.uleb128 0x49
 8660 011f 13       		.uleb128 0x13
 8661 0120 38       		.uleb128 0x38
 8662 0121 05       		.uleb128 0x5
 8663 0122 00       		.byte	0
 8664 0123 00       		.byte	0
 8665 0124 19       		.uleb128 0x19
 8666 0125 13       		.uleb128 0x13
 8667 0126 01       		.byte	0x1
 8668 0127 03       		.uleb128 0x3
 8669 0128 0E       		.uleb128 0xe
 8670 0129 0B       		.uleb128 0xb
 8671 012a 0B       		.uleb128 0xb
ARM GAS  /tmp/cckqXCjj.s 			page 251


 8672 012b 3A       		.uleb128 0x3a
 8673 012c 0B       		.uleb128 0xb
 8674 012d 3B       		.uleb128 0x3b
 8675 012e 05       		.uleb128 0x5
 8676 012f 01       		.uleb128 0x1
 8677 0130 13       		.uleb128 0x13
 8678 0131 00       		.byte	0
 8679 0132 00       		.byte	0
 8680 0133 1A       		.uleb128 0x1a
 8681 0134 13       		.uleb128 0x13
 8682 0135 01       		.byte	0x1
 8683 0136 0B       		.uleb128 0xb
 8684 0137 0B       		.uleb128 0xb
 8685 0138 3A       		.uleb128 0x3a
 8686 0139 0B       		.uleb128 0xb
 8687 013a 3B       		.uleb128 0x3b
 8688 013b 05       		.uleb128 0x5
 8689 013c 01       		.uleb128 0x1
 8690 013d 13       		.uleb128 0x13
 8691 013e 00       		.byte	0
 8692 013f 00       		.byte	0
 8693 0140 1B       		.uleb128 0x1b
 8694 0141 17       		.uleb128 0x17
 8695 0142 01       		.byte	0x1
 8696 0143 0B       		.uleb128 0xb
 8697 0144 0B       		.uleb128 0xb
 8698 0145 3A       		.uleb128 0x3a
 8699 0146 0B       		.uleb128 0xb
 8700 0147 3B       		.uleb128 0x3b
 8701 0148 05       		.uleb128 0x5
 8702 0149 01       		.uleb128 0x1
 8703 014a 13       		.uleb128 0x13
 8704 014b 00       		.byte	0
 8705 014c 00       		.byte	0
 8706 014d 1C       		.uleb128 0x1c
 8707 014e 0D       		.uleb128 0xd
 8708 014f 00       		.byte	0
 8709 0150 03       		.uleb128 0x3
 8710 0151 0E       		.uleb128 0xe
 8711 0152 3A       		.uleb128 0x3a
 8712 0153 0B       		.uleb128 0xb
 8713 0154 3B       		.uleb128 0x3b
 8714 0155 05       		.uleb128 0x5
 8715 0156 49       		.uleb128 0x49
 8716 0157 13       		.uleb128 0x13
 8717 0158 00       		.byte	0
 8718 0159 00       		.byte	0
 8719 015a 1D       		.uleb128 0x1d
 8720 015b 15       		.uleb128 0x15
 8721 015c 01       		.byte	0x1
 8722 015d 27       		.uleb128 0x27
 8723 015e 19       		.uleb128 0x19
 8724 015f 01       		.uleb128 0x1
 8725 0160 13       		.uleb128 0x13
 8726 0161 00       		.byte	0
 8727 0162 00       		.byte	0
 8728 0163 1E       		.uleb128 0x1e
ARM GAS  /tmp/cckqXCjj.s 			page 252


 8729 0164 34       		.uleb128 0x34
 8730 0165 00       		.byte	0
 8731 0166 03       		.uleb128 0x3
 8732 0167 0E       		.uleb128 0xe
 8733 0168 3A       		.uleb128 0x3a
 8734 0169 0B       		.uleb128 0xb
 8735 016a 3B       		.uleb128 0x3b
 8736 016b 05       		.uleb128 0x5
 8737 016c 49       		.uleb128 0x49
 8738 016d 13       		.uleb128 0x13
 8739 016e 3F       		.uleb128 0x3f
 8740 016f 19       		.uleb128 0x19
 8741 0170 3C       		.uleb128 0x3c
 8742 0171 19       		.uleb128 0x19
 8743 0172 00       		.byte	0
 8744 0173 00       		.byte	0
 8745 0174 1F       		.uleb128 0x1f
 8746 0175 35       		.uleb128 0x35
 8747 0176 00       		.byte	0
 8748 0177 49       		.uleb128 0x49
 8749 0178 13       		.uleb128 0x13
 8750 0179 00       		.byte	0
 8751 017a 00       		.byte	0
 8752 017b 20       		.uleb128 0x20
 8753 017c 34       		.uleb128 0x34
 8754 017d 00       		.byte	0
 8755 017e 03       		.uleb128 0x3
 8756 017f 0E       		.uleb128 0xe
 8757 0180 3A       		.uleb128 0x3a
 8758 0181 0B       		.uleb128 0xb
 8759 0182 3B       		.uleb128 0x3b
 8760 0183 0B       		.uleb128 0xb
 8761 0184 49       		.uleb128 0x49
 8762 0185 13       		.uleb128 0x13
 8763 0186 3F       		.uleb128 0x3f
 8764 0187 19       		.uleb128 0x19
 8765 0188 3C       		.uleb128 0x3c
 8766 0189 19       		.uleb128 0x19
 8767 018a 00       		.byte	0
 8768 018b 00       		.byte	0
 8769 018c 21       		.uleb128 0x21
 8770 018d 04       		.uleb128 0x4
 8771 018e 01       		.byte	0x1
 8772 018f 0B       		.uleb128 0xb
 8773 0190 0B       		.uleb128 0xb
 8774 0191 49       		.uleb128 0x49
 8775 0192 13       		.uleb128 0x13
 8776 0193 3A       		.uleb128 0x3a
 8777 0194 0B       		.uleb128 0xb
 8778 0195 3B       		.uleb128 0x3b
 8779 0196 0B       		.uleb128 0xb
 8780 0197 01       		.uleb128 0x1
 8781 0198 13       		.uleb128 0x13
 8782 0199 00       		.byte	0
 8783 019a 00       		.byte	0
 8784 019b 22       		.uleb128 0x22
 8785 019c 28       		.uleb128 0x28
ARM GAS  /tmp/cckqXCjj.s 			page 253


 8786 019d 00       		.byte	0
 8787 019e 03       		.uleb128 0x3
 8788 019f 0E       		.uleb128 0xe
 8789 01a0 1C       		.uleb128 0x1c
 8790 01a1 0B       		.uleb128 0xb
 8791 01a2 00       		.byte	0
 8792 01a3 00       		.byte	0
 8793 01a4 23       		.uleb128 0x23
 8794 01a5 34       		.uleb128 0x34
 8795 01a6 00       		.byte	0
 8796 01a7 03       		.uleb128 0x3
 8797 01a8 0E       		.uleb128 0xe
 8798 01a9 3A       		.uleb128 0x3a
 8799 01aa 0B       		.uleb128 0xb
 8800 01ab 3B       		.uleb128 0x3b
 8801 01ac 05       		.uleb128 0x5
 8802 01ad 49       		.uleb128 0x49
 8803 01ae 13       		.uleb128 0x13
 8804 01af 3F       		.uleb128 0x3f
 8805 01b0 19       		.uleb128 0x19
 8806 01b1 02       		.uleb128 0x2
 8807 01b2 18       		.uleb128 0x18
 8808 01b3 00       		.byte	0
 8809 01b4 00       		.byte	0
 8810 01b5 24       		.uleb128 0x24
 8811 01b6 34       		.uleb128 0x34
 8812 01b7 00       		.byte	0
 8813 01b8 03       		.uleb128 0x3
 8814 01b9 0E       		.uleb128 0xe
 8815 01ba 3A       		.uleb128 0x3a
 8816 01bb 0B       		.uleb128 0xb
 8817 01bc 3B       		.uleb128 0x3b
 8818 01bd 05       		.uleb128 0x5
 8819 01be 49       		.uleb128 0x49
 8820 01bf 13       		.uleb128 0x13
 8821 01c0 02       		.uleb128 0x2
 8822 01c1 18       		.uleb128 0x18
 8823 01c2 00       		.byte	0
 8824 01c3 00       		.byte	0
 8825 01c4 25       		.uleb128 0x25
 8826 01c5 2E       		.uleb128 0x2e
 8827 01c6 01       		.byte	0x1
 8828 01c7 03       		.uleb128 0x3
 8829 01c8 0E       		.uleb128 0xe
 8830 01c9 3A       		.uleb128 0x3a
 8831 01ca 0B       		.uleb128 0xb
 8832 01cb 3B       		.uleb128 0x3b
 8833 01cc 05       		.uleb128 0x5
 8834 01cd 27       		.uleb128 0x27
 8835 01ce 19       		.uleb128 0x19
 8836 01cf 11       		.uleb128 0x11
 8837 01d0 01       		.uleb128 0x1
 8838 01d1 12       		.uleb128 0x12
 8839 01d2 06       		.uleb128 0x6
 8840 01d3 40       		.uleb128 0x40
 8841 01d4 18       		.uleb128 0x18
 8842 01d5 9642     		.uleb128 0x2116
ARM GAS  /tmp/cckqXCjj.s 			page 254


 8843 01d7 19       		.uleb128 0x19
 8844 01d8 01       		.uleb128 0x1
 8845 01d9 13       		.uleb128 0x13
 8846 01da 00       		.byte	0
 8847 01db 00       		.byte	0
 8848 01dc 26       		.uleb128 0x26
 8849 01dd 05       		.uleb128 0x5
 8850 01de 00       		.byte	0
 8851 01df 03       		.uleb128 0x3
 8852 01e0 0E       		.uleb128 0xe
 8853 01e1 3A       		.uleb128 0x3a
 8854 01e2 0B       		.uleb128 0xb
 8855 01e3 3B       		.uleb128 0x3b
 8856 01e4 05       		.uleb128 0x5
 8857 01e5 49       		.uleb128 0x49
 8858 01e6 13       		.uleb128 0x13
 8859 01e7 02       		.uleb128 0x2
 8860 01e8 18       		.uleb128 0x18
 8861 01e9 00       		.byte	0
 8862 01ea 00       		.byte	0
 8863 01eb 27       		.uleb128 0x27
 8864 01ec 2E       		.uleb128 0x2e
 8865 01ed 01       		.byte	0x1
 8866 01ee 3F       		.uleb128 0x3f
 8867 01ef 19       		.uleb128 0x19
 8868 01f0 03       		.uleb128 0x3
 8869 01f1 0E       		.uleb128 0xe
 8870 01f2 3A       		.uleb128 0x3a
 8871 01f3 0B       		.uleb128 0xb
 8872 01f4 3B       		.uleb128 0x3b
 8873 01f5 05       		.uleb128 0x5
 8874 01f6 27       		.uleb128 0x27
 8875 01f7 19       		.uleb128 0x19
 8876 01f8 49       		.uleb128 0x49
 8877 01f9 13       		.uleb128 0x13
 8878 01fa 11       		.uleb128 0x11
 8879 01fb 01       		.uleb128 0x1
 8880 01fc 12       		.uleb128 0x12
 8881 01fd 06       		.uleb128 0x6
 8882 01fe 40       		.uleb128 0x40
 8883 01ff 18       		.uleb128 0x18
 8884 0200 9642     		.uleb128 0x2116
 8885 0202 19       		.uleb128 0x19
 8886 0203 01       		.uleb128 0x1
 8887 0204 13       		.uleb128 0x13
 8888 0205 00       		.byte	0
 8889 0206 00       		.byte	0
 8890 0207 28       		.uleb128 0x28
 8891 0208 2E       		.uleb128 0x2e
 8892 0209 01       		.byte	0x1
 8893 020a 3F       		.uleb128 0x3f
 8894 020b 19       		.uleb128 0x19
 8895 020c 03       		.uleb128 0x3
 8896 020d 0E       		.uleb128 0xe
 8897 020e 3A       		.uleb128 0x3a
 8898 020f 0B       		.uleb128 0xb
 8899 0210 3B       		.uleb128 0x3b
ARM GAS  /tmp/cckqXCjj.s 			page 255


 8900 0211 05       		.uleb128 0x5
 8901 0212 27       		.uleb128 0x27
 8902 0213 19       		.uleb128 0x19
 8903 0214 11       		.uleb128 0x11
 8904 0215 01       		.uleb128 0x1
 8905 0216 12       		.uleb128 0x12
 8906 0217 06       		.uleb128 0x6
 8907 0218 40       		.uleb128 0x40
 8908 0219 18       		.uleb128 0x18
 8909 021a 9642     		.uleb128 0x2116
 8910 021c 19       		.uleb128 0x19
 8911 021d 01       		.uleb128 0x1
 8912 021e 13       		.uleb128 0x13
 8913 021f 00       		.byte	0
 8914 0220 00       		.byte	0
 8915 0221 29       		.uleb128 0x29
 8916 0222 1D       		.uleb128 0x1d
 8917 0223 01       		.byte	0x1
 8918 0224 31       		.uleb128 0x31
 8919 0225 13       		.uleb128 0x13
 8920 0226 11       		.uleb128 0x11
 8921 0227 01       		.uleb128 0x1
 8922 0228 12       		.uleb128 0x12
 8923 0229 06       		.uleb128 0x6
 8924 022a 58       		.uleb128 0x58
 8925 022b 0B       		.uleb128 0xb
 8926 022c 59       		.uleb128 0x59
 8927 022d 05       		.uleb128 0x5
 8928 022e 01       		.uleb128 0x1
 8929 022f 13       		.uleb128 0x13
 8930 0230 00       		.byte	0
 8931 0231 00       		.byte	0
 8932 0232 2A       		.uleb128 0x2a
 8933 0233 0B       		.uleb128 0xb
 8934 0234 01       		.byte	0x1
 8935 0235 11       		.uleb128 0x11
 8936 0236 01       		.uleb128 0x1
 8937 0237 12       		.uleb128 0x12
 8938 0238 06       		.uleb128 0x6
 8939 0239 00       		.byte	0
 8940 023a 00       		.byte	0
 8941 023b 2B       		.uleb128 0x2b
 8942 023c 34       		.uleb128 0x34
 8943 023d 00       		.byte	0
 8944 023e 31       		.uleb128 0x31
 8945 023f 13       		.uleb128 0x13
 8946 0240 02       		.uleb128 0x2
 8947 0241 18       		.uleb128 0x18
 8948 0242 00       		.byte	0
 8949 0243 00       		.byte	0
 8950 0244 2C       		.uleb128 0x2c
 8951 0245 1D       		.uleb128 0x1d
 8952 0246 01       		.byte	0x1
 8953 0247 31       		.uleb128 0x31
 8954 0248 13       		.uleb128 0x13
 8955 0249 11       		.uleb128 0x11
 8956 024a 01       		.uleb128 0x1
ARM GAS  /tmp/cckqXCjj.s 			page 256


 8957 024b 12       		.uleb128 0x12
 8958 024c 06       		.uleb128 0x6
 8959 024d 58       		.uleb128 0x58
 8960 024e 0B       		.uleb128 0xb
 8961 024f 59       		.uleb128 0x59
 8962 0250 05       		.uleb128 0x5
 8963 0251 00       		.byte	0
 8964 0252 00       		.byte	0
 8965 0253 2D       		.uleb128 0x2d
 8966 0254 05       		.uleb128 0x5
 8967 0255 00       		.byte	0
 8968 0256 31       		.uleb128 0x31
 8969 0257 13       		.uleb128 0x13
 8970 0258 02       		.uleb128 0x2
 8971 0259 18       		.uleb128 0x18
 8972 025a 00       		.byte	0
 8973 025b 00       		.byte	0
 8974 025c 2E       		.uleb128 0x2e
 8975 025d 2E       		.uleb128 0x2e
 8976 025e 01       		.byte	0x1
 8977 025f 3F       		.uleb128 0x3f
 8978 0260 19       		.uleb128 0x19
 8979 0261 03       		.uleb128 0x3
 8980 0262 0E       		.uleb128 0xe
 8981 0263 3A       		.uleb128 0x3a
 8982 0264 0B       		.uleb128 0xb
 8983 0265 3B       		.uleb128 0x3b
 8984 0266 05       		.uleb128 0x5
 8985 0267 27       		.uleb128 0x27
 8986 0268 19       		.uleb128 0x19
 8987 0269 49       		.uleb128 0x49
 8988 026a 13       		.uleb128 0x13
 8989 026b 11       		.uleb128 0x11
 8990 026c 01       		.uleb128 0x1
 8991 026d 12       		.uleb128 0x12
 8992 026e 06       		.uleb128 0x6
 8993 026f 40       		.uleb128 0x40
 8994 0270 18       		.uleb128 0x18
 8995 0271 9742     		.uleb128 0x2117
 8996 0273 19       		.uleb128 0x19
 8997 0274 01       		.uleb128 0x1
 8998 0275 13       		.uleb128 0x13
 8999 0276 00       		.byte	0
 9000 0277 00       		.byte	0
 9001 0278 2F       		.uleb128 0x2f
 9002 0279 2E       		.uleb128 0x2e
 9003 027a 01       		.byte	0x1
 9004 027b 03       		.uleb128 0x3
 9005 027c 0E       		.uleb128 0xe
 9006 027d 3A       		.uleb128 0x3a
 9007 027e 0B       		.uleb128 0xb
 9008 027f 3B       		.uleb128 0x3b
 9009 0280 05       		.uleb128 0x5
 9010 0281 27       		.uleb128 0x27
 9011 0282 19       		.uleb128 0x19
 9012 0283 11       		.uleb128 0x11
 9013 0284 01       		.uleb128 0x1
ARM GAS  /tmp/cckqXCjj.s 			page 257


 9014 0285 12       		.uleb128 0x12
 9015 0286 06       		.uleb128 0x6
 9016 0287 40       		.uleb128 0x40
 9017 0288 18       		.uleb128 0x18
 9018 0289 9742     		.uleb128 0x2117
 9019 028b 19       		.uleb128 0x19
 9020 028c 01       		.uleb128 0x1
 9021 028d 13       		.uleb128 0x13
 9022 028e 00       		.byte	0
 9023 028f 00       		.byte	0
 9024 0290 30       		.uleb128 0x30
 9025 0291 2E       		.uleb128 0x2e
 9026 0292 00       		.byte	0
 9027 0293 3F       		.uleb128 0x3f
 9028 0294 19       		.uleb128 0x19
 9029 0295 03       		.uleb128 0x3
 9030 0296 0E       		.uleb128 0xe
 9031 0297 3A       		.uleb128 0x3a
 9032 0298 0B       		.uleb128 0xb
 9033 0299 3B       		.uleb128 0x3b
 9034 029a 05       		.uleb128 0x5
 9035 029b 27       		.uleb128 0x27
 9036 029c 19       		.uleb128 0x19
 9037 029d 11       		.uleb128 0x11
 9038 029e 01       		.uleb128 0x1
 9039 029f 12       		.uleb128 0x12
 9040 02a0 06       		.uleb128 0x6
 9041 02a1 40       		.uleb128 0x40
 9042 02a2 18       		.uleb128 0x18
 9043 02a3 9742     		.uleb128 0x2117
 9044 02a5 19       		.uleb128 0x19
 9045 02a6 00       		.byte	0
 9046 02a7 00       		.byte	0
 9047 02a8 31       		.uleb128 0x31
 9048 02a9 2E       		.uleb128 0x2e
 9049 02aa 01       		.byte	0x1
 9050 02ab 3F       		.uleb128 0x3f
 9051 02ac 19       		.uleb128 0x19
 9052 02ad 03       		.uleb128 0x3
 9053 02ae 0E       		.uleb128 0xe
 9054 02af 3A       		.uleb128 0x3a
 9055 02b0 0B       		.uleb128 0xb
 9056 02b1 3B       		.uleb128 0x3b
 9057 02b2 05       		.uleb128 0x5
 9058 02b3 27       		.uleb128 0x27
 9059 02b4 19       		.uleb128 0x19
 9060 02b5 11       		.uleb128 0x11
 9061 02b6 01       		.uleb128 0x1
 9062 02b7 12       		.uleb128 0x12
 9063 02b8 06       		.uleb128 0x6
 9064 02b9 40       		.uleb128 0x40
 9065 02ba 18       		.uleb128 0x18
 9066 02bb 9742     		.uleb128 0x2117
 9067 02bd 19       		.uleb128 0x19
 9068 02be 01       		.uleb128 0x1
 9069 02bf 13       		.uleb128 0x13
 9070 02c0 00       		.byte	0
ARM GAS  /tmp/cckqXCjj.s 			page 258


 9071 02c1 00       		.byte	0
 9072 02c2 32       		.uleb128 0x32
 9073 02c3 0B       		.uleb128 0xb
 9074 02c4 01       		.byte	0x1
 9075 02c5 11       		.uleb128 0x11
 9076 02c6 01       		.uleb128 0x1
 9077 02c7 12       		.uleb128 0x12
 9078 02c8 06       		.uleb128 0x6
 9079 02c9 01       		.uleb128 0x1
 9080 02ca 13       		.uleb128 0x13
 9081 02cb 00       		.byte	0
 9082 02cc 00       		.byte	0
 9083 02cd 33       		.uleb128 0x33
 9084 02ce 2E       		.uleb128 0x2e
 9085 02cf 00       		.byte	0
 9086 02d0 3F       		.uleb128 0x3f
 9087 02d1 19       		.uleb128 0x19
 9088 02d2 03       		.uleb128 0x3
 9089 02d3 0E       		.uleb128 0xe
 9090 02d4 3A       		.uleb128 0x3a
 9091 02d5 0B       		.uleb128 0xb
 9092 02d6 3B       		.uleb128 0x3b
 9093 02d7 05       		.uleb128 0x5
 9094 02d8 27       		.uleb128 0x27
 9095 02d9 19       		.uleb128 0x19
 9096 02da 49       		.uleb128 0x49
 9097 02db 13       		.uleb128 0x13
 9098 02dc 11       		.uleb128 0x11
 9099 02dd 01       		.uleb128 0x1
 9100 02de 12       		.uleb128 0x12
 9101 02df 06       		.uleb128 0x6
 9102 02e0 40       		.uleb128 0x40
 9103 02e1 18       		.uleb128 0x18
 9104 02e2 9742     		.uleb128 0x2117
 9105 02e4 19       		.uleb128 0x19
 9106 02e5 00       		.byte	0
 9107 02e6 00       		.byte	0
 9108 02e7 34       		.uleb128 0x34
 9109 02e8 2E       		.uleb128 0x2e
 9110 02e9 01       		.byte	0x1
 9111 02ea 03       		.uleb128 0x3
 9112 02eb 0E       		.uleb128 0xe
 9113 02ec 3A       		.uleb128 0x3a
 9114 02ed 0B       		.uleb128 0xb
 9115 02ee 3B       		.uleb128 0x3b
 9116 02ef 05       		.uleb128 0x5
 9117 02f0 27       		.uleb128 0x27
 9118 02f1 19       		.uleb128 0x19
 9119 02f2 49       		.uleb128 0x49
 9120 02f3 13       		.uleb128 0x13
 9121 02f4 11       		.uleb128 0x11
 9122 02f5 01       		.uleb128 0x1
 9123 02f6 12       		.uleb128 0x12
 9124 02f7 06       		.uleb128 0x6
 9125 02f8 40       		.uleb128 0x40
 9126 02f9 18       		.uleb128 0x18
 9127 02fa 9742     		.uleb128 0x2117
ARM GAS  /tmp/cckqXCjj.s 			page 259


 9128 02fc 19       		.uleb128 0x19
 9129 02fd 01       		.uleb128 0x1
 9130 02fe 13       		.uleb128 0x13
 9131 02ff 00       		.byte	0
 9132 0300 00       		.byte	0
 9133 0301 35       		.uleb128 0x35
 9134 0302 34       		.uleb128 0x34
 9135 0303 00       		.byte	0
 9136 0304 03       		.uleb128 0x3
 9137 0305 08       		.uleb128 0x8
 9138 0306 3A       		.uleb128 0x3a
 9139 0307 0B       		.uleb128 0xb
 9140 0308 3B       		.uleb128 0x3b
 9141 0309 05       		.uleb128 0x5
 9142 030a 49       		.uleb128 0x49
 9143 030b 13       		.uleb128 0x13
 9144 030c 02       		.uleb128 0x2
 9145 030d 18       		.uleb128 0x18
 9146 030e 00       		.byte	0
 9147 030f 00       		.byte	0
 9148 0310 36       		.uleb128 0x36
 9149 0311 2E       		.uleb128 0x2e
 9150 0312 01       		.byte	0x1
 9151 0313 03       		.uleb128 0x3
 9152 0314 0E       		.uleb128 0xe
 9153 0315 3A       		.uleb128 0x3a
 9154 0316 0B       		.uleb128 0xb
 9155 0317 3B       		.uleb128 0x3b
 9156 0318 0B       		.uleb128 0xb
 9157 0319 27       		.uleb128 0x27
 9158 031a 19       		.uleb128 0x19
 9159 031b 20       		.uleb128 0x20
 9160 031c 0B       		.uleb128 0xb
 9161 031d 01       		.uleb128 0x1
 9162 031e 13       		.uleb128 0x13
 9163 031f 00       		.byte	0
 9164 0320 00       		.byte	0
 9165 0321 37       		.uleb128 0x37
 9166 0322 05       		.uleb128 0x5
 9167 0323 00       		.byte	0
 9168 0324 03       		.uleb128 0x3
 9169 0325 0E       		.uleb128 0xe
 9170 0326 3A       		.uleb128 0x3a
 9171 0327 0B       		.uleb128 0xb
 9172 0328 3B       		.uleb128 0x3b
 9173 0329 0B       		.uleb128 0xb
 9174 032a 49       		.uleb128 0x49
 9175 032b 13       		.uleb128 0x13
 9176 032c 00       		.byte	0
 9177 032d 00       		.byte	0
 9178 032e 38       		.uleb128 0x38
 9179 032f 2E       		.uleb128 0x2e
 9180 0330 01       		.byte	0x1
 9181 0331 03       		.uleb128 0x3
 9182 0332 0E       		.uleb128 0xe
 9183 0333 3A       		.uleb128 0x3a
 9184 0334 0B       		.uleb128 0xb
ARM GAS  /tmp/cckqXCjj.s 			page 260


 9185 0335 3B       		.uleb128 0x3b
 9186 0336 0B       		.uleb128 0xb
 9187 0337 27       		.uleb128 0x27
 9188 0338 19       		.uleb128 0x19
 9189 0339 49       		.uleb128 0x49
 9190 033a 13       		.uleb128 0x13
 9191 033b 20       		.uleb128 0x20
 9192 033c 0B       		.uleb128 0xb
 9193 033d 01       		.uleb128 0x1
 9194 033e 13       		.uleb128 0x13
 9195 033f 00       		.byte	0
 9196 0340 00       		.byte	0
 9197 0341 39       		.uleb128 0x39
 9198 0342 34       		.uleb128 0x34
 9199 0343 00       		.byte	0
 9200 0344 03       		.uleb128 0x3
 9201 0345 0E       		.uleb128 0xe
 9202 0346 3A       		.uleb128 0x3a
 9203 0347 0B       		.uleb128 0xb
 9204 0348 3B       		.uleb128 0x3b
 9205 0349 0B       		.uleb128 0xb
 9206 034a 49       		.uleb128 0x49
 9207 034b 13       		.uleb128 0x13
 9208 034c 00       		.byte	0
 9209 034d 00       		.byte	0
 9210 034e 3A       		.uleb128 0x3a
 9211 034f 2E       		.uleb128 0x2e
 9212 0350 01       		.byte	0x1
 9213 0351 03       		.uleb128 0x3
 9214 0352 0E       		.uleb128 0xe
 9215 0353 3A       		.uleb128 0x3a
 9216 0354 0B       		.uleb128 0xb
 9217 0355 3B       		.uleb128 0x3b
 9218 0356 0B       		.uleb128 0xb
 9219 0357 27       		.uleb128 0x27
 9220 0358 19       		.uleb128 0x19
 9221 0359 49       		.uleb128 0x49
 9222 035a 13       		.uleb128 0x13
 9223 035b 20       		.uleb128 0x20
 9224 035c 0B       		.uleb128 0xb
 9225 035d 00       		.byte	0
 9226 035e 00       		.byte	0
 9227 035f 00       		.byte	0
 9228              		.section	.debug_aranges,"",%progbits
 9229 0000 1C000000 		.4byte	0x1c
 9230 0004 0200     		.2byte	0x2
 9231 0006 00000000 		.4byte	.Ldebug_info0
 9232 000a 04       		.byte	0x4
 9233 000b 00       		.byte	0
 9234 000c 0000     		.2byte	0
 9235 000e 0000     		.2byte	0
 9236 0010 00000000 		.4byte	.Ltext0
 9237 0014 1C170000 		.4byte	.Letext0-.Ltext0
 9238 0018 00000000 		.4byte	0
 9239 001c 00000000 		.4byte	0
 9240              		.section	.debug_line,"",%progbits
 9241              	.Ldebug_line0:
ARM GAS  /tmp/cckqXCjj.s 			page 261


 9242 0000 54060000 		.section	.debug_str,"MS",%progbits,1
 9242      02006301 
 9242      00000201 
 9242      FB0E0D00 
 9242      01010101 
 9243              	.LASF153:
 9244 0000 70635461 		.ascii	"pcTaskName\000"
 9244      736B4E61 
 9244      6D6500
 9245              	.LASF139:
 9246 000b 75784E75 		.ascii	"uxNumberOfItems\000"
 9246      6D626572 
 9246      4F664974 
 9246      656D7300 
 9247              	.LASF263:
 9248 001b 76546173 		.ascii	"vTaskEndScheduler\000"
 9248      6B456E64 
 9248      53636865 
 9248      64756C65 
 9248      7200
 9249              	.LASF126:
 9250 002d 53797374 		.ascii	"SystemCoreClock\000"
 9250      656D436F 
 9250      7265436C 
 9250      6F636B00 
 9251              	.LASF303:
 9252 003d 474E5520 		.ascii	"GNU C99 6.3.1 20170620 -mthumb -mcpu=cortex-m3 -g -"
 9252      43393920 
 9252      362E332E 
 9252      31203230 
 9252      31373036 
 9253 0070 7374643D 		.ascii	"std=c99 -fno-common\000"
 9253      63393920 
 9253      2D666E6F 
 9253      2D636F6D 
 9253      6D6F6E00 
 9254              	.LASF41:
 9255 0084 5F6F6E5F 		.ascii	"_on_exit_args\000"
 9255      65786974 
 9255      5F617267 
 9255      7300
 9256              	.LASF151:
 9257 0092 75785072 		.ascii	"uxPriority\000"
 9257      696F7269 
 9257      747900
 9258              	.LASF246:
 9259 009d 7078436F 		.ascii	"pxConstList\000"
 9259      6E73744C 
 9259      69737400 
 9260              	.LASF108:
 9261 00a9 5F776374 		.ascii	"_wctomb_state\000"
 9261      6F6D625F 
 9261      73746174 
 9261      6500
 9262              	.LASF147:
 9263 00b7 74736B54 		.ascii	"tskTaskControlBlock\000"
 9263      61736B43 
ARM GAS  /tmp/cckqXCjj.s 			page 262


 9263      6F6E7472 
 9263      6F6C426C 
 9263      6F636B00 
 9264              	.LASF216:
 9265 00cb 756C4269 		.ascii	"ulBitsToClearOnExit\000"
 9265      7473546F 
 9265      436C6561 
 9265      724F6E45 
 9265      78697400 
 9266              	.LASF105:
 9267 00df 5F723438 		.ascii	"_r48\000"
 9267      00
 9268              	.LASF306:
 9269 00e4 75785461 		.ascii	"uxTaskGetNumberOfTasks\000"
 9269      736B4765 
 9269      744E756D 
 9269      6265724F 
 9269      66546173 
 9270              	.LASF222:
 9271 00fb 78546173 		.ascii	"xTaskGetSchedulerState\000"
 9271      6B476574 
 9271      53636865 
 9271      64756C65 
 9271      72537461 
 9272              	.LASF206:
 9273 0112 70784869 		.ascii	"pxHigherPriorityTaskWoken\000"
 9273      67686572 
 9273      5072696F 
 9273      72697479 
 9273      5461736B 
 9274              	.LASF156:
 9275 012c 654E6F41 		.ascii	"eNoAction\000"
 9275      6374696F 
 9275      6E00
 9276              	.LASF185:
 9277 0136 7578546F 		.ascii	"uxTopReadyPriority\000"
 9277      70526561 
 9277      64795072 
 9277      696F7269 
 9277      747900
 9278              	.LASF276:
 9279 0149 75785461 		.ascii	"uxTaskPriorityGet\000"
 9279      736B5072 
 9279      696F7269 
 9279      74794765 
 9279      7400
 9280              	.LASF110:
 9281 015b 5F736967 		.ascii	"_signal_buf\000"
 9281      6E616C5F 
 9281      62756600 
 9282              	.LASF0:
 9283 0167 756E7369 		.ascii	"unsigned int\000"
 9283      676E6564 
 9283      20696E74 
 9283      00
 9284              	.LASF241:
 9285 0174 70784576 		.ascii	"pxEventList\000"
ARM GAS  /tmp/cckqXCjj.s 			page 263


 9285      656E744C 
 9285      69737400 
 9286              	.LASF186:
 9287 0180 78536368 		.ascii	"xSchedulerRunning\000"
 9287      6564756C 
 9287      65725275 
 9287      6E6E696E 
 9287      6700
 9288              	.LASF140:
 9289 0192 7078496E 		.ascii	"pxIndex\000"
 9289      64657800 
 9290              	.LASF128:
 9291 019a 53746163 		.ascii	"StackType_t\000"
 9291      6B547970 
 9291      655F7400 
 9292              	.LASF162:
 9293 01a6 7854494D 		.ascii	"xTIME_OUT\000"
 9293      455F4F55 
 9293      5400
 9294              	.LASF199:
 9295 01b0 756C4269 		.ascii	"ulBitsToClear\000"
 9295      7473546F 
 9295      436C6561 
 9295      7200
 9296              	.LASF55:
 9297 01be 5F6C6266 		.ascii	"_lbfsize\000"
 9297      73697A65 
 9297      00
 9298              	.LASF53:
 9299 01c7 5F666C61 		.ascii	"_flags\000"
 9299      677300
 9300              	.LASF260:
 9301 01ce 7850656E 		.ascii	"xPendedCounts\000"
 9301      64656443 
 9301      6F756E74 
 9301      7300
 9302              	.LASF132:
 9303 01dc 784C4953 		.ascii	"xLIST_ITEM\000"
 9303      545F4954 
 9303      454D00
 9304              	.LASF174:
 9305 01e7 70785265 		.ascii	"pxReadyTasksLists\000"
 9305      61647954 
 9305      61736B73 
 9305      4C697374 
 9305      7300
 9306              	.LASF70:
 9307 01f9 5F657272 		.ascii	"_errno\000"
 9307      6E6F00
 9308              	.LASF169:
 9309 0200 756C5061 		.ascii	"ulParameters\000"
 9309      72616D65 
 9309      74657273 
 9309      00
 9310              	.LASF236:
 9311 020d 76546173 		.ascii	"vTaskSetTimeOutState\000"
 9311      6B536574 
ARM GAS  /tmp/cckqXCjj.s 			page 264


 9311      54696D65 
 9311      4F757453 
 9311      74617465 
 9312              	.LASF209:
 9313 0222 78546173 		.ascii	"xTaskGenericNotifyFromISR\000"
 9313      6B47656E 
 9313      65726963 
 9313      4E6F7469 
 9313      66794672 
 9314              	.LASF247:
 9315 023c 78546173 		.ascii	"xTaskIncrementTick\000"
 9315      6B496E63 
 9315      72656D65 
 9315      6E745469 
 9315      636B00
 9316              	.LASF13:
 9317 024f 5F4C4F43 		.ascii	"_LOCK_RECURSIVE_T\000"
 9317      4B5F5245 
 9317      43555253 
 9317      4956455F 
 9317      5400
 9318              	.LASF301:
 9319 0261 756C4269 		.ascii	"ulBitmap\000"
 9319      746D6170 
 9319      00
 9320              	.LASF57:
 9321 026a 5F726561 		.ascii	"_read\000"
 9321      6400
 9322              	.LASF175:
 9323 0270 7844656C 		.ascii	"xDelayedTaskList1\000"
 9323      61796564 
 9323      5461736B 
 9323      4C697374 
 9323      3100
 9324              	.LASF176:
 9325 0282 7844656C 		.ascii	"xDelayedTaskList2\000"
 9325      61796564 
 9325      5461736B 
 9325      4C697374 
 9325      3200
 9326              	.LASF112:
 9327 0294 5F6D6272 		.ascii	"_mbrlen_state\000"
 9327      6C656E5F 
 9327      73746174 
 9327      6500
 9328              	.LASF163:
 9329 02a2 784F7665 		.ascii	"xOverflowCount\000"
 9329      72666C6F 
 9329      77436F75 
 9329      6E7400
 9330              	.LASF297:
 9331 02b1 76506F72 		.ascii	"vPortSetBASEPRI\000"
 9331      74536574 
 9331      42415345 
 9331      50524900 
 9332              	.LASF72:
 9333 02c1 5F737464 		.ascii	"_stdout\000"
ARM GAS  /tmp/cckqXCjj.s 			page 265


 9333      6F757400 
 9334              	.LASF250:
 9335 02c9 78546173 		.ascii	"xTaskCatchUpTicks\000"
 9335      6B436174 
 9335      63685570 
 9335      5469636B 
 9335      7300
 9336              	.LASF15:
 9337 02db 5F66706F 		.ascii	"_fpos_t\000"
 9337      735F7400 
 9338              	.LASF48:
 9339 02e3 5F666E73 		.ascii	"_fns\000"
 9339      00
 9340              	.LASF266:
 9341 02e8 78546173 		.ascii	"xTaskToResume\000"
 9341      6B546F52 
 9341      6573756D 
 9341      6500
 9342              	.LASF56:
 9343 02f6 5F636F6F 		.ascii	"_cookie\000"
 9343      6B696500 
 9344              	.LASF196:
 9345 02fe 7854696D 		.ascii	"xTimeToWake\000"
 9345      65546F57 
 9345      616B6500 
 9346              	.LASF221:
 9347 030a 75785265 		.ascii	"uxReturn\000"
 9347      7475726E 
 9347      00
 9348              	.LASF30:
 9349 0313 5F426967 		.ascii	"_Bigint\000"
 9349      696E7400 
 9350              	.LASF38:
 9351 031b 5F5F746D 		.ascii	"__tm_wday\000"
 9351      5F776461 
 9351      7900
 9352              	.LASF80:
 9353 0325 5F726573 		.ascii	"_result\000"
 9353      756C7400 
 9354              	.LASF208:
 9355 032d 75785361 		.ascii	"uxSavedInterruptStatus\000"
 9355      76656449 
 9355      6E746572 
 9355      72757074 
 9355      53746174 
 9356              	.LASF125:
 9357 0344 75696E74 		.ascii	"uint32_t\000"
 9357      33325F74 
 9357      00
 9358              	.LASF307:
 9359 034d 70727654 		.ascii	"prvTaskIsTaskSuspended\000"
 9359      61736B49 
 9359      73546173 
 9359      6B537573 
 9359      70656E64 
 9360              	.LASF34:
 9361 0364 5F5F746D 		.ascii	"__tm_hour\000"
ARM GAS  /tmp/cckqXCjj.s 			page 266


 9361      5F686F75 
 9361      7200
 9362              	.LASF155:
 9363 036e 75634E6F 		.ascii	"ucNotifyState\000"
 9363      74696679 
 9363      53746174 
 9363      6500
 9364              	.LASF252:
 9365 037c 78596965 		.ascii	"xYieldRequired\000"
 9365      6C645265 
 9365      71756972 
 9365      656400
 9366              	.LASF71:
 9367 038b 5F737464 		.ascii	"_stdin\000"
 9367      696E00
 9368              	.LASF295:
 9369 0392 756C4F72 		.ascii	"ulOriginalBASEPRI\000"
 9369      6967696E 
 9369      616C4241 
 9369      53455052 
 9369      4900
 9370              	.LASF20:
 9371 03a4 5F5F636F 		.ascii	"__count\000"
 9371      756E7400 
 9372              	.LASF213:
 9373 03ac 78546173 		.ascii	"xTaskGenericNotify\000"
 9373      6B47656E 
 9373      65726963 
 9373      4E6F7469 
 9373      667900
 9374              	.LASF193:
 9375 03bf 75785363 		.ascii	"uxSchedulerSuspended\000"
 9375      68656475 
 9375      6C657253 
 9375      75737065 
 9375      6E646564 
 9376              	.LASF239:
 9377 03d4 7078556E 		.ascii	"pxUnblockedTCB\000"
 9377      626C6F63 
 9377      6B656454 
 9377      434200
 9378              	.LASF33:
 9379 03e3 5F5F746D 		.ascii	"__tm_min\000"
 9379      5F6D696E 
 9379      00
 9380              	.LASF121:
 9381 03ec 5F696D70 		.ascii	"_impure_ptr\000"
 9381      7572655F 
 9381      70747200 
 9382              	.LASF118:
 9383 03f8 5F6E6578 		.ascii	"_nextf\000"
 9383      746600
 9384              	.LASF95:
 9385 03ff 5F72616E 		.ascii	"_rand48\000"
 9385      64343800 
 9386              	.LASF233:
 9387 0407 78456C61 		.ascii	"xElapsedTime\000"
ARM GAS  /tmp/cckqXCjj.s 			page 267


 9387      70736564 
 9387      54696D65 
 9387      00
 9388              	.LASF159:
 9389 0414 65536574 		.ascii	"eSetValueWithOverwrite\000"
 9389      56616C75 
 9389      65576974 
 9389      684F7665 
 9389      72777269 
 9390              	.LASF81:
 9391 042b 5F726573 		.ascii	"_result_k\000"
 9391      756C745F 
 9391      6B00
 9392              	.LASF12:
 9393 0435 6C6F6E67 		.ascii	"long long unsigned int\000"
 9393      206C6F6E 
 9393      6720756E 
 9393      7369676E 
 9393      65642069 
 9394              	.LASF255:
 9395 044c 78546173 		.ascii	"xTaskGetTickCountFromISR\000"
 9395      6B476574 
 9395      5469636B 
 9395      436F756E 
 9395      7446726F 
 9396              	.LASF101:
 9397 0465 5F617363 		.ascii	"_asctime_buf\000"
 9397      74696D65 
 9397      5F627566 
 9397      00
 9398              	.LASF215:
 9399 0472 756C4269 		.ascii	"ulBitsToClearOnEntry\000"
 9399      7473546F 
 9399      436C6561 
 9399      724F6E45 
 9399      6E747279 
 9400              	.LASF52:
 9401 0487 5F5F7346 		.ascii	"__sFILE\000"
 9401      494C4500 
 9402              	.LASF29:
 9403 048f 5F776473 		.ascii	"_wds\000"
 9403      00
 9404              	.LASF179:
 9405 0494 7850656E 		.ascii	"xPendingReadyList\000"
 9405      64696E67 
 9405      52656164 
 9405      794C6973 
 9405      7400
 9406              	.LASF227:
 9407 04a6 70727649 		.ascii	"prvInitialiseTaskLists\000"
 9407      6E697469 
 9407      616C6973 
 9407      65546173 
 9407      6B4C6973 
 9408              	.LASF135:
 9409 04bd 70785072 		.ascii	"pxPrevious\000"
 9409      6576696F 
ARM GAS  /tmp/cckqXCjj.s 			page 268


 9409      757300
 9410              	.LASF180:
 9411 04c8 78546173 		.ascii	"xTasksWaitingTermination\000"
 9411      6B735761 
 9411      6974696E 
 9411      67546572 
 9411      6D696E61 
 9412              	.LASF6:
 9413 04e1 5F5F7569 		.ascii	"__uint16_t\000"
 9413      6E743136 
 9413      5F7400
 9414              	.LASF91:
 9415 04ec 5F5F4649 		.ascii	"__FILE\000"
 9415      4C4500
 9416              	.LASF249:
 9417 04f3 70785465 		.ascii	"pxTemp\000"
 9417      6D7000
 9418              	.LASF64:
 9419 04fa 5F6F6666 		.ascii	"_offset\000"
 9419      73657400 
 9420              	.LASF262:
 9421 0502 76546173 		.ascii	"vTaskSuspendAll\000"
 9421      6B537573 
 9421      70656E64 
 9421      416C6C00 
 9422              	.LASF75:
 9423 0512 5F656D65 		.ascii	"_emergency\000"
 9423      7267656E 
 9423      637900
 9424              	.LASF161:
 9425 051d 654E6F74 		.ascii	"eNotifyAction\000"
 9425      69667941 
 9425      6374696F 
 9425      6E00
 9426              	.LASF2:
 9427 052b 73697A65 		.ascii	"size_t\000"
 9427      5F7400
 9428              	.LASF171:
 9429 0532 74736B54 		.ascii	"tskTCB\000"
 9429      434200
 9430              	.LASF32:
 9431 0539 5F5F746D 		.ascii	"__tm_sec\000"
 9431      5F736563 
 9431      00
 9432              	.LASF158:
 9433 0542 65496E63 		.ascii	"eIncrement\000"
 9433      72656D65 
 9433      6E7400
 9434              	.LASF39:
 9435 054d 5F5F746D 		.ascii	"__tm_yday\000"
 9435      5F796461 
 9435      7900
 9436              	.LASF74:
 9437 0557 5F696E63 		.ascii	"_inc\000"
 9437      00
 9438              	.LASF47:
 9439 055c 5F696E64 		.ascii	"_ind\000"
ARM GAS  /tmp/cckqXCjj.s 			page 269


 9439      00
 9440              	.LASF181:
 9441 0561 75784465 		.ascii	"uxDeletedTasksWaitingCleanUp\000"
 9441      6C657465 
 9441      64546173 
 9441      6B735761 
 9441      6974696E 
 9442              	.LASF184:
 9443 057e 78546963 		.ascii	"xTickCount\000"
 9443      6B436F75 
 9443      6E7400
 9444              	.LASF138:
 9445 0589 784C4953 		.ascii	"xLIST\000"
 9445      5400
 9446              	.LASF143:
 9447 058f 784D494E 		.ascii	"xMINI_LIST_ITEM\000"
 9447      495F4C49 
 9447      53545F49 
 9447      54454D00 
 9448              	.LASF26:
 9449 059f 5F6E6578 		.ascii	"_next\000"
 9449      7400
 9450              	.LASF197:
 9451 05a5 78436F6E 		.ascii	"xConstTickCount\000"
 9451      73745469 
 9451      636B436F 
 9451      756E7400 
 9452              	.LASF114:
 9453 05b5 5F6D6273 		.ascii	"_mbsrtowcs_state\000"
 9453      72746F77 
 9453      63735F73 
 9453      74617465 
 9453      00
 9454              	.LASF182:
 9455 05c6 78537573 		.ascii	"xSuspendedTaskList\000"
 9455      70656E64 
 9455      65645461 
 9455      736B4C69 
 9455      737400
 9456              	.LASF289:
 9457 05d9 70634E61 		.ascii	"pcName\000"
 9457      6D6500
 9458              	.LASF178:
 9459 05e0 70784F76 		.ascii	"pxOverflowDelayedTaskList\000"
 9459      6572666C 
 9459      6F774465 
 9459      6C617965 
 9459      64546173 
 9460              	.LASF204:
 9461 05fa 78526574 		.ascii	"xReturn\000"
 9461      75726E00 
 9462              	.LASF203:
 9463 0602 78546173 		.ascii	"xTaskNotifyStateClear\000"
 9463      6B4E6F74 
 9463      69667953 
 9463      74617465 
 9463      436C6561 
ARM GAS  /tmp/cckqXCjj.s 			page 270


 9464              	.LASF277:
 9465 0618 76546173 		.ascii	"vTaskDelay\000"
 9465      6B44656C 
 9465      617900
 9466              	.LASF21:
 9467 0623 5F5F7661 		.ascii	"__value\000"
 9467      6C756500 
 9468              	.LASF82:
 9469 062b 5F703573 		.ascii	"_p5s\000"
 9469      00
 9470              	.LASF154:
 9471 0630 756C4E6F 		.ascii	"ulNotifiedValue\000"
 9471      74696669 
 9471      65645661 
 9471      6C756500 
 9472              	.LASF237:
 9473 0640 76546173 		.ascii	"vTaskRemoveFromUnorderedEventList\000"
 9473      6B52656D 
 9473      6F766546 
 9473      726F6D55 
 9473      6E6F7264 
 9474              	.LASF116:
 9475 0662 5F776373 		.ascii	"_wcsrtombs_state\000"
 9475      72746F6D 
 9475      62735F73 
 9475      74617465 
 9475      00
 9476              	.LASF106:
 9477 0673 5F6D626C 		.ascii	"_mblen_state\000"
 9477      656E5F73 
 9477      74617465 
 9477      00
 9478              	.LASF240:
 9479 0680 78546173 		.ascii	"xTaskRemoveFromEventList\000"
 9479      6B52656D 
 9479      6F766546 
 9479      726F6D45 
 9479      76656E74 
 9480              	.LASF24:
 9481 0699 63686172 		.ascii	"char\000"
 9481      00
 9482              	.LASF35:
 9483 069e 5F5F746D 		.ascii	"__tm_mday\000"
 9483      5F6D6461 
 9483      7900
 9484              	.LASF142:
 9485 06a8 4C697374 		.ascii	"ListItem_t\000"
 9485      4974656D 
 9485      5F7400
 9486              	.LASF88:
 9487 06b3 5F736967 		.ascii	"_sig_func\000"
 9487      5F66756E 
 9487      6300
 9488              	.LASF113:
 9489 06bd 5F6D6272 		.ascii	"_mbrtowc_state\000"
 9489      746F7763 
 9489      5F737461 
ARM GAS  /tmp/cckqXCjj.s 			page 271


 9489      746500
 9490              	.LASF87:
 9491 06cc 5F617465 		.ascii	"_atexit0\000"
 9491      78697430 
 9491      00
 9492              	.LASF160:
 9493 06d5 65536574 		.ascii	"eSetValueWithoutOverwrite\000"
 9493      56616C75 
 9493      65576974 
 9493      686F7574 
 9493      4F766572 
 9494              	.LASF214:
 9495 06ef 78546173 		.ascii	"xTaskNotifyWait\000"
 9495      6B4E6F74 
 9495      69667957 
 9495      61697400 
 9496              	.LASF130:
 9497 06ff 55426173 		.ascii	"UBaseType_t\000"
 9497      65547970 
 9497      655F7400 
 9498              	.LASF290:
 9499 070b 756C5374 		.ascii	"ulStackDepth\000"
 9499      61636B44 
 9499      65707468 
 9499      00
 9500              	.LASF282:
 9501 0718 7853686F 		.ascii	"xShouldDelay\000"
 9501      756C6444 
 9501      656C6179 
 9501      00
 9502              	.LASF228:
 9503 0725 70727649 		.ascii	"prvIdleTask\000"
 9503      646C6554 
 9503      61736B00 
 9504              	.LASF157:
 9505 0731 65536574 		.ascii	"eSetBits\000"
 9505      42697473 
 9505      00
 9506              	.LASF141:
 9507 073a 784C6973 		.ascii	"xListEnd\000"
 9507      74456E64 
 9507      00
 9508              	.LASF218:
 9509 0743 756C5461 		.ascii	"ulTaskNotifyTake\000"
 9509      736B4E6F 
 9509      74696679 
 9509      54616B65 
 9509      00
 9510              	.LASF23:
 9511 0754 5F666C6F 		.ascii	"_flock_t\000"
 9511      636B5F74 
 9511      00
 9512              	.LASF144:
 9513 075d 4D696E69 		.ascii	"MiniListItem_t\000"
 9513      4C697374 
 9513      4974656D 
 9513      5F7400
ARM GAS  /tmp/cckqXCjj.s 			page 272


 9514              	.LASF293:
 9515 076c 78546173 		.ascii	"xTaskCreate\000"
 9515      6B437265 
 9515      61746500 
 9516              	.LASF17:
 9517 0778 5F5F7763 		.ascii	"__wch\000"
 9517      6800
 9518              	.LASF94:
 9519 077e 5F696F62 		.ascii	"_iobs\000"
 9519      7300
 9520              	.LASF123:
 9521 0784 75696E74 		.ascii	"uint8_t\000"
 9521      385F7400 
 9522              	.LASF60:
 9523 078c 5F636C6F 		.ascii	"_close\000"
 9523      736500
 9524              	.LASF286:
 9525 0793 70784E65 		.ascii	"pxNewTCB\000"
 9525      77544342 
 9525      00
 9526              	.LASF245:
 9527 079c 7578546F 		.ascii	"uxTopPriority\000"
 9527      70507269 
 9527      6F726974 
 9527      7900
 9528              	.LASF78:
 9529 07aa 5F5F7364 		.ascii	"__sdidinit\000"
 9529      6964696E 
 9529      697400
 9530              	.LASF288:
 9531 07b5 70785461 		.ascii	"pxTaskCode\000"
 9531      736B436F 
 9531      646500
 9532              	.LASF170:
 9533 07c0 4D656D6F 		.ascii	"MemoryRegion_t\000"
 9533      72795265 
 9533      67696F6E 
 9533      5F7400
 9534              	.LASF191:
 9535 07cf 784E6578 		.ascii	"xNextTaskUnblockTime\000"
 9535      74546173 
 9535      6B556E62 
 9535      6C6F636B 
 9535      54696D65 
 9536              	.LASF308:
 9537 07e4 756C506F 		.ascii	"ulPortRaiseBASEPRI\000"
 9537      72745261 
 9537      69736542 
 9537      41534550 
 9537      524900
 9538              	.LASF294:
 9539 07f7 75735374 		.ascii	"usStackDepth\000"
 9539      61636B44 
 9539      65707468 
 9539      00
 9540              	.LASF305:
 9541 0804 2F686F6D 		.ascii	"/home/sls/workspace/stm32f103c8-blink\000"
ARM GAS  /tmp/cckqXCjj.s 			page 273


 9541      652F736C 
 9541      732F776F 
 9541      726B7370 
 9541      6163652F 
 9542              	.LASF103:
 9543 082a 5F67616D 		.ascii	"_gamma_signgam\000"
 9543      6D615F73 
 9543      69676E67 
 9543      616D00
 9544              	.LASF11:
 9545 0839 6C6F6E67 		.ascii	"long long int\000"
 9545      206C6F6E 
 9545      6720696E 
 9545      7400
 9546              	.LASF50:
 9547 0847 5F626173 		.ascii	"_base\000"
 9547      6500
 9548              	.LASF83:
 9549 084d 5F667265 		.ascii	"_freelist\000"
 9549      656C6973 
 9549      7400
 9550              	.LASF201:
 9551 0857 756C5265 		.ascii	"ulReturn\000"
 9551      7475726E 
 9551      00
 9552              	.LASF97:
 9553 0860 5F6D756C 		.ascii	"_mult\000"
 9553      7400
 9554              	.LASF299:
 9555 0866 7563506F 		.ascii	"ucPortCountLeadingZeros\000"
 9555      7274436F 
 9555      756E744C 
 9555      65616469 
 9555      6E675A65 
 9556              	.LASF25:
 9557 087e 5F5F554C 		.ascii	"__ULong\000"
 9557      6F6E6700 
 9558              	.LASF257:
 9559 0886 78546963 		.ascii	"xTicks\000"
 9559      6B7300
 9560              	.LASF296:
 9561 088d 756C4E65 		.ascii	"ulNewBASEPRI\000"
 9561      77424153 
 9561      45505249 
 9561      00
 9562              	.LASF115:
 9563 089a 5F776372 		.ascii	"_wcrtomb_state\000"
 9563      746F6D62 
 9563      5F737461 
 9563      746500
 9564              	.LASF129:
 9565 08a9 42617365 		.ascii	"BaseType_t\000"
 9565      54797065 
 9565      5F7400
 9566              	.LASF275:
 9567 08b4 75785361 		.ascii	"uxSavedInterruptState\000"
 9567      76656449 
ARM GAS  /tmp/cckqXCjj.s 			page 274


 9567      6E746572 
 9567      72757074 
 9567      53746174 
 9568              	.LASF54:
 9569 08ca 5F66696C 		.ascii	"_file\000"
 9569      6500
 9570              	.LASF224:
 9571 08d0 70727652 		.ascii	"prvResetNextTaskUnblockTime\000"
 9571      65736574 
 9571      4E657874 
 9571      5461736B 
 9571      556E626C 
 9572              	.LASF164:
 9573 08ec 7854696D 		.ascii	"xTimeOnEntering\000"
 9573      654F6E45 
 9573      6E746572 
 9573      696E6700 
 9574              	.LASF271:
 9575 08fc 75784E65 		.ascii	"uxNewPriority\000"
 9575      77507269 
 9575      6F726974 
 9575      7900
 9576              	.LASF127:
 9577 090a 5461736B 		.ascii	"TaskFunction_t\000"
 9577      46756E63 
 9577      74696F6E 
 9577      5F7400
 9578              	.LASF134:
 9579 0919 70784E65 		.ascii	"pxNext\000"
 9579      787400
 9580              	.LASF212:
 9581 0920 70756C50 		.ascii	"pulPreviousNotificationValue\000"
 9581      72657669 
 9581      6F75734E 
 9581      6F746966 
 9581      69636174 
 9582              	.LASF231:
 9583 093d 70785469 		.ascii	"pxTimeOut\000"
 9583      6D654F75 
 9583      7400
 9584              	.LASF79:
 9585 0947 5F5F636C 		.ascii	"__cleanup\000"
 9585      65616E75 
 9585      7000
 9586              	.LASF274:
 9587 0951 75785461 		.ascii	"uxTaskPriorityGetFromISR\000"
 9587      736B5072 
 9587      696F7269 
 9587      74794765 
 9587      7446726F 
 9588              	.LASF22:
 9589 096a 5F6D6273 		.ascii	"_mbstate_t\000"
 9589      74617465 
 9589      5F7400
 9590              	.LASF256:
 9591 0975 78546173 		.ascii	"xTaskGetTickCount\000"
 9591      6B476574 
ARM GAS  /tmp/cckqXCjj.s 			page 275


 9591      5469636B 
 9591      436F756E 
 9591      7400
 9592              	.LASF165:
 9593 0987 54696D65 		.ascii	"TimeOut_t\000"
 9593      4F75745F 
 9593      7400
 9594              	.LASF235:
 9595 0991 76546173 		.ascii	"vTaskInternalSetTimeOutState\000"
 9595      6B496E74 
 9595      65726E61 
 9595      6C536574 
 9595      54696D65 
 9596              	.LASF40:
 9597 09ae 5F5F746D 		.ascii	"__tm_isdst\000"
 9597      5F697364 
 9597      737400
 9598              	.LASF190:
 9599 09b9 75785461 		.ascii	"uxTaskNumber\000"
 9599      736B4E75 
 9599      6D626572 
 9599      00
 9600              	.LASF146:
 9601 09c6 5461736B 		.ascii	"TaskHandle_t\000"
 9601      48616E64 
 9601      6C655F74 
 9601      00
 9602              	.LASF211:
 9603 09d3 65416374 		.ascii	"eAction\000"
 9603      696F6E00 
 9604              	.LASF300:
 9605 09db 756C4E65 		.ascii	"ulNewMaskValue\000"
 9605      774D6173 
 9605      6B56616C 
 9605      756500
 9606              	.LASF220:
 9607 09ea 75785461 		.ascii	"uxTaskResetEventItemValue\000"
 9607      736B5265 
 9607      73657445 
 9607      76656E74 
 9607      4974656D 
 9608              	.LASF270:
 9609 0a04 76546173 		.ascii	"vTaskPrioritySet\000"
 9609      6B507269 
 9609      6F726974 
 9609      79536574 
 9609      00
 9610              	.LASF117:
 9611 0a15 5F685F65 		.ascii	"_h_errno\000"
 9611      72726E6F 
 9611      00
 9612              	.LASF145:
 9613 0a1e 4C697374 		.ascii	"List_t\000"
 9613      5F7400
 9614              	.LASF254:
 9615 0a25 78546173 		.ascii	"xTaskToQuery\000"
 9615      6B546F51 
ARM GAS  /tmp/cckqXCjj.s 			page 276


 9615      75657279 
 9615      00
 9616              	.LASF28:
 9617 0a32 5F736967 		.ascii	"_sign\000"
 9617      6E00
 9618              	.LASF131:
 9619 0a38 5469636B 		.ascii	"TickType_t\000"
 9619      54797065 
 9619      5F7400
 9620              	.LASF205:
 9621 0a43 78546173 		.ascii	"xTaskToNotify\000"
 9621      6B546F4E 
 9621      6F746966 
 9621      7900
 9622              	.LASF198:
 9623 0a51 78546173 		.ascii	"xTask\000"
 9623      6B00
 9624              	.LASF36:
 9625 0a57 5F5F746D 		.ascii	"__tm_mon\000"
 9625      5F6D6F6E 
 9625      00
 9626              	.LASF207:
 9627 0a60 75634F72 		.ascii	"ucOriginalNotifyState\000"
 9627      6967696E 
 9627      616C4E6F 
 9627      74696679 
 9627      53746174 
 9628              	.LASF166:
 9629 0a76 784D454D 		.ascii	"xMEMORY_REGION\000"
 9629      4F52595F 
 9629      52454749 
 9629      4F4E00
 9630              	.LASF124:
 9631 0a85 75696E74 		.ascii	"uint16_t\000"
 9631      31365F74 
 9631      00
 9632              	.LASF283:
 9633 0a8e 76546173 		.ascii	"vTaskDelete\000"
 9633      6B44656C 
 9633      65746500 
 9634              	.LASF58:
 9635 0a9a 5F777269 		.ascii	"_write\000"
 9635      746500
 9636              	.LASF244:
 9637 0aa1 76546173 		.ascii	"vTaskSwitchContext\000"
 9637      6B537769 
 9637      74636843 
 9637      6F6E7465 
 9637      787400
 9638              	.LASF189:
 9639 0ab4 784E756D 		.ascii	"xNumOfOverflows\000"
 9639      4F664F76 
 9639      6572666C 
 9639      6F777300 
 9640              	.LASF137:
 9641 0ac4 7076436F 		.ascii	"pvContainer\000"
 9641      6E746169 
ARM GAS  /tmp/cckqXCjj.s 			page 277


 9641      6E657200 
 9642              	.LASF173:
 9643 0ad0 70784375 		.ascii	"pxCurrentTCB\000"
 9643      7272656E 
 9643      74544342 
 9643      00
 9644              	.LASF46:
 9645 0add 5F617465 		.ascii	"_atexit\000"
 9645      78697400 
 9646              	.LASF67:
 9647 0ae5 5F6D6273 		.ascii	"_mbstate\000"
 9647      74617465 
 9647      00
 9648              	.LASF243:
 9649 0aee 76546173 		.ascii	"vTaskPlaceOnEventList\000"
 9649      6B506C61 
 9649      63654F6E 
 9649      4576656E 
 9649      744C6973 
 9650              	.LASF5:
 9651 0b04 73686F72 		.ascii	"short int\000"
 9651      7420696E 
 9651      7400
 9652              	.LASF287:
 9653 0b0e 70727649 		.ascii	"prvInitialiseNewTask\000"
 9653      6E697469 
 9653      616C6973 
 9653      654E6577 
 9653      5461736B 
 9654              	.LASF229:
 9655 0b23 70765061 		.ascii	"pvParameters\000"
 9655      72616D65 
 9655      74657273 
 9655      00
 9656              	.LASF133:
 9657 0b30 78497465 		.ascii	"xItemValue\000"
 9657      6D56616C 
 9657      756500
 9658              	.LASF8:
 9659 0b3b 6C6F6E67 		.ascii	"long int\000"
 9659      20696E74 
 9659      00
 9660              	.LASF219:
 9661 0b44 78436C65 		.ascii	"xClearCountOnExit\000"
 9661      6172436F 
 9661      756E744F 
 9661      6E457869 
 9661      7400
 9662              	.LASF152:
 9663 0b56 70785374 		.ascii	"pxStack\000"
 9663      61636B00 
 9664              	.LASF258:
 9665 0b5e 78546173 		.ascii	"xTaskResumeAll\000"
 9665      6B526573 
 9665      756D6541 
 9665      6C6C00
 9666              	.LASF234:
ARM GAS  /tmp/cckqXCjj.s 			page 278


 9667 0b6d 76546173 		.ascii	"vTaskNotifyGiveFromISR\000"
 9667      6B4E6F74 
 9667      69667947 
 9667      69766546 
 9667      726F6D49 
 9668              	.LASF177:
 9669 0b84 70784465 		.ascii	"pxDelayedTaskList\000"
 9669      6C617965 
 9669      64546173 
 9669      6B4C6973 
 9669      7400
 9670              	.LASF90:
 9671 0b96 5F5F7366 		.ascii	"__sf\000"
 9671      00
 9672              	.LASF304:
 9673 0b9b 46726565 		.ascii	"FreeRTOS/Source/tasks.c\000"
 9673      52544F53 
 9673      2F536F75 
 9673      7263652F 
 9673      7461736B 
 9674              	.LASF77:
 9675 0bb3 5F637572 		.ascii	"_current_locale\000"
 9675      72656E74 
 9675      5F6C6F63 
 9675      616C6500 
 9676              	.LASF248:
 9677 0bc3 78537769 		.ascii	"xSwitchRequired\000"
 9677      74636852 
 9677      65717569 
 9677      72656400 
 9678              	.LASF65:
 9679 0bd3 5F646174 		.ascii	"_data\000"
 9679      6100
 9680              	.LASF18:
 9681 0bd9 5F5F7763 		.ascii	"__wchb\000"
 9681      686200
 9682              	.LASF122:
 9683 0be0 5F676C6F 		.ascii	"_global_impure_ptr\000"
 9683      62616C5F 
 9683      696D7075 
 9683      72655F70 
 9683      747200
 9684              	.LASF284:
 9685 0bf3 78546173 		.ascii	"xTaskToDelete\000"
 9685      6B546F44 
 9685      656C6574 
 9685      6500
 9686              	.LASF37:
 9687 0c01 5F5F746D 		.ascii	"__tm_year\000"
 9687      5F796561 
 9687      7200
 9688              	.LASF210:
 9689 0c0b 756C5661 		.ascii	"ulValue\000"
 9689      6C756500 
 9690              	.LASF269:
 9691 0c13 78546173 		.ascii	"xTaskToSuspend\000"
 9691      6B546F53 
ARM GAS  /tmp/cckqXCjj.s 			page 279


 9691      75737065 
 9691      6E6400
 9692              	.LASF230:
 9693 0c22 78546173 		.ascii	"xTaskCheckForTimeOut\000"
 9693      6B436865 
 9693      636B466F 
 9693      7254696D 
 9693      654F7574 
 9694              	.LASF280:
 9695 0c37 70785072 		.ascii	"pxPreviousWakeTime\000"
 9695      6576696F 
 9695      75735761 
 9695      6B655469 
 9695      6D6500
 9696              	.LASF102:
 9697 0c4a 5F6C6F63 		.ascii	"_localtime_buf\000"
 9697      616C7469 
 9697      6D655F62 
 9697      756600
 9698              	.LASF120:
 9699 0c59 5F756E75 		.ascii	"_unused\000"
 9699      73656400 
 9700              	.LASF3:
 9701 0c61 5F5F7569 		.ascii	"__uint8_t\000"
 9701      6E74385F 
 9701      7400
 9702              	.LASF86:
 9703 0c6b 5F6E6577 		.ascii	"_new\000"
 9703      00
 9704              	.LASF84:
 9705 0c70 5F637674 		.ascii	"_cvtlen\000"
 9705      6C656E00 
 9706              	.LASF27:
 9707 0c78 5F6D6178 		.ascii	"_maxwds\000"
 9707      77647300 
 9708              	.LASF109:
 9709 0c80 5F6C3634 		.ascii	"_l64a_buf\000"
 9709      615F6275 
 9709      6600
 9710              	.LASF76:
 9711 0c8a 5F637572 		.ascii	"_current_category\000"
 9711      72656E74 
 9711      5F636174 
 9711      65676F72 
 9711      7900
 9712              	.LASF192:
 9713 0c9c 7849646C 		.ascii	"xIdleTaskHandle\000"
 9713      65546173 
 9713      6B48616E 
 9713      646C6500 
 9714              	.LASF168:
 9715 0cac 756C4C65 		.ascii	"ulLengthInBytes\000"
 9715      6E677468 
 9715      496E4279 
 9715      74657300 
 9716              	.LASF265:
 9717 0cbc 78546173 		.ascii	"xTaskResumeFromISR\000"
ARM GAS  /tmp/cckqXCjj.s 			page 280


 9717      6B526573 
 9717      756D6546 
 9717      726F6D49 
 9717      535200
 9718              	.LASF217:
 9719 0ccf 70756C4E 		.ascii	"pulNotificationValue\000"
 9719      6F746966 
 9719      69636174 
 9719      696F6E56 
 9719      616C7565 
 9720              	.LASF63:
 9721 0ce4 5F626C6B 		.ascii	"_blksize\000"
 9721      73697A65 
 9721      00
 9722              	.LASF31:
 9723 0ced 5F5F746D 		.ascii	"__tm\000"
 9723      00
 9724              	.LASF66:
 9725 0cf2 5F6C6F63 		.ascii	"_lock\000"
 9725      6B00
 9726              	.LASF19:
 9727 0cf8 73697A65 		.ascii	"sizetype\000"
 9727      74797065 
 9727      00
 9728              	.LASF261:
 9729 0d01 76546173 		.ascii	"vTaskMissedYield\000"
 9729      6B4D6973 
 9729      73656459 
 9729      69656C64 
 9729      00
 9730              	.LASF10:
 9731 0d12 6C6F6E67 		.ascii	"long unsigned int\000"
 9731      20756E73 
 9731      69676E65 
 9731      6420696E 
 9731      7400
 9732              	.LASF298:
 9733 0d24 76506F72 		.ascii	"vPortRaiseBASEPRI\000"
 9733      74526169 
 9733      73654241 
 9733      53455052 
 9733      4900
 9734              	.LASF93:
 9735 0d36 5F6E696F 		.ascii	"_niobs\000"
 9735      627300
 9736              	.LASF16:
 9737 0d3d 77696E74 		.ascii	"wint_t\000"
 9737      5F7400
 9738              	.LASF253:
 9739 0d44 70635461 		.ascii	"pcTaskGetName\000"
 9739      736B4765 
 9739      744E616D 
 9739      6500
 9740              	.LASF43:
 9741 0d52 5F64736F 		.ascii	"_dso_handle\000"
 9741      5F68616E 
 9741      646C6500 
ARM GAS  /tmp/cckqXCjj.s 			page 281


 9742              	.LASF264:
 9743 0d5e 76546173 		.ascii	"vTaskStartScheduler\000"
 9743      6B537461 
 9743      72745363 
 9743      68656475 
 9743      6C657200 
 9744              	.LASF226:
 9745 0d72 70727643 		.ascii	"prvCheckTasksWaitingTermination\000"
 9745      6865636B 
 9745      5461736B 
 9745      73576169 
 9745      74696E67 
 9746              	.LASF195:
 9747 0d92 7843616E 		.ascii	"xCanBlockIndefinitely\000"
 9747      426C6F63 
 9747      6B496E64 
 9747      6566696E 
 9747      6974656C 
 9748              	.LASF167:
 9749 0da8 70764261 		.ascii	"pvBaseAddress\000"
 9749      73654164 
 9749      64726573 
 9749      7300
 9750              	.LASF278:
 9751 0db6 78546963 		.ascii	"xTicksToDelay\000"
 9751      6B73546F 
 9751      44656C61 
 9751      7900
 9752              	.LASF85:
 9753 0dc4 5F637674 		.ascii	"_cvtbuf\000"
 9753      62756600 
 9754              	.LASF4:
 9755 0dcc 756E7369 		.ascii	"unsigned char\000"
 9755      676E6564 
 9755      20636861 
 9755      7200
 9756              	.LASF242:
 9757 0dda 76546173 		.ascii	"vTaskPlaceOnUnorderedEventList\000"
 9757      6B506C61 
 9757      63654F6E 
 9757      556E6F72 
 9757      64657265 
 9758              	.LASF9:
 9759 0df9 5F5F7569 		.ascii	"__uint32_t\000"
 9759      6E743332 
 9759      5F7400
 9760              	.LASF232:
 9761 0e04 70785469 		.ascii	"pxTicksToWait\000"
 9761      636B7354 
 9761      6F576169 
 9761      7400
 9762              	.LASF111:
 9763 0e12 5F676574 		.ascii	"_getdate_err\000"
 9763      64617465 
 9763      5F657272 
 9763      00
 9764              	.LASF279:
ARM GAS  /tmp/cckqXCjj.s 			page 282


 9765 0e1f 76546173 		.ascii	"vTaskDelayUntil\000"
 9765      6B44656C 
 9765      6179556E 
 9765      74696C00 
 9766              	.LASF150:
 9767 0e2f 78457665 		.ascii	"xEventListItem\000"
 9767      6E744C69 
 9767      73744974 
 9767      656D00
 9768              	.LASF98:
 9769 0e3e 5F616464 		.ascii	"_add\000"
 9769      00
 9770              	.LASF273:
 9771 0e43 75785072 		.ascii	"uxPriorityUsedOnEntry\000"
 9771      696F7269 
 9771      74795573 
 9771      65644F6E 
 9771      456E7472 
 9772              	.LASF172:
 9773 0e59 5443425F 		.ascii	"TCB_t\000"
 9773      7400
 9774              	.LASF194:
 9775 0e5f 78546963 		.ascii	"xTicksToWait\000"
 9775      6B73546F 
 9775      57616974 
 9775      00
 9776              	.LASF136:
 9777 0e6c 70764F77 		.ascii	"pvOwner\000"
 9777      6E657200 
 9778              	.LASF225:
 9779 0e74 70727644 		.ascii	"prvDeleteTCB\000"
 9779      656C6574 
 9779      65544342 
 9779      00
 9780              	.LASF268:
 9781 0e81 76546173 		.ascii	"vTaskSuspend\000"
 9781      6B537573 
 9781      70656E64 
 9781      00
 9782              	.LASF259:
 9783 0e8e 78416C72 		.ascii	"xAlreadyYielded\000"
 9783      65616479 
 9783      5969656C 
 9783      64656400 
 9784              	.LASF49:
 9785 0e9e 5F5F7362 		.ascii	"__sbuf\000"
 9785      756600
 9786              	.LASF187:
 9787 0ea5 7850656E 		.ascii	"xPendedTicks\000"
 9787      64656454 
 9787      69636B73 
 9787      00
 9788              	.LASF92:
 9789 0eb2 5F676C75 		.ascii	"_glue\000"
 9789      6500
 9790              	.LASF251:
 9791 0eb8 78546963 		.ascii	"xTicksToCatchUp\000"
ARM GAS  /tmp/cckqXCjj.s 			page 283


 9791      6B73546F 
 9791      43617463 
 9791      68557000 
 9792              	.LASF292:
 9793 0ec8 78526567 		.ascii	"xRegions\000"
 9793      696F6E73 
 9793      00
 9794              	.LASF223:
 9795 0ed1 70727641 		.ascii	"prvAddCurrentTaskToDelayedList\000"
 9795      64644375 
 9795      7272656E 
 9795      74546173 
 9795      6B546F44 
 9796              	.LASF89:
 9797 0ef0 5F5F7367 		.ascii	"__sglue\000"
 9797      6C756500 
 9798              	.LASF100:
 9799 0ef8 5F737472 		.ascii	"_strtok_last\000"
 9799      746F6B5F 
 9799      6C617374 
 9799      00
 9800              	.LASF107:
 9801 0f05 5F6D6274 		.ascii	"_mbtowc_state\000"
 9801      6F77635F 
 9801      73746174 
 9801      6500
 9802              	.LASF183:
 9803 0f13 75784375 		.ascii	"uxCurrentNumberOfTasks\000"
 9803      7272656E 
 9803      744E756D 
 9803      6265724F 
 9803      66546173 
 9804              	.LASF281:
 9805 0f2a 7854696D 		.ascii	"xTimeIncrement\000"
 9805      65496E63 
 9805      72656D65 
 9805      6E7400
 9806              	.LASF42:
 9807 0f39 5F666E61 		.ascii	"_fnargs\000"
 9807      72677300 
 9808              	.LASF1:
 9809 0f41 7369676E 		.ascii	"signed char\000"
 9809      65642063 
 9809      68617200 
 9810              	.LASF202:
 9811 0f4d 756C5461 		.ascii	"ulTaskNotifyValueClear\000"
 9811      736B4E6F 
 9811      74696679 
 9811      56616C75 
 9811      65436C65 
 9812              	.LASF69:
 9813 0f64 5F726565 		.ascii	"_reent\000"
 9813      6E7400
 9814              	.LASF7:
 9815 0f6b 73686F72 		.ascii	"short unsigned int\000"
 9815      7420756E 
 9815      7369676E 
ARM GAS  /tmp/cckqXCjj.s 			page 284


 9815      65642069 
 9815      6E7400
 9816              	.LASF149:
 9817 0f7e 78537461 		.ascii	"xStateListItem\000"
 9817      74654C69 
 9817      73744974 
 9817      656D00
 9818              	.LASF200:
 9819 0f8d 70785443 		.ascii	"pxTCB\000"
 9819      4200
 9820              	.LASF44:
 9821 0f93 5F666E74 		.ascii	"_fntypes\000"
 9821      79706573 
 9821      00
 9822              	.LASF51:
 9823 0f9c 5F73697A 		.ascii	"_size\000"
 9823      6500
 9824              	.LASF14:
 9825 0fa2 5F6F6666 		.ascii	"_off_t\000"
 9825      5F7400
 9826              	.LASF62:
 9827 0fa9 5F6E6275 		.ascii	"_nbuf\000"
 9827      6600
 9828              	.LASF99:
 9829 0faf 5F756E75 		.ascii	"_unused_rand\000"
 9829      7365645F 
 9829      72616E64 
 9829      00
 9830              	.LASF148:
 9831 0fbc 7078546F 		.ascii	"pxTopOfStack\000"
 9831      704F6653 
 9831      7461636B 
 9831      00
 9832              	.LASF68:
 9833 0fc9 5F666C61 		.ascii	"_flags2\000"
 9833      67733200 
 9834              	.LASF267:
 9835 0fd1 76546173 		.ascii	"vTaskResume\000"
 9835      6B526573 
 9835      756D6500 
 9836              	.LASF45:
 9837 0fdd 5F69735F 		.ascii	"_is_cxa\000"
 9837      63786100 
 9838              	.LASF238:
 9839 0fe5 70784576 		.ascii	"pxEventListItem\000"
 9839      656E744C 
 9839      69737449 
 9839      74656D00 
 9840              	.LASF96:
 9841 0ff5 5F736565 		.ascii	"_seed\000"
 9841      6400
 9842              	.LASF104:
 9843 0ffb 5F72616E 		.ascii	"_rand_next\000"
 9843      645F6E65 
 9843      787400
 9844              	.LASF291:
 9845 1006 70784372 		.ascii	"pxCreatedTask\000"
ARM GAS  /tmp/cckqXCjj.s 			page 285


 9845      65617465 
 9845      64546173 
 9845      6B00
 9846              	.LASF59:
 9847 1014 5F736565 		.ascii	"_seek\000"
 9847      6B00
 9848              	.LASF285:
 9849 101a 70727641 		.ascii	"prvAddNewTaskToReadyList\000"
 9849      64644E65 
 9849      77546173 
 9849      6B546F52 
 9849      65616479 
 9850              	.LASF73:
 9851 1033 5F737464 		.ascii	"_stderr\000"
 9851      65727200 
 9852              	.LASF119:
 9853 103b 5F6E6D61 		.ascii	"_nmalloc\000"
 9853      6C6C6F63 
 9853      00
 9854              	.LASF61:
 9855 1044 5F756275 		.ascii	"_ubuf\000"
 9855      6600
 9856              	.LASF302:
 9857 104a 75635265 		.ascii	"ucReturn\000"
 9857      7475726E 
 9857      00
 9858              	.LASF272:
 9859 1053 75784375 		.ascii	"uxCurrentBasePriority\000"
 9859      7272656E 
 9859      74426173 
 9859      65507269 
 9859      6F726974 
 9860              	.LASF188:
 9861 1069 78596965 		.ascii	"xYieldPending\000"
 9861      6C645065 
 9861      6E64696E 
 9861      6700
 9862              		.ident	"GCC: (15:6.3.1+svn253039-1build1) 6.3.1 20170620"
ARM GAS  /tmp/cckqXCjj.s 			page 286


DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/cckqXCjj.s:20     .bss:0000000000000000 pxCurrentTCB
     /tmp/cckqXCjj.s:17     .bss:0000000000000000 $d
     /tmp/cckqXCjj.s:23     .bss:0000000000000004 pxReadyTasksLists
     /tmp/cckqXCjj.s:27     .bss:0000000000000068 xDelayedTaskList1
     /tmp/cckqXCjj.s:31     .bss:000000000000007c xDelayedTaskList2
     /tmp/cckqXCjj.s:35     .bss:0000000000000090 pxDelayedTaskList
     /tmp/cckqXCjj.s:39     .bss:0000000000000094 pxOverflowDelayedTaskList
     /tmp/cckqXCjj.s:43     .bss:0000000000000098 xPendingReadyList
     /tmp/cckqXCjj.s:47     .bss:00000000000000ac xTasksWaitingTermination
     /tmp/cckqXCjj.s:51     .bss:00000000000000c0 uxDeletedTasksWaitingCleanUp
     /tmp/cckqXCjj.s:55     .bss:00000000000000c4 xSuspendedTaskList
     /tmp/cckqXCjj.s:59     .bss:00000000000000d8 uxCurrentNumberOfTasks
     /tmp/cckqXCjj.s:63     .bss:00000000000000dc xTickCount
     /tmp/cckqXCjj.s:67     .bss:00000000000000e0 uxTopReadyPriority
     /tmp/cckqXCjj.s:71     .bss:00000000000000e4 xSchedulerRunning
     /tmp/cckqXCjj.s:75     .bss:00000000000000e8 xPendedTicks
     /tmp/cckqXCjj.s:79     .bss:00000000000000ec xYieldPending
     /tmp/cckqXCjj.s:83     .bss:00000000000000f0 xNumOfOverflows
     /tmp/cckqXCjj.s:87     .bss:00000000000000f4 uxTaskNumber
     /tmp/cckqXCjj.s:91     .bss:00000000000000f8 xNextTaskUnblockTime
     /tmp/cckqXCjj.s:95     .bss:00000000000000fc xIdleTaskHandle
     /tmp/cckqXCjj.s:99     .bss:0000000000000100 uxSchedulerSuspended
     /tmp/cckqXCjj.s:103    .text:0000000000000000 $t
     /tmp/cckqXCjj.s:110    .text:0000000000000000 xTaskCreate
     /tmp/cckqXCjj.s:214    .text:0000000000000082 prvInitialiseNewTask
     /tmp/cckqXCjj.s:374    .text:0000000000000164 prvAddNewTaskToReadyList
     /tmp/cckqXCjj.s:3347   .text:0000000000000f90 prvInitialiseTaskLists
     /tmp/cckqXCjj.s:502    .text:000000000000021c $d
     /tmp/cckqXCjj.s:512    .text:0000000000000238 $t
     /tmp/cckqXCjj.s:519    .text:0000000000000238 vTaskDelete
     /tmp/cckqXCjj.s:3513   .text:0000000000001068 prvDeleteTCB
     /tmp/cckqXCjj.s:3553   .text:0000000000001088 prvResetNextTaskUnblockTime
     /tmp/cckqXCjj.s:669    .text:0000000000000310 $d
     /tmp/cckqXCjj.s:681    .text:0000000000000334 $t
     /tmp/cckqXCjj.s:688    .text:0000000000000334 vTaskDelayUntil
     /tmp/cckqXCjj.s:1908   .text:000000000000090c vTaskSuspendAll
     /tmp/cckqXCjj.s:4721   .text:0000000000001650 prvAddCurrentTaskToDelayedList
     /tmp/cckqXCjj.s:1950   .text:0000000000000928 xTaskResumeAll
     /tmp/cckqXCjj.s:807    .text:00000000000003cc $d
     /tmp/cckqXCjj.s:812    .text:00000000000003d4 $t
     /tmp/cckqXCjj.s:819    .text:00000000000003d4 vTaskDelay
     /tmp/cckqXCjj.s:880    .text:0000000000000418 $d
     /tmp/cckqXCjj.s:884    .text:000000000000041c $t
     /tmp/cckqXCjj.s:891    .text:000000000000041c uxTaskPriorityGet
     /tmp/cckqXCjj.s:941    .text:000000000000044c $d
     /tmp/cckqXCjj.s:945    .text:0000000000000450 $t
     /tmp/cckqXCjj.s:952    .text:0000000000000450 uxTaskPriorityGetFromISR
     /tmp/cckqXCjj.s:1038   .text:00000000000004a0 $d
     /tmp/cckqXCjj.s:1042   .text:00000000000004a4 $t
     /tmp/cckqXCjj.s:1049   .text:00000000000004a4 vTaskPrioritySet
     /tmp/cckqXCjj.s:1239   .text:00000000000005b8 $d
     /tmp/cckqXCjj.s:1246   .text:00000000000005c8 $t
     /tmp/cckqXCjj.s:1253   .text:00000000000005c8 vTaskSuspend
     /tmp/cckqXCjj.s:2606   .text:0000000000000c40 vTaskSwitchContext
     /tmp/cckqXCjj.s:1413   .text:00000000000006b0 $d
ARM GAS  /tmp/cckqXCjj.s 			page 287


     /tmp/cckqXCjj.s:1423   .text:00000000000006cc $t
     /tmp/cckqXCjj.s:1429   .text:00000000000006cc prvTaskIsTaskSuspended
     /tmp/cckqXCjj.s:1487   .text:0000000000000708 $d
     /tmp/cckqXCjj.s:1492   .text:0000000000000710 $t
     /tmp/cckqXCjj.s:1499   .text:0000000000000710 vTaskResume
     /tmp/cckqXCjj.s:1599   .text:00000000000007a0 $d
     /tmp/cckqXCjj.s:1606   .text:00000000000007b0 $t
     /tmp/cckqXCjj.s:1613   .text:00000000000007b0 xTaskResumeFromISR
     /tmp/cckqXCjj.s:1743   .text:000000000000085c $d
     /tmp/cckqXCjj.s:1752   .rodata:0000000000000000 $d
     /tmp/cckqXCjj.s:1756   .text:0000000000000870 $t
     /tmp/cckqXCjj.s:1763   .text:0000000000000870 vTaskStartScheduler
     /tmp/cckqXCjj.s:1834   .text:00000000000008c4 $d
     /tmp/cckqXCjj.s:3295   .text:0000000000000f60 prvIdleTask
     /tmp/cckqXCjj.s:1843   .text:00000000000008dc $t
     /tmp/cckqXCjj.s:1850   .text:00000000000008dc vTaskEndScheduler
     /tmp/cckqXCjj.s:1897   .text:0000000000000908 $d
     /tmp/cckqXCjj.s:1901   .text:000000000000090c $t
     /tmp/cckqXCjj.s:1939   .text:0000000000000924 $d
     /tmp/cckqXCjj.s:1943   .text:0000000000000928 $t
     /tmp/cckqXCjj.s:2386   .text:0000000000000af0 xTaskIncrementTick
     /tmp/cckqXCjj.s:2125   .text:0000000000000a20 $d
     /tmp/cckqXCjj.s:2137   .text:0000000000000a44 $t
     /tmp/cckqXCjj.s:2144   .text:0000000000000a44 xTaskGetTickCount
     /tmp/cckqXCjj.s:2178   .text:0000000000000a5c $d
     /tmp/cckqXCjj.s:2182   .text:0000000000000a60 $t
     /tmp/cckqXCjj.s:2189   .text:0000000000000a60 xTaskGetTickCountFromISR
     /tmp/cckqXCjj.s:2226   .text:0000000000000a7c $d
     /tmp/cckqXCjj.s:2230   .text:0000000000000a80 $t
     /tmp/cckqXCjj.s:2237   .text:0000000000000a80 uxTaskGetNumberOfTasks
     /tmp/cckqXCjj.s:2264   .text:0000000000000a90 $d
     /tmp/cckqXCjj.s:2268   .text:0000000000000a94 $t
     /tmp/cckqXCjj.s:2275   .text:0000000000000a94 pcTaskGetName
     /tmp/cckqXCjj.s:2321   .text:0000000000000abc $d
     /tmp/cckqXCjj.s:2325   .text:0000000000000ac0 $t
     /tmp/cckqXCjj.s:2332   .text:0000000000000ac0 xTaskCatchUpTicks
     /tmp/cckqXCjj.s:2375   .text:0000000000000aec $d
     /tmp/cckqXCjj.s:2379   .text:0000000000000af0 $t
     /tmp/cckqXCjj.s:2585   .text:0000000000000c14 $d
     /tmp/cckqXCjj.s:2599   .text:0000000000000c40 $t
     /tmp/cckqXCjj.s:2709   .text:0000000000000cb8 $d
     /tmp/cckqXCjj.s:2717   .text:0000000000000ccc $t
     /tmp/cckqXCjj.s:2724   .text:0000000000000ccc vTaskPlaceOnEventList
     /tmp/cckqXCjj.s:2762   .text:0000000000000cf4 $d
     /tmp/cckqXCjj.s:2766   .text:0000000000000cf8 $t
     /tmp/cckqXCjj.s:2773   .text:0000000000000cf8 vTaskPlaceOnUnorderedEventList
     /tmp/cckqXCjj.s:2818   .text:0000000000000d30 $d
     /tmp/cckqXCjj.s:2822   .text:0000000000000d34 $t
     /tmp/cckqXCjj.s:2829   .text:0000000000000d34 xTaskRemoveFromEventList
     /tmp/cckqXCjj.s:2930   .text:0000000000000dc4 $d
     /tmp/cckqXCjj.s:2939   .text:0000000000000ddc $t
     /tmp/cckqXCjj.s:2946   .text:0000000000000ddc vTaskRemoveFromUnorderedEventList
     /tmp/cckqXCjj.s:3026   .text:0000000000000e50 $d
     /tmp/cckqXCjj.s:3033   .text:0000000000000e60 $t
     /tmp/cckqXCjj.s:3040   .text:0000000000000e60 vTaskSetTimeOutState
     /tmp/cckqXCjj.s:3080   .text:0000000000000e88 $d
     /tmp/cckqXCjj.s:3085   .text:0000000000000e90 $t
ARM GAS  /tmp/cckqXCjj.s 			page 288


     /tmp/cckqXCjj.s:3092   .text:0000000000000e90 vTaskInternalSetTimeOutState
     /tmp/cckqXCjj.s:3131   .text:0000000000000eb4 $d
     /tmp/cckqXCjj.s:3136   .text:0000000000000ebc $t
     /tmp/cckqXCjj.s:3143   .text:0000000000000ebc xTaskCheckForTimeOut
     /tmp/cckqXCjj.s:3245   .text:0000000000000f40 $d
     /tmp/cckqXCjj.s:3250   .text:0000000000000f48 $t
     /tmp/cckqXCjj.s:3257   .text:0000000000000f48 vTaskMissedYield
     /tmp/cckqXCjj.s:3285   .text:0000000000000f5c $d
     /tmp/cckqXCjj.s:3289   .text:0000000000000f60 $t
     /tmp/cckqXCjj.s:3436   .text:0000000000001010 prvCheckTasksWaitingTermination
     /tmp/cckqXCjj.s:3336   .text:0000000000000f88 $d
     /tmp/cckqXCjj.s:3341   .text:0000000000000f90 $t
     /tmp/cckqXCjj.s:3419   .text:0000000000000ff0 $d
     /tmp/cckqXCjj.s:3430   .text:0000000000001010 $t
     /tmp/cckqXCjj.s:3501   .text:000000000000105c $d
     /tmp/cckqXCjj.s:3507   .text:0000000000001068 $t
     /tmp/cckqXCjj.s:3606   .text:00000000000010c0 $d
     /tmp/cckqXCjj.s:3611   .text:00000000000010c8 $t
     /tmp/cckqXCjj.s:3618   .text:00000000000010c8 xTaskGetSchedulerState
     /tmp/cckqXCjj.s:3672   .text:00000000000010fc $d
     /tmp/cckqXCjj.s:3677   .text:0000000000001104 $t
     /tmp/cckqXCjj.s:3684   .text:0000000000001104 uxTaskResetEventItemValue
     /tmp/cckqXCjj.s:3727   .text:0000000000001130 $d
     /tmp/cckqXCjj.s:3731   .text:0000000000001134 $t
     /tmp/cckqXCjj.s:3738   .text:0000000000001134 ulTaskNotifyTake
     /tmp/cckqXCjj.s:3840   .text:00000000000011bc $d
     /tmp/cckqXCjj.s:3845   .text:00000000000011c4 $t
     /tmp/cckqXCjj.s:3852   .text:00000000000011c4 xTaskNotifyWait
     /tmp/cckqXCjj.s:3973   .text:0000000000001270 $d
     /tmp/cckqXCjj.s:3978   .text:0000000000001278 $t
     /tmp/cckqXCjj.s:3985   .text:0000000000001278 xTaskGenericNotify
     /tmp/cckqXCjj.s:4038   .text:00000000000012c0 $d
     /tmp/cckqXCjj.s:4043   .text:00000000000012d4 $t
     /tmp/cckqXCjj.s:4160   .text:0000000000001378 $d
     /tmp/cckqXCjj.s:4167   .text:0000000000001388 $t
     /tmp/cckqXCjj.s:4174   .text:0000000000001388 xTaskGenericNotifyFromISR
     /tmp/cckqXCjj.s:4247   .text:00000000000013e8 $d
     /tmp/cckqXCjj.s:4252   .text:00000000000013fc $t
     /tmp/cckqXCjj.s:4395   .text:00000000000014c0 $d
     /tmp/cckqXCjj.s:4404   .text:00000000000014d8 $t
     /tmp/cckqXCjj.s:4411   .text:00000000000014d8 vTaskNotifyGiveFromISR
     /tmp/cckqXCjj.s:4559   .text:00000000000015a4 $d
     /tmp/cckqXCjj.s:4568   .text:00000000000015bc $t
     /tmp/cckqXCjj.s:4575   .text:00000000000015bc xTaskNotifyStateClear
     /tmp/cckqXCjj.s:4640   .text:0000000000001604 $d
     /tmp/cckqXCjj.s:4644   .text:0000000000001608 $t
     /tmp/cckqXCjj.s:4651   .text:0000000000001608 ulTaskNotifyValueClear
     /tmp/cckqXCjj.s:4711   .text:000000000000164c $d
     /tmp/cckqXCjj.s:4715   .text:0000000000001650 $t
     /tmp/cckqXCjj.s:4839   .text:0000000000001700 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
pvPortMalloc
vPortFree
vListInitialiseItem
pxPortInitialiseStack
ARM GAS  /tmp/cckqXCjj.s 			page 289


vPortEnterCritical
vListInsertEnd
vPortExitCritical
uxListRemove
xPortStartScheduler
vPortEndScheduler
vListInsert
vListInitialise
